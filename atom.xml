<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KobeLuo的技术笔记</title>
  
  <subtitle>不完美源自对完美的追求</subtitle>
  <link href="/TECH/atom.xml" rel="self"/>
  
  <link href="http://kobeluo.com/"/>
  <updated>2019-01-21T08:07:06.370Z</updated>
  <id>http://kobeluo.com/</id>
  
  <author>
    <name>KOBE LUO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Monitor Filesystem on Mac OS X 未完结</title>
    <link href="http://kobeluo.com/2019/01/15/monitorFSOnOSX/"/>
    <id>http://kobeluo.com/2019/01/15/monitorFSOnOSX/</id>
    <published>2019-01-15T10:02:18.000Z</published>
    <updated>2019-01-21T08:07:06.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近各大网络磁盘厂商都推出了使用才下载的文件同步功能，类似<strong>Dropbox</strong>的<a href="https://www.dropbox.com/smartsync" target="_blank" rel="noopener">SmartSync</a>, <strong>oneDrive</strong>的<a href="https://www.theverge.com/2018/9/24/17896018/microsoft-onedrive-files-on-demand-macos-mac-feature" target="_blank" rel="noopener">Store aways</a>等，他们都是实现了远端文件在本地的可视化，但仅仅对部分需要修改或查看的文件提供下载的功能，这样就大大降低了同步过程消耗的时间和流量，仅仅只是下载需要下载的几个文件，这是个非常先进的设计思路，该功能真正体现了云盘的优势和价值。</p><p>博主的工作也刚好是云盘相关的业务，因此对于其背后的原理进行了一些探索，得到了一些有用的信息，其中就包括对于文件系统监控的部分知识。</p><a id="more"></a><h3 id="APFS文件系统监控"><a href="#APFS文件系统监控" class="headerlink" title="APFS文件系统监控"></a>APFS文件系统监控</h3><p>Mac OS X上关于文件系统监控的方法有很多种，博主只是知道其中的一小部分，列举如下:</p><h4 id="FSEventStream"><a href="#FSEventStream" class="headerlink" title="FSEventStream"></a><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html" target="_blank" rel="noopener">FSEventStream</a></h4><p>FSEventStream是苹果官方提供的一套标准的监控文件事件的API,它通过给定的路径和一些参数来控制监控的数据细节，并传入一个<code>callback</code>来接收所有从APFS底层传回的所有事件列表；其关键函数如下：<br><figure class="highlight objc"><figcaption><span>注册函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!_watchPath) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFStringRef</span> watchDir = (__bridge <span class="built_in">CFStringRef</span>)_watchPath;</span><br><span class="line">        <span class="built_in">CFArrayRef</span> pathsToWatch = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;watchDir, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        FSEventStreamContext *fseventContext = (FSEventStreamContext *)malloc(<span class="keyword">sizeof</span>(FSEventStreamContext));</span><br><span class="line">        fseventContext-&gt;version = <span class="number">0</span>;</span><br><span class="line">        fseventContext-&gt;info = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">        fseventContext-&gt;<span class="keyword">retain</span> = <span class="literal">NULL</span>;</span><br><span class="line">        fseventContext-&gt;release = <span class="literal">NULL</span>;</span><br><span class="line">        fseventContext-&gt;copyDescription = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        FSEventStreamCreateFlags flags = kFSEventStreamCreateFlagNone |</span><br><span class="line">                                         kFSEventStreamCreateFlagWatchRoot |</span><br><span class="line">                                         kFSEventStreamEventFlagItemXattrMod |</span><br><span class="line">                                         kFSEventStreamCreateFlagFileEvents;</span><br><span class="line">        </span><br><span class="line">        FSEventStreamRef stream = FSEventStreamCreate(<span class="literal">NULL</span>,</span><br><span class="line">                                                      &amp;watchCallback,</span><br><span class="line">                                                      fseventContext,</span><br><span class="line">                                                      pathsToWatch,</span><br><span class="line">                                                      kFSEventStreamEventIdSinceNow,</span><br><span class="line">                                                      <span class="number">1.0</span>,</span><br><span class="line">                                                      flags);</span><br><span class="line">        </span><br><span class="line">        _loop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        FSEventStreamScheduleWithRunLoop(stream, _loop, kCFRunLoopDefaultMode);</span><br><span class="line">        FSEventStreamStart(stream);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">        </span><br><span class="line">        FSEventStreamStop(stream);</span><br><span class="line">        FSEventStreamInvalidate(stream);</span><br><span class="line">        FSEventStreamRelease(stream);</span><br><span class="line">        free(fseventContext);</span><br><span class="line">        <span class="built_in">CFRelease</span>(pathsToWatch);</span><br><span class="line">        stream = <span class="literal">NULL</span>;</span><br><span class="line">        fseventContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里边有很多的参数都可以按照你的需要去设定，具体怎么设定请参考<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html" target="_blank" rel="noopener">官方资料</a>。</p><figure class="highlight objc"><figcaption><span>回调函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> watchCallback(ConstFSEventStreamRef streamRef,</span><br><span class="line">                          <span class="keyword">void</span> *clientCallBackInfo,</span><br><span class="line">                          size_t numEvents,</span><br><span class="line">                          <span class="keyword">void</span> *eventPaths,</span><br><span class="line">                          <span class="keyword">const</span> FSEventStreamEventFlags eventFlags[],</span><br><span class="line">                          <span class="keyword">const</span> FSEventStreamEventId eventIds[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> **paths = eventPaths;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numEvents; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> flag = eventFlags[i];</span><br><span class="line">        printf(<span class="string">"Change %llu in %s, flags %u\n"</span>, eventIds[i], paths[i], flag);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag == kFSEventStreamEventFlagNone) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagNone"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagMustScanSubDirs) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagMustScanSubDirs"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagUserDropped) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagUserDropped"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagKernelDropped) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagKernelDropped"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagEventIdsWrapped) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagEventIdsWrapped"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagHistoryDone) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagHistoryDone"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagRootChanged) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagRootChanged"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagMount) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagMount"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagUnmount) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagUnmount"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemCreated) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemCreated"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag&amp; kFSEventStreamEventFlagItemRemoved) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemRemoved"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemInodeMetaMod) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemInodeMetaMod"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemRenamed) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemRenamed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemModified) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemModified"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemFinderInfoMod) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemFinderInfoMod"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemChangeOwner) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemChangeOwner"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemXattrMod) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemXattrMod"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemIsFile) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemIsFile"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemIsDir) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemIsDir"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; kFSEventStreamEventFlagItemIsSymlink) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kFSEventStreamEventFlagItemIsSymlink"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"i don't know!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过回调函数，当文件系统指定的目录及其递归子目录发生变更时，会将对应的事件回调到该函数中，拿到事件后，再继续做后续操作即可。<br>FSEventStream可以跟踪到事件的发送过程，它得定义是当事件发生后，系统回调给注册者，如果要求是事件发生前先得到信息，根据博主的理解，FSEventStream可能无法满足需求。</p><h4 id="NSFileCoordinator-amp-NSFilePresenter"><a href="#NSFileCoordinator-amp-NSFilePresenter" class="headerlink" title="NSFileCoordinator &amp; NSFilePresenter"></a>NSFileCoordinator &amp; NSFilePresenter</h4><p><a href="https://developer.apple.com/documentation/foundation/nsfilecoordinator" target="_blank" rel="noopener">NSFileCoordinator</a>和<a href="https://developer.apple.com/documentation/foundation/nsfilepresenter" target="_blank" rel="noopener">NSFilePresenter</a>,可以结合起来使用，以达到监控某个路径文件的事件，它是iCloud开发必须掌握的知识，实现的核心方法如下:</p><div class="note info"><p>1.创建一个class并遵循<nsfilepresenter>协议，<br>2.初始化时，将self添加至NSFileCoordinator中，<br>3.实现NSFilePresenter协议要求的方法，会自动让你填写监控的url和回调函数.<br>4.打印log监控回调事件.</nsfilepresenter></p></div><p>利用NSFilePresenter方式可以监控到文件系统调用<code>open</code>和<code>release</code>时的回调，值得注意的是该系列函数是在文件执行操作之前回调的，这对于实现类似Dropbox的smartSync功能尤为重要，当文件双击时，首先调用该函数，然后启动下载，下载完成后，再调用默认打开进程去打开文件。</p><p><strong>PS:</strong>文章中提到的<code>FSEventStream</code>和<code>NSFileCoordinate</code>相关的代码均来自:<a href="https://github.com/KobeLuo/DemoRepo/tree/develop/HybridDemo" target="_blank" rel="noopener">Demo地址</a>， 如果需要可以点击下载代码。</p><h4 id="fswatch"><a href="#fswatch" class="headerlink" title="fswatch"></a>fswatch</h4><p><a href="https://github.com/emcrisostomo/fswatch" target="_blank" rel="noopener">fswatch</a>是github上的一个开源项目，作者将多种文件监控的方法汇聚到该开源项目中，该项目可以监控来自多个操作系统下的文件事件监控，有兴趣的可以仔细查阅。</p><p>fswatch有很多使用方式，其HTML文档地址<a href="https://emcrisostomo.github.io/fswatch/doc/" target="_blank" rel="noopener">在这儿</a>,下面是一个经典的使用实例： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fswatch -xr /path/to/observe</span><br></pre></td></tr></table></figure><p>该实例可以监控到指定目录下的文件的变化情况。</p><h4 id="Dtrace"><a href="#Dtrace" class="headerlink" title="Dtrace"></a>Dtrace</h4><p>这是一个神级工具，该工具位于OSX系统<code>/usr/bin/dtrace</code>位置，Instrument绝大部分统计工具其背后统计数据均来自<code>dtrace</code>，由于dtrace直接操作系统内核，所以需要的权限非常高，如果需要使用dtrace来实现一些牛逼的功能，需要更改一些电脑的权限，由于其强大的功能，博主并未深究，实在不敢误人子弟，具体如何使用，还请自行查阅。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>目前博主在实现类似Dropbox的smartSync功能使用 sparse file + NSFilePresenter相结合的方式，可以实现功能，但由于NSFilePresenter只能监控某一个文件，如果想要获得指定目录及其递归子目录监控，就需要建立大量的FilePresenter，这在性能上是一个瓶颈，也是一种不太好的方式，目前还未找到更好的解决方案！！！<br>如果有大神有更好的方案，还请赐教一二，博主邮箱地址: <a href="mailto:kobev5@126.com" target="_blank" rel="noopener">kobev5@126.com</a>，也欢迎您给我发邮件探讨关于Mac和iOS上的技术问题。</p><h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><ul><li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html" target="_blank" rel="noopener">FSEventStream Documentation</a></li><li><a href="https://www.jianshu.com/p/7c37b39b143e" target="_blank" rel="noopener">FSEventStream Blog1</a></li><li><a href="https://blog.csdn.net/lovechris00/article/details/78080598" target="_blank" rel="noopener">FSEventStream Blog2</a></li><li><a href="https://developer.apple.com/documentation/foundation/nsfilecoordinator" target="_blank" rel="noopener">NSCoordinator</a></li><li><a href="https://developer.apple.com/documentation/foundation/nsfilepresenter" target="_blank" rel="noopener">NSFilePresenter</a></li><li><a href="https://github.com/emcrisostomo/fswatch" target="_blank" rel="noopener">fswatch</a></li><li><a href="http://dtrace.org/blogs/brendan/2011/10/10/top-10-dtrace-scripts-for-mac-os-x/" target="_blank" rel="noopener">DTrace</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近各大网络磁盘厂商都推出了使用才下载的文件同步功能，类似&lt;strong&gt;Dropbox&lt;/strong&gt;的&lt;a href=&quot;https://www.dropbox.com/smartsync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SmartSync&lt;/a&gt;, &lt;strong&gt;oneDrive&lt;/strong&gt;的&lt;a href=&quot;https://www.theverge.com/2018/9/24/17896018/microsoft-onedrive-files-on-demand-macos-mac-feature&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Store aways&lt;/a&gt;等，他们都是实现了远端文件在本地的可视化，但仅仅对部分需要修改或查看的文件提供下载的功能，这样就大大降低了同步过程消耗的时间和流量，仅仅只是下载需要下载的几个文件，这是个非常先进的设计思路，该功能真正体现了云盘的优势和价值。&lt;/p&gt;
&lt;p&gt;博主的工作也刚好是云盘相关的业务，因此对于其背后的原理进行了一些探索，得到了一些有用的信息，其中就包括对于文件系统监控的部分知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="Monitor FS" scheme="http://kobeluo.com/tags/Monitor-FS/"/>
    
      <category term="监控文件系统" scheme="http://kobeluo.com/tags/%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="FSEvent" scheme="http://kobeluo.com/tags/FSEvent/"/>
    
      <category term="MACF" scheme="http://kobeluo.com/tags/MACF/"/>
    
      <category term="fswatch" scheme="http://kobeluo.com/tags/fswatch/"/>
    
      <category term="Dtrace" scheme="http://kobeluo.com/tags/Dtrace/"/>
    
      <category term="NSFileCoordinate" scheme="http://kobeluo.com/tags/NSFileCoordinate/"/>
    
  </entry>
  
  <entry>
    <title>细数Mac OS/iOS 系统下的锁(lock)</title>
    <link href="http://kobeluo.com/2018/11/13/os-lock/"/>
    <id>http://kobeluo.com/2018/11/13/os-lock/</id>
    <published>2018-11-13T03:30:49.000Z</published>
    <updated>2018-11-16T05:42:50.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近一段时间，博主都在做代码性能上的一些优化工作，其中就包括了对Mac OS/iOS锁这一部分的优化，趁此机会，也比较系统的测试了各种用户态的锁分别在单个线程和多个线程中的表现。之所以叫用户态的锁，是因为Mach内核部分其实还有一部分内核态的锁，它并不为用户态所开放，我们一般也使用不到。</p><p>对同一个锁对象的加解锁必须保持在同一线程执行，如果尝试在不同线程去加解锁将会引发一个运行时的错误。</p><h4 id="用户态可用的锁"><a href="#用户态可用的锁" class="headerlink" title="用户态可用的锁"></a>用户态可用的锁</h4><p>用户态的锁大概有以下:</p><ul><li>NSLock</li><li>NSRecusiveLock</li><li>pthread_mutex_t </li><li>pthread_mutex_t (recusive)</li><li>NSCondition</li><li>NSConditionLock</li><li>dispatch_semaphore_t</li><li>os_unfair_lock</li><li>OS_SPLINK_LOCK</li><li>@synchronized</li></ul><a id="more"></a><h4 id="内核态的锁"><a href="#内核态的锁" class="headerlink" title="内核态的锁"></a>内核态的锁</h4><p>而内核态的锁大概有以下几类: </p><ul><li>lck_mtx_t (互斥体)<br>互斥体是内核内存中的普通变量，是一个机器字大小的整数，但是它要求硬件必须对这些互斥体进行原子(atomic)操作</li><li>lck_rw_t （读写锁）<br>一个更高级的互斥体，多个读者可以同时持有锁，而同时只能有一个写者持有该锁。一旦写者持有该锁，其它线程全部都将被阻塞</li><li>hw_lock_t （自旋锁）<br>内核态的自旋锁跟用户态的自旋锁(OS_SPLIN_LOCK)并不是一个概念，内核态的自旋锁实际上是为了解决互斥体在频繁的线程切换过程中带来的开销而设计的，当锁被阻塞时，它不会主动交出线程的处理器，而处于一种重复尝试访问锁的忙等状态(busy-wait)，如果当前访问的锁的持有者在它访问几个周期后就放弃持有了，那么它的效率就比较高，省去了很多上下文切换带来的开销，同时，他也可能造成死锁，整个系统可能会因此而停滞。</li><li>semaphore (信号量)<br>其实它是一个用户态的锁，Mach中的信号量跟POSIX中的信号量不是一个概念，API也不一样，但是XNU上POSIX信号量的底层是通过Mach信号量来实现的。</li></ul><p>关于内核态的同步机制，博主也写了一篇<a href="http://www.kobeluo.com/TECH/2018/10/31/mach-synchronization/" target="_blank" rel="noopener">学习笔记</a>,有兴趣可以了解一下。</p><h3 id="锁的测试结果"><a href="#锁的测试结果" class="headerlink" title="锁的测试结果"></a>锁的测试结果</h3><p>针对用户态可用的锁，博主做了一个较为详细的测试，由于使用的是Swift来测试锁的性能，所以在Objective-C中使用的<code>@synchronized</code>并没有在本次测试范围，实际上@synchronized可能是最消耗性能的一种锁。，测试源码<a href="https://github.com/KobeLuo/DemoRepo/blob/master/OSLockCompareDemo/OSLockCompareDemo/OSLockCompare.swift" target="_blank" rel="noopener">在这</a></p><p>简单看以下测试的源代码片段<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testSemaphore</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...repeatTimes &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> start = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">            </span><br><span class="line">            sema.wait()</span><br><span class="line">            <span class="comment">//如果要去掉上下文，则注释该print</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"index: <span class="subst">\(index)</span> "</span>)</span><br><span class="line">            sema.signal()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> end = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">            <span class="keyword">self</span>.recordTimeFor(type: <span class="type">OSLockType</span>.l_Semaphore, time: end - start)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码时测试信号量(semaphore)时的核心代码，该段代码有两种测试方式，一种是保留上下文，另外一种则是去掉上下文。</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>以下是测试结果的汇总：</p><ul><li>测试环境:   Mac OS X 10.14.1 Beta (18B57c)， Xcode: Version 9.4.1 (9F2000)</li><li>为了全部数据格式统一和去掉上下文的数据更准确，本次测试所有时间单位统一为(us/10),即0.1微妙为单位。</li><li>对于单线程的条形图，数据表示每一次加锁和解锁的平均消耗</li><li><p>对于多线程的条形图，数据表示5个线程完成一次加锁和解锁的平均消耗</p></li><li><p>测试发现<code>OSUnfairLock</code>、<code>semaphore</code>、<code>mutex</code>在各种环境下的表现最稳定，性能差距不大，应该作为锁的首选考虑。</p></li></ul><p>本次测试博主尝试了Repeat不同的次数下，各类锁的耗时情况，发现各类锁的耗时大小顺序并不是固定的，并且差异挺大，仅仅只有单线程且去掉上下文的情况下，测试结果相对稳定，博主猜测大概是因为测试时电脑瞬时性能、CPU使用情况和内核调度的情况有关系，具体原因不敢妄下结论。</p><h4 id="测试结果总结"><a href="#测试结果总结" class="headerlink" title="测试结果总结"></a>测试结果总结</h4><p><strong>测试结果只能从某个方面反映出锁的效率，也许它并不是最准确的结果，它是在特定环境下的真实测试结果。</strong></p><p>去掉上下文的测试结果，仅仅只能说明锁本身的实现复杂度和内部的执行效率,它并不能说明锁在实际使用过程中，结合上下文的执行效率，只能作为理论依据。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>关于多线程的测试，其核心片段代码如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">startThreadCompare</span>(_ <span class="title">testTimes</span>: <span class="title">Int</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//initial class</span></span><br><span class="line">    <span class="keyword">let</span> compare = <span class="type">OSLockCompare</span>.<span class="keyword">init</span>(testTimes: testTimes)</span><br><span class="line">    <span class="comment">//test locks</span></span><br><span class="line">    compare.testLocks()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="单线程，去掉上下文"><a href="#单线程，去掉上下文" class="headerlink" title="单线程，去掉上下文"></a>单线程，去掉上下文</h5><p><img src="/TECH/2018/11/13/os-lock/singleAndContextResign.png" alt="测试元数据"><br><img src="/TECH/2018/11/13/os-lock/contextResignSingle.png" alt="测试图表"></p><p>从元数据清单表格上可以看出，随着Repeat次数的逐步增大，信号量(<code>Semaphore</code>)的执行效率逐渐变得更优优势，其次是<code>SpinLock</code>，<code>mutex</code>，<code>unfairLock</code>，效率最低的是<code>NSConditionLock</code><br>至于为什么量级越大，不同的锁在纯粹的加减锁过程中的效率表现会出现差异，有待进一步研究，同时也希望各路大神指点一二。</p><h5 id="单线程，保留上下文"><a href="#单线程，保留上下文" class="headerlink" title="单线程，保留上下文"></a>单线程，保留上下文</h5><p><img src="/TECH/2018/11/13/os-lock/singleAndContextKeep.png" alt="测试元数据"><br><img src="/TECH/2018/11/13/os-lock/contextKeepSingle.png" alt="测试图表"></p><p>在保留上下文的情况下，使用相同的方式去测试单线程下各类锁的性能消耗，得到了一个与去掉上下文完全不同的结果，在仅仅只执行<code>print</code>函数的上下文情况下，发现OSUnfairLock的效率是最高的，其次是<code>mutex</code>、<code>semaphore</code>，最差的是<code>OSSpinLock</code>。</p><p>单线程测试发现：</p><ul><li>在低频次的加减锁情况下，<code>unfairLock</code>的表现是最好的。</li><li>在高频次的加减锁情况下，<code>semaphore</code>的表现是最好的。</li></ul><p>同时发现其它的一些大牛写的博文跟这里的结果并不一致，这可能跟测试方式、当前OS系统运行情况等多方面有关系，博主所呈现的是真实的测试数据。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>关于多线程的测试，其核心片段代码如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">startMultiThreadCompare</span>(_ <span class="title">testTimes</span>: <span class="title">Int</span>, <span class="title">threadCount</span>: <span class="title">Int</span>, <span class="title">ci</span>: @<span class="title">escaping</span> <span class="title">invokeBlock</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> compare = <span class="type">OSLockCompare</span>.<span class="keyword">init</span>(testTimes: testTimes, threadCount)</span><br><span class="line">    <span class="keyword">let</span> labelbase = <span class="string">"com.compare.oslock"</span></span><br><span class="line">    </span><br><span class="line">    compare.invoke = ci</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> subQueues = [<span class="type">DispatchQueue</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...threadCount &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> label = labelbase + <span class="string">".<span class="subst">\(index)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> seriaQueue = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: label)</span><br><span class="line">        </span><br><span class="line">        seriaQueue.async &#123; compare.testLocks() &#125;</span><br><span class="line">        </span><br><span class="line">        subQueues.append(seriaQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    compare.queues = subQueues</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试数据中的多线程的<em>Average Per time</em>是指多个线程同时完成一次加减锁所需要的时间。本例是5个线程</p><h5 id="多线程，去掉上下文"><a href="#多线程，去掉上下文" class="headerlink" title="多线程，去掉上下文"></a>多线程，去掉上下文</h5><p><img src="/TECH/2018/11/13/os-lock/multiAndContextResign.png" alt="测试元数据"><br><img src="/TECH/2018/11/13/os-lock/contextResgnMulti.png" alt="测试图表"></p><p>通过测试数据可以发现，</p><ul><li><code>OSUnfairLock</code>在5个线程同时测试锁的性能时，表现最优越，其平均消耗远低于其它锁，信号量<code>Semaphore</code>次之，<code>mutex</code>紧随其后。</li><li>而类似于<code>NSLock</code>,<code>NSConditionLock</code>等更上层的锁在多线程环境下的综合表现则很一般。单线程的锁更多的是作为一种理论而存在，而多线程的测试数据则重要得多，它可能更接近于我们日常开发的需要。</li><li>对比单线程，去掉上下文的数据，多线程的耗时多了很多，除了多个线程同时加减锁所耗费的时间外，更多的消耗则用在了线程之间的来回切换。</li></ul><h5 id="多线程，保留上下文"><a href="#多线程，保留上下文" class="headerlink" title="多线程，保留上下文"></a>多线程，保留上下文</h5><p><img src="/TECH/2018/11/13/os-lock/multiAndContextKeep.png" alt="测试元数据"><br><img src="/TECH/2018/11/13/os-lock/contextKeepMulti.png" alt="测试图表"></p><p>在这组综合测试中，<code>OSUnfairLock</code>依然稳居榜首，而<code>mutex</code>和<code>semaphore</code>则排在稍微靠后的位置上，博主猜测可能是因为频繁的线程切换导致的性能损失。</p><h3 id="各类锁介绍"><a href="#各类锁介绍" class="headerlink" title="各类锁介绍"></a>各类锁介绍</h3><p>Mac OS/iOS系统下，用户态的锁使用方式都相对简单，大部分都进行了封装，像<code>NSLock</code>,<code>NSConditionLock</code>,<code>NSRecusiveLock</code>等等，他们只暴露必要的接口，而降实现细节全部隐藏起来由内部函数去处理，这些锁在ARC系统下不需要管理内存；也有一部分较为底层的锁，像<code>pthread_mutex</code>，<code>OSUnfairLock</code>等，但他们的使用都非常的方便简单。</p><h4 id="OSSpinLock-不再安全的自旋锁"><a href="#OSSpinLock-不再安全的自旋锁" class="headerlink" title="OSSpinLock 不再安全的自旋锁"></a>OSSpinLock 不再安全的自旋锁</h4><p>POSIX下的自旋锁的设计原理跟Mach内核的自旋锁原理一致。</p><p>苹果的工程师已经<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151214/000372.html" target="_blank" rel="noopener">证实</a>了OSSpinLock在多种优先级并存的环境中同时访问自旋锁由于优先级反转问题致使持有自旋锁的低优先级线程无法获取CPU资源，导致高优先级线程产生忙等的问题。具体请看ibireme大神<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">这篇文章</a>,</p><p>结论是：如果无法确定当前多线程环境的所有线程是同一个优先级，请勿使用OSSpinLock.</p><p>Apple在OSX 10.12/iOS 10上使用<code>OSUnfairLock</code>替代了<code>OSSpinLock</code>,后面将会提及<code>OSUnfaieLock</code>相关消息及使用方法。</p><p>其使用方法如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> splinLock = <span class="type">OS_SPINLOCK_INIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark: test locks</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testOSSpinlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">OSSpinLockLock</span>(&amp;splinLock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//code block in here...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">OSSpinLockUnlock</span>(&amp;splinLock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OSUnfairLock"><a href="#OSUnfairLock" class="headerlink" title="OSUnfairLock"></a>OSUnfairLock</h4><p><code>OSUnfairLock</code>是在Mac OSX 10.12上，Mac给出了替换<code>OSSpinLock</code>的方案，它也是一个底层的锁对象，与<code>OSSpinLock</code>不同的是，他不再是采用忙等的方式，而是睡眠，知道该锁被unlock时被内核唤醒。官方文档还提到<br><div class="note info"><p>A lock should be considered opaque and implementation-defined. Locks contain thread ownership information that the system may use to attempt to resolve priority inversions.</p><p>//一个锁应该被是不透明的且有实现的定义，锁对象包括的拥有者信息可以用来解决优先级反转问题。</p></div></p><p>其使用方式如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> unfair = os_unfair_lock()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testOSUnfairLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    os_unfair_lock_lock(&amp;unfair)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//your code block in here.</span></span><br><span class="line">    </span><br><span class="line">    os_unfair_lock_unlock(&amp;unfair)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h4><p><code>pthread_mutex_t</code>是 linux系统下的互斥体，属于底层锁，但它跟Mach内核太的互斥体不是一回事，实际上POSIX下的互斥体的底层实现应该是使用了Mach内核的互斥体(<code>lck_mtx_t</code>),，POSIX下的互斥体文档中有很多函数实现，以下仅简单说明重要的函数使用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化互斥体</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_attr_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">//初始化一个pthread的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_attr_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">//销毁一个曾经初始化的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_attr_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">///设置pthread属性的类型,分别是</span></span><br><span class="line"><span class="comment">/// PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_ERRORCHECK</span></span><br><span class="line"><span class="comment">/// PTHREAD_MUTEX_DEFAULT, PTHREAD_MUTEX_RECURSIVE</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_mutexattr_t&gt;, <span class="number">_</span>: Int32)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化mutex</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_mutex_t&gt;, <span class="number">_</span>: UnsafePointer&lt;pthread_mutexattr_t&gt;?)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">//给指定的mutex加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_mutex_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">//尝试给指定的mutex加锁，是pthread_mutex_lock的非阻塞版本，返回0则加锁成功，返回其它值以表示当前锁的状态。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_mutex_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="comment">//给指定的mutex解锁，必须入pthread_mutex_lock或成功执行的pthread_mutex_trylock成对出现</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="number">_</span>: UnsafeMutablePointer&lt;pthread_mutex_t&gt;)</span></span> -&gt; <span class="type">Int32</span></span><br></pre></td></tr></table></figure></p><h5 id="互斥锁的简单使用"><a href="#互斥锁的简单使用" class="headerlink" title="互斥锁的简单使用"></a>互斥锁的简单使用</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line"></span><br><span class="line"><span class="comment">//initial mutex</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testPthreadMutex</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;mutex)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//your code block in here...</span></span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归互斥锁的简单使用"><a href="#递归互斥锁的简单使用" class="headerlink" title="递归互斥锁的简单使用"></a>递归互斥锁的简单使用</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmutex = pthread_mutex_t()</span><br><span class="line"></span><br><span class="line"><span class="comment">//initial recusive mutex</span></span><br><span class="line"><span class="keyword">var</span> attr: pthread_mutexattr_t = pthread_mutexattr_t()</span><br><span class="line">pthread_mutexattr_init(&amp;attr)</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, <span class="type">PTHREAD_MUTEX_RECURSIVE</span>)</span><br><span class="line">pthread_mutex_init(&amp;rmutex, &amp;attr)</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testPthreadMutexRecusive</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;rmutex)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//your code block in here...</span></span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;rmutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dispatch-semaphore-t"><a href="#Dispatch-semaphore-t" class="headerlink" title="Dispatch_semaphore_t"></a>Dispatch_semaphore_t</h4><p>信号量跟其它的锁概念有所不同，OS上的锁其本质上都是通过Mach内核中的互斥锁<code>lck_mtx_t</code>根据不同的不同的场景需求而设计的锁，它们大多采用阻塞的方式，少部分使用忙等的方式；而信号量不一致，它是使用信号的方式来控制多线程对于资源的控制，并且信号量可同时释放信号量以保证多个线程同时访问资源，博主曾经写过<a href="http://www.kobeluo.com/TECH/2017/03/28/dispatch-semaphore/" target="_blank" rel="noopener">这篇博客</a>对信号量的用法做了分析。</p><p>简单使用方式大致如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> sema: <span class="type">DispatchSemaphore</span> = <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testSemaphore</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    sema.wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// your code block in here...</span></span><br><span class="line">    </span><br><span class="line">    sema.signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSLock-NSRecusiveLock"><a href="#NSLock-NSRecusiveLock" class="headerlink" title="NSLock / NSRecusiveLock"></a>NSLock / NSRecusiveLock</h4><p><code>NSLock</code>是OS封装的一个上层锁对象，它可以用来间接的读取全局数据或者保护一个临界区域的代码安全，<code>NSLock</code>支持原子操作。</p><div class="note danger"><p>NSLock使用 POSIX线程来实现Lock的行为，当发送一个<code>unlock()</code>消息到NSLock对象，你必须确保之前在同样的线程已经发送了一个<code>lock()</code>消息,<br>对于同一个NSLock锁的实例，如果<code>lock()</code>和<code>unlock()</code>不在同一线程，将引发一个未知的错误（can result in undefined behavior.）。</p></div><p>NSLock无法支持对同一个NSLock的实例连续进行两次及以上的<code>lock()</code>操作，否则会引发死锁，如果需要递归的调用<code>lock()</code>操作，应该是用<code>NSRecusiveLock</code>。</p><p><code>Unlocking a lock that is not locked is considered a programmer error and should be fixed in your code</code><br>如果你尝试解锁一个未被加锁的NSLock对象，这被认为是程序员的错误，同时输出一个类似的错误在console上。</p><p>其简单使用如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testNSLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    lock.lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// your code block in here...</span></span><br><span class="line">    </span><br><span class="line">    lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rlock = <span class="type">NSRecursiveLock</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testNSRecusiveLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    rlock.lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//your code block in here ...</span></span><br><span class="line">    </span><br><span class="line">    rlock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><div class="note info"><p>官方文档:<br>A condition object acts as both a lock and a checkpoint in a given thread. The lock protects your code while it tests the condition and performs the task triggered by the condition. The checkpoint behavior requires that the condition be true before the thread proceeds with its task. While the condition is not true, the thread blocks. It remains blocked until another thread signals the condition object.</p></div><p>一个Condition对象被用于指定线程的checkpoint或一个锁。 作为锁，可以在当测试某种条件和执行有条件触发的任务时来保护你的代码。作为checkpoint，其要求在线程执行完之前，condition为true,否则该线程将被一直锁住,直到另一个线程发送一个condition对象的信号。</p><p><code>NSCondition</code>官方使用六大步：</p><ul><li>lock condition对象(<code>condition.lock()</code>)</li><li>添加一个bool量的判断，用来指示是否需要继续执行下面受保护的内容</li><li>如果bool量为false,则调用<code>wait()</code>或<code>wait(until:)</code>函数，用以锁住当前线程，从这个循环返回后继续回到步骤2，继续测试bool量<br>归纳起来就是 <code>while (boolvalue == false) { condition.wait() }</code></li><li>如果bool量为true了，则继续向下执行受保护的内容。</li><li>可选项，更新条件或发送一个condition信号,如果需要的话。(<code>conditon.signal()</code> or <code>condition.broadcast()</code>)</li><li>当所有工作完成时，调用 <code>conditon.unlock()</code></li></ul><p>简单的锁使用方式如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> condition = <span class="type">NSCondition</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testNSCondition</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    condition.lock()</span><br><span class="line">    <span class="keyword">while</span>( booleanvalue == <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    condition.wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//your code in here...</span></span><br><span class="line"></span><br><span class="line">    condition.unlock()    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set the booleanvalue to true in a given time.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为上层锁，其内部实现复杂度是要高于底层锁的，因此从性能上开率，除特殊需求外，不建议使用此类锁。</p><p>最后再上一段官方的使用心得：<br><div class="note info"><p>Whenever you use a condition object, the first step is to lock the condition. Locking the condition ensures that your predicate and task code are protected from interference by other threads using the same condition. Once you have completed your task, you can set other predicates or signal other conditions based on the needs of your code. You should always set predicates and signal conditions while holding the condition object’s lock.</p></div></p><h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>使用NSConditionLock对象需要确保线程可以在确定的条件下拿到锁，一旦拿到锁并执行了关键区域的代码(被保护的代码)，该线程可以丢弃该锁或者设置新的相关条件，条件是不固定的，根据你的项目而自定。</p><p>其简单使用如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="type">NSConditionLock</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testNSConditionLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">clock.lock()</span><br><span class="line">    <span class="comment">///your code block in here...</span></span><br><span class="line">    clock.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// clock.try() 尝试加锁，如果成功获取锁，则返回一个正值，否则返回负值， try()成功，才可以unlock(),否则引发一个未知错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>这是Objective-C上面封装的一个上层锁，允许递归使用，其内部处理逻辑相对复杂，因此性能在所有的锁中相对较差，其简单使用方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(lockedObj) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code block in here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于@synchronized的消息请参考以下链接<br><a href="https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/" target="_blank" rel="noopener">https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/</a></p><p>相关链接:</p><p>OSSpinLock<br><a href="https://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/" target="_blank" rel="noopener">https://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/</a><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/</a></p><p>Synchronized<br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3</a><br><a href="https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/" target="_blank" rel="noopener">https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/</a><br><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近一段时间，博主都在做代码性能上的一些优化工作，其中就包括了对Mac OS/iOS锁这一部分的优化，趁此机会，也比较系统的测试了各种用户态的锁分别在单个线程和多个线程中的表现。之所以叫用户态的锁，是因为Mach内核部分其实还有一部分内核态的锁，它并不为用户态所开放，我们一般也使用不到。&lt;/p&gt;
&lt;p&gt;对同一个锁对象的加解锁必须保持在同一线程执行，如果尝试在不同线程去加解锁将会引发一个运行时的错误。&lt;/p&gt;
&lt;h4 id=&quot;用户态可用的锁&quot;&gt;&lt;a href=&quot;#用户态可用的锁&quot; class=&quot;headerlink&quot; title=&quot;用户态可用的锁&quot;&gt;&lt;/a&gt;用户态可用的锁&lt;/h4&gt;&lt;p&gt;用户态的锁大概有以下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSLock&lt;/li&gt;
&lt;li&gt;NSRecusiveLock&lt;/li&gt;
&lt;li&gt;pthread_mutex_t &lt;/li&gt;
&lt;li&gt;pthread_mutex_t (recusive)&lt;/li&gt;
&lt;li&gt;NSCondition&lt;/li&gt;
&lt;li&gt;NSConditionLock&lt;/li&gt;
&lt;li&gt;dispatch_semaphore_t&lt;/li&gt;
&lt;li&gt;os_unfair_lock&lt;/li&gt;
&lt;li&gt;OS_SPLINK_LOCK&lt;/li&gt;
&lt;li&gt;@synchronized&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="OS Lock" scheme="http://kobeluo.com/tags/OS-Lock/"/>
    
      <category term="锁" scheme="http://kobeluo.com/tags/%E9%94%81/"/>
    
      <category term="locks" scheme="http://kobeluo.com/tags/locks/"/>
    
      <category term="osunfairlock" scheme="http://kobeluo.com/tags/osunfairlock/"/>
    
      <category term="mutex" scheme="http://kobeluo.com/tags/mutex/"/>
    
      <category term="semaphore" scheme="http://kobeluo.com/tags/semaphore/"/>
    
      <category term="nslock" scheme="http://kobeluo.com/tags/nslock/"/>
    
      <category term="NSConditionLock" scheme="http://kobeluo.com/tags/NSConditionLock/"/>
    
  </entry>
  
  <entry>
    <title>Unicode Forms</title>
    <link href="http://kobeluo.com/2018/11/05/StringEncode/"/>
    <id>http://kobeluo.com/2018/11/05/StringEncode/</id>
    <published>2018-11-05T03:16:15.000Z</published>
    <updated>2018-11-16T05:42:57.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a></h3><p>Unicode是计算机领域的一项业界标准，主要为了解决世界上大部分的文字系统的统一编码问题而存在，因此它记录了差不多世界上全部主流的语言的编码集合。Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0[2]，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p><a id="more"></a><h4 id="Unicode的设计原则"><a href="#Unicode的设计原则" class="headerlink" title="Unicode的设计原则"></a>Unicode的设计原则</h4><p>一下内容列举了Unciode设计的十大原则：</p><ul><li>Universality：提供单一、综合的字符集，编码一切现代与大部分历史文献的字符。</li><li>Efficiency：易于处理与分析。</li><li>Characters, not glyphs：字符，而不是字形。</li><li>Semantics：字符要有良好定义的语义</li><li>Plain text：仅限于文本字符</li><li>Logical order：默认内存表示是其逻辑序</li><li>Unification：把不同语言的同一书写系统（scripts）中相同字符统一起来。</li><li>Dynamic composition：附加符号可以动态组合。</li><li>Stability：已分配的字符与语义不再改变。</li><li>Convertibility：Unicode与其他著名字符集可以精确转换。</li></ul><h4 id="Unicode的编码与实现"><a href="#Unicode的编码与实现" class="headerlink" title="Unicode的编码与实现"></a>Unicode的编码与实现</h4><p>大体上来说，Unicode 编码系统可分为<code>编码方式</code>和<code>实现方式</code>两个层次.</p><h5 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h5><p>统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。</p><p>上述16位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。</p><p>基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。</p><p>关于统一码和ISO 10646及UCS的详细关系，见<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">通用字符集</a>。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为<code>UTF</code>）</p><p>Unicode实现方式的主流编码格式有：</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>:<br>  是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为邮箱、网页及其他存储或发送文字的应用中，优先采用的编码。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>:<br>  Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区块是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区块的码位来对辅助平面的字符的码位进行编码。</p></li><li><p>其它的一些编码方式(UTF-7、UTF-32、Punycode、CESU-8、SCSU、GB18030…etc)</p></li></ul><h3 id="Unicode-Form"><a href="#Unicode-Form" class="headerlink" title="Unicode Form"></a><a href="https://unicode.org/reports/tr15/" target="_blank" rel="noopener">Unicode Form</a></h3><p>Unicode主要有四种标准化格式，分别是</p><p>标准模式：</p><ul><li>Form C (Normalization Form C)</li><li>Form D (Normalization Form D)</li></ul><p>兼容模式：</p><ul><li>Form KC (Normalization Form KC)</li><li>Form KD (Normalization Form KD)</li></ul><p>关于标准化格式的内容,请自行查阅相关资料。</p><p>这里着重强调的是，Window使用的是UTF-16作为标注的编码方式，而并未使用Unicode的标准化格式，这就意味着你可以使用两个肉眼看上去一模一样的名字（实际上他们的代码点不一样），而Mac OS系统使用的是UTF-8作为标注编码方式，使用Form C作为标准文本格式，这意味着当你使用两个看上去一样的名字时，OS系统会自动将名字区分开。</p><p>由于使用上的操作系统的差异，就导致了有时候从服务端返回的名称看上去跟本地一致，其实不一致的问题。</p><p>对于采用了其它标准格式或未使用标准格式的服务端，对于服务端返回的名称，则需要把源字符串转化为标准的FormD格式（Mac OS系统底层默认格式），这样才能正常的比较字符串<br>而当你上传本地文件到服务端时，指定名字也需要反向的使用服务端相应的名字格式。</p><p>Mac OS/iOS系统下Foundation库中String的属性代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Form D</span><br><span class="line">@property (readonly, copy) NSString *decomposedStringWithCanonicalMapping; </span><br><span class="line"></span><br><span class="line">//Form C</span><br><span class="line">@property (readonly, copy) NSString *precomposedStringWithCanonicalMapping;</span><br><span class="line"></span><br><span class="line">//Form KD</span><br><span class="line">@property (readonly, copy) NSString *decomposedStringWithCompatibilityMapping;</span><br><span class="line"></span><br><span class="line">//Form KC</span><br><span class="line">@property (readonly, copy) NSString *precomposedStringWithCompatibilityMapping;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Unicode&quot;&gt;&lt;a href=&quot;#Unicode&quot; class=&quot;headerlink&quot; title=&quot;Unicode&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unicode&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Unicode是计算机领域的一项业界标准，主要为了解决世界上大部分的文字系统的统一编码问题而存在，因此它记录了差不多世界上全部主流的语言的编码集合。Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0[2]，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kobeluo.com/categories/Tools/"/>
    
    
      <category term="编码格式" scheme="http://kobeluo.com/tags/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
    
      <category term="FormC" scheme="http://kobeluo.com/tags/FormC/"/>
    
      <category term="FormD" scheme="http://kobeluo.com/tags/FormD/"/>
    
      <category term="unicode Encode" scheme="http://kobeluo.com/tags/unicode-Encode/"/>
    
  </entry>
  
  <entry>
    <title>Mach 同步机制-学习笔记</title>
    <link href="http://kobeluo.com/2018/10/31/mach-synchronization/"/>
    <id>http://kobeluo.com/2018/10/31/mach-synchronization/</id>
    <published>2018-10-31T08:59:31.000Z</published>
    <updated>2018-11-16T05:43:36.615Z</updated>
    
    <content type="html"><![CDATA[<p>消息传递机制是 Mach IPC架构中的一个组件，另一个组件是同步机制(synchronization)，同步机制用于判定多个并发的操纵时，如何访问共享资源的问题。同步机制的本质是:<br><code>排他访问的能力，即：在使用一个资源时，排除其它对象对该资源的访问的能力。</code><br>最基本的同步原语是互斥(mutual exclusion)对象，也叫互斥体(mutex)。互斥体只不过是内核内存中的普通变量，硬件必须对这些变量进行原子(atomic)操作。意思是对互斥体的操作决不允许被打断，即使硬件中断也不能打断，在SMP系统上，互斥体还有一个要求就是要求硬件实现某种屏障(fence或barrier)。</p><a id="more"></a><p>下面是一些同步原语：</p><table><thead><tr><th>对象</th><th>实现的文件</th><th>所有者</th><th>可见性</th><th>等待</th></tr></thead><tbody><tr><td>互斥体(lck_mtx_t)</td><td>i386/i386_locks.c</td><td>1个</td><td>内核态</td><td>阻塞</td></tr><tr><td>信号量(semaphore_t)</td><td>kern/sync_sema.c</td><td>多个</td><td>用户态</td><td>阻塞</td></tr><tr><td>自旋锁(hw_lock_t等)</td><td>i386/i386_locks.s</td><td>1个</td><td>内核态</td><td>忙等</td></tr><tr><td>锁集(lock_set_t)</td><td>kern/sync_lock.c</td><td>1个</td><td>用户态</td><td>阻塞(同互斥体)</td></tr></tbody></table><p>Mach锁由两个层次组成：</p><ul><li>硬件相关层: 通过硬件的特性，通过特定的汇编指令实现的原子性和互斥性。</li><li>硬件无关层: 通过API包装硬件特定的调用，是通过简单的宏来实现的；这些API使得基于Mach的上层完全不用关心细节的实现。</li></ul><h3 id="锁组对象"><a href="#锁组对象" class="headerlink" title="锁组对象"></a><a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/locks.h.auto.html" target="_blank" rel="noopener">锁组对象</a></h3><p>大部分Mach的同步对象都不是独立存在的，而是属于<code>lck_grp_t</code>对象,<code>typedef struct __lck_grp__ lck_grp_t;</code>;<br>锁组(lock group)对象定义结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LCK_GRP_MAX_NAME64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> _<span class="title">lck_grp_</span> &#123;</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>lck_grp_link;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_refcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_spincnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_mtxcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_rwcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_attr;</span><br><span class="line"><span class="keyword">char</span>lck_grp_name[LCK_GRP_MAX_NAME];</span><br><span class="line"><span class="keyword">lck_grp_stat_t</span>lck_grp_stat;</span><br><span class="line">&#125; <span class="keyword">lck_grp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCK_GRP_NULL(lck_grp_t *)0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lck_grp__</span> <span class="title">lck_grp_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><code>lck_grp_t</code>就是一个链表中的一个元素，有一个指定的名字，以及最多三种类型的锁:自旋锁、互斥体和读写锁。其中<code>lck_grp_stat_t</code>提供锁组的统计信息功能，用于调试和同步相关的问题。<code>lck_grp_attr</code>可以用来设置一个LCK_ATTR_DEBUG属性。</p><p>锁组的创建和销毁API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新的锁组； 锁组通过grp_name标识，拥有attr指定的属性，一般情况下，都是通过lck_grp_attr_alloc_init()设置默认属性。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_grp_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">const</span> <span class="keyword">char</span> *grp_name, <span class="keyword">lck_grp_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//接触分配锁组</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_grp_free</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在Mach和BSD中，几乎每个子系统在初始化时都会创建一个自己使用的锁组。</p><h3 id="互斥体对象"><a href="#互斥体对象" class="headerlink" title="互斥体对象"></a>互斥体对象</h3><p>互斥体(lck_mtx_t)是最常用的锁对象,它必须属于一个锁组，相关的API如下表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过指定的grp和attr,创建并初始化新的互斥体对象</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> lck_mtx_t *<span class="title">lck_mtx_alloc_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化已经分配的互斥体lck.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_init</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体上锁，如果重复上锁会产生阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_lock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体尝试上锁，如果不成功则返回失败</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> boolean_t <span class="title">ck_mtx_try_lock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体解锁</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_unlock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将互斥体标记为销毁，互斥体将不可以继续使用，但依然占据内存空间，可以重新对其初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_destroy</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将互斥体标记为销毁，并释放其内存空间。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_free</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程置于睡眠状态，直到lck变为可用状态</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_mtx_sleep</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck, <span class="keyword">ck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程置于睡眠状态，直到lck变为可用状态或到达deadline的时限</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_mtx_sleep_deadline</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">lck_sleep_action_t</span> lck_sleep_action, <span class="keyword">event_t</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wait_interrupt_t</span> interruptible, <span class="keyword">uint64_t</span> deadline)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥锁有一个很大的缺点：<code>就是一次只能由一个线程持有锁对象。</code><br>在很多情况下，多线程可能对资源请求只读的访问。在这些情况下，使用互斥体会阻止并发的访问，即使这些线程之间并不会相互影响，这就带来了性能的瓶颈。</p><h3 id="读写锁对象"><a href="#读写锁对象" class="headerlink" title="读写锁对象"></a>读写锁对象</h3><p>读写锁(read-write lock)的设计初衷就是为了解决互斥锁的缺点。它是更智能的互斥锁，能够区分读写访问，多个只读的线程可以同时持有读写锁，而一次只允许一个写的线程可以获得锁，当一个写的线程持有锁是，其余线程的锁都将被阻塞。<br>跟mutex lock相似，下面是读写锁相关的API:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> lck_rw_t *<span class="title">lck_rw_alloc_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_init</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock_shared</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock_shared</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock_exclusive</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock_exclusive</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="comment">//如果当前线程是读，当有写的线程持有锁时，当前线程调用会被阻塞</span></span><br><span class="line"><span class="comment">//如果当前线程是写，当有其他线程获得锁时，调用会被阻塞</span></span><br><span class="line"><span class="comment">//这个API等同于lck_rw_lock_shared + lck_rw_lock_exclusion </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_rw_type_t</span> lck_rw_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////这个API等同于lck_rw_unlock_shared + lck_rw_unlock_exclusion</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_rw_type_t</span> lck_rw_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_destroy</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_free</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//action 可以是LCK_SLEEP_SHARED 和 LCK_SLEEP_EXCLUSION.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_rw_sleep</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_rw_sleep_deadline</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible, <span class="keyword">uint64_t</span> deadline)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><p>Mach提供了信号量(Semaphore)，信号量是一种泛化的互斥体，互斥体只能是0和1，而信号量是可以将取值达到某个整数时就允许持有信号量的线程同时执行的这样一种互斥体，信号量在用户态使用，而互斥体只能在内核态使用。</p><div class="note info"><p>Mach中的信号量和POSIX中的信号量不同，API也不同，因此两者不相容，在XNU上，POSIX信号量的底层实现是通过Mach的信号量实现的。<br>POSIX中的<code>sem_open()</code>函数其实调用了Mach的<code>semaphore_create()</code>函数</p></div><p>信号量本身是一个不可锁的对象，拥有很小的结构体，包含了所有者和端口的引用，还包括了一个wait_queue_t用来保证正在等待这个信号量的线程的链表，<br>wait_queue_t会通过硬件锁的方式锁定。<br>下面是信号量对象的结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MACH_KERNEL_PRIVATE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>  task_link;  <span class="comment">/* chain of semaphores owned by a task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> <span class="title">wait_queue</span>;</span> <span class="comment">/* queue of blocked threads &amp; lock     */</span></span><br><span class="line"><span class="keyword">task_t</span>  owner;      <span class="comment">/* task that owns semaphore            */</span></span><br><span class="line"><span class="keyword">ipc_port_t</span>  port;      <span class="comment">/* semaphore port      */</span></span><br><span class="line"><span class="keyword">int</span>  ref_count;  <span class="comment">/* reference count     */</span></span><br><span class="line"><span class="keyword">int</span>  count;      <span class="comment">/* current count value             */</span></span><br><span class="line"><span class="keyword">boolean_t</span>  active;     <span class="comment">/* active status     */</span></span><br><span class="line">&#125; Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> semaphore_lock(semaphore)   wait_queue_lock(&amp;(semaphore)-&gt;wait_queue)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> semaphore_unlock(semaphore) wait_queue_unlock(&amp;(semaphore)-&gt;wait_queue)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">semaphore_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span><span class="keyword">void</span><span class="title">semaphore_reference</span><span class="params">(<span class="keyword">semaphore_t</span> semaphore)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span><span class="keyword">void</span><span class="title">semaphore_dereference</span><span class="params">(<span class="keyword">semaphore_t</span> semaphore)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MACH_KERNEL_PRIVATE */</span></span></span><br></pre></td></tr></table></figure></p><p>下面列出了Mach中 信号量的相关API:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_create</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Creates a semaphore.</span></span><br><span class="line"><span class="comment"> *The port representing the semaphore is returned as a parameter.</span></span><br><span class="line"><span class="comment"> *为task创建一个信号量new_semaphore,policy表示阻塞的线程如何被唤醒，使用的是和锁策略相同的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_create(<span class="keyword">task_t</span> task, <span class="keyword">semaphore_t</span> *new_semaphore, <span class="keyword">int</span> policy, <span class="keyword">int</span> value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_destroy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Destroys a semaphore.  This call will only succeed if the</span></span><br><span class="line"><span class="comment"> *specified task is the SAME task name specified at the semaphore's</span></span><br><span class="line"><span class="comment"> *creation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *All threads currently blocked on the semaphore are awoken.  These</span></span><br><span class="line"><span class="comment"> *threads will return with the KERN_TERMINATED error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_destroy( <span class="keyword">task_t</span> task, <span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_signal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Traditional (in-kernel client and MIG interface) semaphore</span></span><br><span class="line"><span class="comment"> *signal routine.  Most users will access the trap version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *This interface in not defined to return info about whether</span></span><br><span class="line"><span class="comment"> *this call found a thread waiting or not.  The internal</span></span><br><span class="line"><span class="comment"> *routines (and future external routines) do.  We have to</span></span><br><span class="line"><span class="comment"> *convert those into plain KERN_SUCCESS returns.</span></span><br><span class="line"><span class="comment"> *增加信号量计数，如果计数器大于等于0，则唤醒一个阻塞的线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_signal(<span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_signal_all</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Awakens ALL threads currently blocked on the semaphore.</span></span><br><span class="line"><span class="comment"> *The semaphore count returns to zero.</span></span><br><span class="line"><span class="comment"> *将计数器值置为0，并唤醒所有阻塞的线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_signal_all(<span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Traditional (non-continuation) interface presented to</span></span><br><span class="line"><span class="comment"> * in-kernel clients to wait on a semaphore.</span></span><br><span class="line"><span class="comment"> * 减去一个信号量计数，如果小于0，则阻塞知道计数器再次变为非负数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_wait(<span class="keyword">semaphore_t</span> semaphore)</span><br></pre></td></tr></table></figure></p><p>信号量的属性可以让信号量转换为端口，也可以由端口转换回来，<a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/ipc_sync.c.auto.html" target="_blank" rel="noopener">ipc_sync.c</a>中定义了这些操作的函数，但该功能并不为用户态暴露，内核态也未使用。</p><h3 id="自旋锁对象"><a href="#自旋锁对象" class="headerlink" title="自旋锁对象"></a>自旋锁对象</h3><p>互斥体和信号量都是阻塞等待的对象。如果所被其他线程持有，那么请求将被加入到等待队列，当前线程处于阻塞状态，阻塞线程意味着放弃线程的时间片，把处理器让给调度器认为下一个要执行的线程。当锁可用时，调度器得到通知再根据判断将线程从等待队列中取出并重新调度。然而这种方式可能会严重的影响性能，在大多数情况下，锁对象可能只需要短短几个周期的时间，因为造成两次或更多次的上下文切换带来的开销非常大，在这种case下，如果线程不阻塞而是继续重复尝试访问锁对象所带来的开销可能会小得多，这种方式被称为“忙等(busy-wait)”。</p><p>然而上面说的case只是一种假设，按照这种方式自旋等待的线程很可能会陷入无限的循环等待中，这会造成一个非常恐怖的死锁场景，甚至整个系统会因此陷入停滞状态。</p><p>基础的自旋锁(spinlock)类型是硬件相关的<code>hw_lock_t</code>。其它的自旋锁类型都是实现在它之上： <code>lck_spin_t</code>、<code>simple_lock_t</code>、<code>usimple_lock_t</code>等。</p><p>这些自旋锁的的API和其它类型所得API都差不多，详参:</p><ul><li><a href="https://www.kernel.org/doc/Documentation/locking/spinlocks.txt" target="_blank" rel="noopener">自旋锁API</a></li><li><a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/simple_lock.h.auto.html" target="_blank" rel="noopener">simple lock</a></li></ul><h3 id="锁集对象"><a href="#锁集对象" class="headerlink" title="锁集对象"></a><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" target="_blank" rel="noopener">锁集对象</a></h3><p>任务在用户态可以使用锁集，概念上，锁集对象就是锁的数组，实际上是互斥体的数组，通过给定的ID可以访问锁，锁可在线程之间传递，锁集是lck_mtx_t的封装<br>下面是相关的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为task创建一个lock_set,锁的数量是locks个，policy用于指定唤醒锁的策略，主要有</span></span><br><span class="line"><span class="comment">// SYNC_POLICY_FIFO 先进先出原则</span></span><br><span class="line"><span class="comment">// SYNC_POLICY_FIXED_PROIRITY 根据指定的优先级原则</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_set_create(<span class="keyword">task_t</span> task, <span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> locks, <span class="keyword">int</span> policy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁锁集及所包含的锁</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_set_destroy(<span class="keyword">task_t</span> task, <span class="keyword">lock_set_t</span> lock_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock_id从lock_set中获取指定的锁，该函数可能会永久阻塞如果指定的锁已经被另外的线程控制了。</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_acquire(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock_id释放锁集中指定的锁，如果调用的线程不拥有该锁，则会调用失败</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_release(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试获取锁，如果锁已经被持有了则立即返回KERN_LOCK_OWNED</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_try(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数清除锁集的不稳定状态，将锁集置于稳定状态。</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_make_stable(<span class="keyword">lock_set_t</span> lock_set,<span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程拥有的锁交出，并传递给匿名的接受线程，如果接受线程没有等待接收该锁，则会造成线程阻塞，知道接收线程接收为止。</span></span><br><span class="line"><span class="comment">//The lock_handoff function passes lock ownership from the calling thread to an anonymous accepting thread. </span></span><br><span class="line"><span class="comment">//The lock must be owned by the calling thread. If the accepting thread is not waiting to receive the lock, </span></span><br><span class="line"><span class="comment">//the calling thread will block until the hand-off is accepted.</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_handoff(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个匿名线程通过lock_handoff传递的锁，如果发送锁的线程没有等待切换锁，</span></span><br><span class="line"><span class="comment">//则调用的线程将造成阻塞，知道锁切换完成，任何指定的时间只能有一个线程可能正在接受锁切换</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_handoff_accept(<span class="keyword">lock_set_t</span> lock_set,<span class="keyword">int</span> lock_id);</span><br></pre></td></tr></table></figure></p><p>锁集的有趣之处在于允许锁在线程之间传递。Mach在调度中也使用了这个概念，允许一个线程放弃处理器并指定由另一个线程来接替运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息传递机制是 Mach IPC架构中的一个组件，另一个组件是同步机制(synchronization)，同步机制用于判定多个并发的操纵时，如何访问共享资源的问题。同步机制的本质是:&lt;br&gt;&lt;code&gt;排他访问的能力，即：在使用一个资源时，排除其它对象对该资源的访问的能力。&lt;/code&gt;&lt;br&gt;最基本的同步原语是互斥(mutual exclusion)对象，也叫互斥体(mutex)。互斥体只不过是内核内存中的普通变量，硬件必须对这些变量进行原子(atomic)操作。意思是对互斥体的操作决不允许被打断，即使硬件中断也不能打断，在SMP系统上，互斥体还有一个要求就是要求硬件实现某种屏障(fence或barrier)。&lt;/p&gt;
    
    </summary>
    
      <category term="OS Kernal" scheme="http://kobeluo.com/categories/OS-Kernal/"/>
    
    
      <category term="Mach同步机制，同步，mutex，自旋锁，信号量" scheme="http://kobeluo.com/tags/Mach%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%90%8C%E6%AD%A5%EF%BC%8Cmutex%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>IPC-进程间通信</title>
    <link href="http://kobeluo.com/2018/10/31/IPC/"/>
    <id>http://kobeluo.com/2018/10/31/IPC/</id>
    <published>2018-10-31T08:06:25.000Z</published>
    <updated>2018-11-16T05:43:47.308Z</updated>
    
    <content type="html"><![CDATA[<p>进程间通信的基础原语: 消息、端口、已经确保并发安全的信号量和锁。这篇文章主要对于这些原语的底层实现和端口的内部实现做一些探讨。</p><p>Mach任务是一个对应于进程的高层次抽象，Mach任务包含了一个指向自己的IPC namespace（命名空间），在命名空间中保存了自己的端口，此外mach任务也可以获得系统范围内的端口，如：主机端口、特权端口和其它端口。</p><a id="more"></a><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><hr><p>导出给用户空间的端口对象(mach_port_t)实际上是对”真正”端口对象的一个句柄，后者是<a href="https://opensource.apple.com/source/xnu/xnu-344/osfmk/ipc/ipc_port.h" target="_blank" rel="noopener">ipc_port_t</a>，其数据结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  A receive right (port) can be in four states:</span></span><br><span class="line"><span class="comment"> *1) dead (not active, ip_timestamp has death time)</span></span><br><span class="line"><span class="comment"> *2) in a space (ip_receiver_name != 0, ip_receiver points</span></span><br><span class="line"><span class="comment"> *to the space but doesn't hold a ref for it)</span></span><br><span class="line"><span class="comment"> *3) in transit (ip_receiver_name == 0, ip_destination points</span></span><br><span class="line"><span class="comment"> *to the destination port and holds a ref for it)</span></span><br><span class="line"><span class="comment"> *4) in limbo (ip_receiver_name == 0, ip_destination == IP_NULL)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  If the port is active, and ip_receiver points to some space,</span></span><br><span class="line"><span class="comment"> *  then ip_receiver_name != 0, and that space holds receive rights.</span></span><br><span class="line"><span class="comment"> *  If the port is not active, then ip_timestamp contains a timestamp</span></span><br><span class="line"><span class="comment"> *  taken when the port was destroyed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">ipc_port_timestamp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">ipc_port_flags_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initial sub-structure in common with ipc_pset and rpc_port</span></span><br><span class="line"><span class="comment"> * First element is an ipc_object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span> <span class="comment">//ipc对象，初始化子结构跟ipc_pset和rpc_port一致。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span> <span class="comment">//指向接收者的IPC指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span> <span class="comment">//指向全局端口的指针</span></span><br><span class="line"><span class="keyword">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">&#125; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ipc_kobject_t</span> ip_kobject;</span><br><span class="line"><span class="keyword">mach_port_mscount_t</span> ip_mscount;</span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_srights;</span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_sorights;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_dnrequests</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ip_pset_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span> <span class="comment">//消息队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">ip_premsg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>NORMA_VM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *These fields are needed for the use of XMM.</span></span><br><span class="line"><span class="comment"> *Few ports need this information; it should</span></span><br><span class="line"><span class="comment"> *be kept in XMM instead (TBD).  XXX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span>ip_norma_xmm_object_refs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span>*<span class="title">ip_norma_xmm_object</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>MACH_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>IP_NSPARES10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>IP_CALLSTACK_MAX10</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>ip_port_links;<span class="comment">/* all allocated ports */</span></span><br><span class="line"><span class="keyword">natural_t</span>ip_thread;<span class="comment">/* who made me?  thread context */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>ip_timetrack;<span class="comment">/* give an idea of "when" created */</span></span><br><span class="line"><span class="keyword">natural_t</span>ip_callstack[IP_CALLSTACK_MAX]; <span class="comment">/* stack trace */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>ip_spares[IP_NSPARES]; <span class="comment">/* for debugging */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* MACH_ASSERT */</span></span></span><br><span class="line"><span class="keyword">int</span>alias;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="消息传递的实现"><a href="#消息传递的实现" class="headerlink" title="消息传递的实现"></a>消息传递的实现</h3><hr><p>用户态的Mach消息传递使用的函数是<code>mach_msg()</code>函数，这个函数通过内核的Mach trap调用内核函数<code>mach_msg_trap()</code>。然后<code>mach_msg_trap</code>调用<code>mach_msg_overwrite_trap()</code>,<code>mach_msg_overwrite_trap</code>通过测试<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>标志位来判断是发送操作还是接收操作。</p><p>下面分析IPC最重要的两个函数<code>mach_msg_send()</code>和<code>mach_msg_receive()</code>的实现</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Mach 消息发送的核心逻辑在内核中有两处实现: <code>mach_msg_overwrite_trap()</code>和<code>mach_msg_send()</code>。后者只用于内核态的消息传递，对用户态不可见。两处实现的逻辑大同小异并遵循以下流程：</p><ul><li>调用<code>current_space()</code>来获取当前的IPC空间。</li><li>调用<code>current_map()</code>来获取当前VM空间(<a href="https://www.freebsd.org/cgi/man.cgi?query=vm_map&amp;sektion=9&amp;apropos=0&amp;manpath=FreeBSD+11-current" target="_blank" rel="noopener">vm_map</a>)</li><li>对消息的大小进行正确性检查。</li><li>计算要分配的消息大小，从send_size参数获得大小再加上硬编码的MAX_TRAILER_SIZE。</li><li>通过ipc_kmsg_alloc分配消息。</li><li>复制消息(复制消息send_size字节的部分)，然后在消息头设置msgh_size。</li><li>复制消息关联的端口权限，然后通过ipc_kmsg_copyin将所有的OOL数据的内存复制到当前的vm_map。 ipc_kmsg_copyin函数调用了ipc_kmsg_copyin_header和ipc_kmsg_copyin_body。</li><li>调用ipc_kmsg_send()发送消息：<ul><li>获得msgh_remote_port引用，并锁定端口。</li><li>如果该端口是一个内核端口（即端口的ip_receiver是内核的IPC空间），那么通过ipc_kobject_server()函数处理消息。该函数会在内核中找到相应的函数来执行消息，还会生成消息的应答。</li><li>不论哪种端口，调用ipc_mqueue_send(),这个函数将消息直接复制到端口的ip_messages队列中并唤醒任何正在等待的线程处理消息。</li></ul></li></ul><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>Mach接收消息的方式个发送类似，也体现在内核的两个地方，<code>mach_msg_overwrite_trap()</code>用用户态接收请求，而内核通过<code>mach_msg_receive()</code>函数接收消息。</p><ul><li>调用current_space()来获取当前的IPC空间</li><li>调用current_map()</li><li>不校对消息大小，因为发送的时候已经校对过了</li><li>通过调用ipc_mqueue_copyin()获取IPC队列</li><li>持有当前线程的一个引用。使用当前线程的引用可使它适合使用Mach的续体模型，续体(continuation)模型可以表面维护完整线程栈的必要性。<code>续体是撒玩意儿博主也弄不明白</code></li><li>调用ipc_mqueue_receive()从队列中取出消息</li><li>调用mach_msg_receive_results()函数，该函数也可以从续体中调用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程间通信的基础原语: 消息、端口、已经确保并发安全的信号量和锁。这篇文章主要对于这些原语的底层实现和端口的内部实现做一些探讨。&lt;/p&gt;
&lt;p&gt;Mach任务是一个对应于进程的高层次抽象，Mach任务包含了一个指向自己的IPC namespace（命名空间），在命名空间中保存了自己的端口，此外mach任务也可以获得系统范围内的端口，如：主机端口、特权端口和其它端口。&lt;/p&gt;
    
    </summary>
    
      <category term="OS Kernal" scheme="http://kobeluo.com/categories/OS-Kernal/"/>
    
    
      <category term="进程" scheme="http://kobeluo.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Process Communication" scheme="http://kobeluo.com/tags/Process-Communication/"/>
    
      <category term="进程间通信" scheme="http://kobeluo.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
      <category term="IPC" scheme="http://kobeluo.com/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Mach 原语-学习笔记</title>
    <link href="http://kobeluo.com/2018/10/31/Mach/"/>
    <id>http://kobeluo.com/2018/10/31/Mach/</id>
    <published>2018-10-31T02:21:59.000Z</published>
    <updated>2018-11-16T05:43:28.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-概述"><a href="#Mach-概述" class="headerlink" title="Mach 概述"></a><a href="https://zh.wikipedia.org/wiki/Mach" target="_blank" rel="noopener">Mach</a> 概述</h3><hr><h4 id="Mach设计原则"><a href="#Mach设计原则" class="headerlink" title="Mach设计原则"></a>Mach设计原则</h4><p>Mac OS X采用Mach作为锡系统的内核，其源头可以追溯到乔老爷创立的NeXT。Mach采用了极简主义概念:<br><code>具有一个简单最小的核心，支持面向对象的模型，使得独立的具有良好定义的组件可以通过消息的方式互相通信。</code><br>Mach只提供了一个极简的模型，操作系统本身可以在这个模型基础上实现，OS X的<a href="https://en.wikipedia.org/wiki/XNU" target="_blank" rel="noopener">XNU</a>是UNIX（<a href="https://zh.wikipedia.org/zh-hans/FreeBSD" target="_blank" rel="noopener">FreeBSD</a> 4.4）在Mach上的一个具体实现，Windows也采用了一些Mach的原则，不过其实现方式与Mac OS则完全不同。</p><p>Mach内核成为了一个底层的基础，它只关心驱动操作系统的最少需求，其余的功能则需要由上层来实现，尽管Mach对用户态也是可见的，使用Mach都是实现了深层次的核心功能，在这个基础上可以实现更大的内核，而Mach则是内核中的内核，<code>XNU的官方API是BSD的POSIX API,Apple保持了Mach绝对的极简，基于Mach外层则有丰富的Cocoa API来支撑，因此Mach是Mac OS X操作系统中最关键最基础的部分</code></p><a id="more"></a><p>在Mach的所有都是通过自己的对象实现的。进程、线程、虚拟内存其实都是对象，所有的对象都有自己的属性，所谓的对象其实就是C语言的结构体加上函数指针实现的。</p><p>Mach的独特之处在于选择了通过消息传递的方式实现对象与对象之间的通信。而其他架构中一个对象要访问另一个对象则需要一个接口来实现。而Mach对象不能直接调用另一个对象，而是通过消息传递的方式，源发送一条消息，这条消息被加入到目标对象的队列中等待处理，类似，消息处理中可能会产生一个应答，该应答则通过另一条消息被发送回源对象，消息发送的方式是以FIFIO的方式保证了传输的可靠性，而内容则由发送者和接收者协商。</p><h4 id="Mach-设计目标"><a href="#Mach-设计目标" class="headerlink" title="Mach 设计目标"></a>Mach 设计目标</h4><p>其最重要的目标是将所有的功能都移出内核，将功能放在用户态中去实现，保持内核极简，其主要功能如下:</p><ul><li>控制点和执行单元(线程)管理</li><li>线程和线程组的资源分配</li><li>虚拟内存的分配和管理</li><li>底层物理资源的分配(即CPU、内存和其他任何物理设备)</li></ul><p>Mach只提供了实行策略的方法，而不提供策略本身，Mach也不会识别任何安全特性、优先级和选项(Options)，所有这些都需要上层去定义和实现。</p><p>Mach设计中有一个强大的优点:<strong>多处理(multi process)</strong>。<br>内核中大部分的功能都是由独立的组件实现，组件之间的传递具有良好定义的消息，之间没有公共作用域，因此，没有必要所有的组件都在同一个处理器上执行，甚至不要求在同一台计算机上执行。<br><strong>理论上：Mach可以轻松扩展成计算机集群使用的操作系统。</strong></p><h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><hr><p>消息是Mach中最基本的概念，通过短点(endpoint)或端口(port)之间传递，消息是Mach IPC的核心模块。</p><h4 id="简单消息"><a href="#简单消息" class="headerlink" title="简单消息"></a>简单消息</h4><p>一条消息就像一个网络数据包，通过固定的包头进行封装，定义为BLOB(binary large object,二进制大对象)，在Mach中，消息定义在<code>&lt;mach/message.h&gt;</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span>body;</span><br><span class="line">&#125;<span class="keyword">mach_msg_base_t</span>;</span><br></pre></td></tr></table></figure></p><p>而消息头是强制要求的，其中定义了相关的元数据，内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>msgh_bits; <span class="comment">//消息头的标识位</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>msgh_size;<span class="comment">//大小，以字节为单位</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>msgh_remote_port;<span class="comment">//目标(发出的消息)或源(接收的消息)</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>msgh_local_port;<span class="comment">//源(发出的消息)或目标(接收的消息)</span></span><br><span class="line">  <span class="keyword">mach_port_name_t</span>msgh_voucher_port;<span class="comment">//</span></span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>msgh_id;<span class="comment">//唯一ID</span></span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure></p><p>一条消息就是一个BLOB,通过端口发送到另一个端口并带有可选的标识；<br>消息还可以选择带有一个消息尾(trailer),其定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">mach_msg_trailer_type_t</span>;</span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">mach_msg_trailer_size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_trailer_type_t</span>msgh_trailer_type;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_size_t</span>msgh_trailer_size;</span><br><span class="line">&#125; <span class="keyword">mach_msg_trailer_t</span>;</span><br></pre></td></tr></table></figure></p><p>每一种trailer类型都定义了一种特殊的trailer格式，这些格式都是为未来可以实现扩展的，下面是一些已经定义好的类型：</p><table><thead><tr><th style="text-align:left">trailer</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">mach_msg_trailer_t</td><td style="text-align:left">空trailer</td></tr><tr><td style="text-align:left">mach_msg_security_trailer_t</td><td style="text-align:left">发送者安全令牌</td></tr><tr><td style="text-align:left">mach_msg_seqno_trailer_t</td><td style="text-align:left">顺序编号</td></tr><tr><td style="text-align:left">mach_msg_audit_trailer_t，mach_msg_context_trailer_t</td><td style="text-align:left">审计令牌(用于BSM)</td></tr><tr><td style="text-align:left">mach_msg_mac_trailer_t</td><td style="text-align:left">MAC策略标签</td></tr></tbody></table><p>应答消息和内核消息使用到了trailer.</p><h4 id="复杂消息"><a href="#复杂消息" class="headerlink" title="复杂消息"></a>复杂消息</h4><p>除了简单的消息外，有一些带有额外的字段和结构的消息被称为”复杂消息”，它们是通过消息头标志中的MACH_MSGH_BITS_COMPLEX位来表示的，而且数据结构也不同：<br><code>消息头后面跟着一个描述符计数字段，再接一个串行化的描述符</code></p><table><thead><tr><th style="text-align:left">trailer</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">MACH_MSG_PORT_DESCRIPTOR</td><td style="text-align:left">传递一个端口权限</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_DESCRIPTOR</td><td style="text-align:left">传递 out-of-line 数据</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_PORTS_DESCRIPTOR</td><td style="text-align:left">传递 out-of-line 端口</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_VOLATILE_DESCRIPTOR</td><td style="text-align:left">传递有可能发生变化(volatile)的out-of-line数据</td></tr></tbody></table><p>以上是一些已规定的复杂消息描述符，其中<code>out-of-line</code>是Mach消息的一个重要特性，允许添加各种数据的分散指针，类似于电子邮件添加附件的功能，其64位的数据结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span>*address;<span class="comment">//指向数据的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       size;<span class="comment">//数据大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean_t</span>     deallocate: <span class="number">8</span>;<span class="comment">//发送之后是否解除分配</span></span><br><span class="line">  <span class="keyword">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;<span class="comment">//复制指令</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     pad1: <span class="number">8</span>;<span class="comment">//预留参数</span></span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;<span class="comment">//MACH_MSG_OOL_DESCRIPTOR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">mach_msg_ool_descriptor_t</span>;</span><br></pre></td></tr></table></figure></p><p>OOL描述了要附加的数据的地址和大小，一级如何处理数据的指令，例如是否可以解除分配，以及复制选项(如物理内存和虚拟内存的复制)。<br>OOL描述符常用语传递大块的数据，能避免昂贵的复制操作。</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Mach消息的发送和接收都是通过同一个API函数mach_msg()来完成的，该函数在用户态和内核态都有实现，其原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:mach_msg</span></span><br><span class="line"><span class="comment"> *Purpose:</span></span><br><span class="line"><span class="comment"> *Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="function"><span class="keyword">extern</span> mach_msg_return_t<span class="title">mach_msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify)</span></span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:mach_msg_overwrite</span></span><br><span class="line"><span class="comment"> *Purpose:</span></span><br><span class="line"><span class="comment"> *Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Distinct send and receive buffers may be specified.  If</span></span><br><span class="line"><span class="comment"> *no separate receive buffer is specified, the msg parameter</span></span><br><span class="line"><span class="comment"> *will be used for both send and receive operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *In addition to a distinct receive buffer, that buffer may</span></span><br><span class="line"><span class="comment"> *already contain scatter control information to direct the</span></span><br><span class="line"><span class="comment"> *receiving of the message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="function"><span class="keyword">extern</span> mach_msg_return_t<span class="title">mach_msg_overwrite</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *rcv_msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_limit)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接受一个消息缓冲区参数，对于发送操作是一个输入指针，对于接收操作是一个输出指针。该函数还有一个姊妹函数<code>mach_msg_overwrite</code>，允许调用者指定另外两个参数:一个是<code>mach_msg_header_t*</code>指向接收缓冲区，一个是<code>mach_msg_size_t</code>用于表示缓冲区大小。<br>无论哪个函数，都可以通过按位操作选项来指定，具体的操作如下表：</p><table><thead><tr><th style="text-align:left">选项标志位</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">MACH_RCV_MSG</td><td style="text-align:left">接收一条消息放在msg缓冲区</td></tr><tr><td style="text-align:left">MACH_RCV_LARGE</td><td style="text-align:left">如果接收缓冲区太小，则将过大的消息放在队列中，并且出错返回MACH_RCV_TOO_LARGE。在这种情况下，只返回消息头(指定消息的大小)，因此调用者可以分配更多的内存</td></tr><tr><td style="text-align:left">MACH_RCV_TIMEOUT</td><td style="text-align:left">单位是毫秒，如果接收超时，则出错返回MACH_RCV_TIMED_OUT。timeout值可以指定为0</td></tr><tr><td style="text-align:left">MACH_RCV_NOTIFY</td><td style="text-align:left">带通知的接收操作</td></tr><tr><td style="text-align:left">MACH_RCV_INTERRUPT</td><td style="text-align:left">允许操作被打断(返回MACH_RCV_INTERRUPT)</td></tr><tr><td style="text-align:left">MACH_RCV_OVERWRITW</td><td style="text-align:left">在mach_msg_overwrite中，指定额外的参数：接收缓冲区参数，输入还是输出</td></tr><tr><td style="text-align:left">MACH_SEND_MSG</td><td style="text-align:left">发送msg缓冲区中的消息</td></tr><tr><td style="text-align:left">MACH_SEND_INTERRUPT</td><td style="text-align:left">允许发送操作被打断</td></tr><tr><td style="text-align:left">MACH_SEND_TIMEOUT</td><td style="text-align:left">发送超时，单位是毫秒。如果发送timeout秒后还未发送完成，则返回MACH_SEND_TIME_OUT</td></tr><tr><td style="text-align:left">MACH_SEND_NOTIFY</td><td style="text-align:left">向通知端口通知消息的传递 </td></tr><tr><td style="text-align:left">MACH_SEND_ALWAYS</td><td style="text-align:left">内部使用</td></tr><tr><td style="text-align:left">MACH_SEND_TRAILER</td><td style="text-align:left">表示一个已知的Mach trailer位于位置大小偏移的位置(也就是紧跟着消息缓冲区之后的位置，有点晦涩，笔者没看明白)</td></tr><tr><td style="text-align:left">MACH_SEND_CANCEL</td><td style="text-align:left">取消一条消息(Lion中已经被移出了)</td></tr></tbody></table><p>Mach消息原本是为真正的微内核框架而设计的，也就是说<code>mach_msg()</code>必须在发送者和接收者之间复制消息所在的内存，这种实现方式忠于微内核的范式，但事实证明：频繁的复制内存所带来的性能消耗是无法忍受的。<br>因此，XNU通过单一内核方式:所有的内核组件都共享同一个地址空间，这样传递消息的过程中只需要传递消息的指针的就可以了，从而省去了昂贵的内存复制操作。</p><p>为了实现消息的发送和接收，<code>mach_msg()</code>函数调用了一个Mach trap,在用户态调用<code>mach_msg_trap()</code>函数会引发陷阱机制，切换到内核态，而在内核态中，内核实现的<code>mach_msg()</code>会完成实际的工作。</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是一个32位整型的标识符，不能按整数来操作，而是要按照透明的对象来操作。<br><code>像一个端口发送消息实际是将消息放在一个队列中，直到消息能被接收者处理。</code><br>所有的Mach原生对象都是通过对应的端口访问的，查找一个对象的句柄(Handle)时，实际上请求的是这个对象端口的句柄，访问端口是通过访问端口权限的方式进行的，Mach端口权限的定义如下:</p><table><thead><tr><th style="text-align:left">MACH_PORT_RIGHT_</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SEND</td><td style="text-align:left">向端口发送消息。允许多个发送者</td></tr><tr><td style="text-align:left">RECEIVE</td><td style="text-align:left">从端口读取消息，实际上这是对端口的所有权</td></tr><tr><td style="text-align:left">SEND_ONCE</td><td style="text-align:left">只发送一次消息，该权限在使用后立即被撤销(revoke)，成为DEAD_NAME</td></tr><tr><td style="text-align:left">PORT_SET</td><td style="text-align:left">同时拥有多个端口的接受权限</td></tr><tr><td style="text-align:left">DEAD_NAME</td><td style="text-align:left">端口在SEND_ONCE之后用完了权限</td></tr></tbody></table><p>关键是SEND和RECEIVE,而SEND_ONCE跟SEND一样，只不过只能发送一次。MACH_PORT_RIGHT_RECEIVE权限的持有者实际上是端口的所有者，这是允许从该端口读取队列消息的唯一实体。</p><p>&lt;mach/mach_port.h&gt;中的函数可以用于操纵任何端口，甚至可以在任务之外操纵。其中，<code>mach_port_names</code>函数可以导出给定任务的端口空间名称。</p><p>端口和权限也可以从一个实体传递到另一个实体。实际上，通过复杂消息将端口从一个任务传递到另一个任务并不罕见，这是IPC设计中的一个非常强大的特性，有点类似于UNIX中的<code>domain socket</code>允许在进程间传递描述符。<br>Lion允许UNIX文件描述符和Mach端口相互转换。这些对象称为fileport，主要有通知系统使用。</p><p>Mach通过端口命名服务器注册全局的端口-即系统范围内的端口。在XNU中，这个“自举服务器”正是PID为1的launchd(8)，该进程注册自举服务器端口，由于系统的所有进程都是launchd的后代，因此从诞生起都集成了这个端口。</p><h4 id="Mach-接口生成器-MIG"><a href="#Mach-接口生成器-MIG" class="headerlink" title="Mach 接口生成器(MIG)"></a>Mach 接口生成器(MIG)</h4><p>Mach没有使用专门的端口映射器(不过launchd(8)处理了一部分端口映射的逻辑）,但是Mach中有一个类似于<a href="https://en.wikipedia.org/wiki/RPCGEN" target="_blank" rel="noopener">rpcgen</a>的组件，即Mach接口生成器(Mach Interface Generator)，简称MIG。rpcgen在经典UNIX中的SUN-RPC中，通过rpcgen编译器从IDL(Interface Definition Language, IDL)生成代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mach-概述&quot;&gt;&lt;a href=&quot;#Mach-概述&quot; class=&quot;headerlink&quot; title=&quot;Mach 概述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Mach&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mach&lt;/a&gt; 概述&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;Mach设计原则&quot;&gt;&lt;a href=&quot;#Mach设计原则&quot; class=&quot;headerlink&quot; title=&quot;Mach设计原则&quot;&gt;&lt;/a&gt;Mach设计原则&lt;/h4&gt;&lt;p&gt;Mac OS X采用Mach作为锡系统的内核，其源头可以追溯到乔老爷创立的NeXT。Mach采用了极简主义概念:&lt;br&gt;&lt;code&gt;具有一个简单最小的核心，支持面向对象的模型，使得独立的具有良好定义的组件可以通过消息的方式互相通信。&lt;/code&gt;&lt;br&gt;Mach只提供了一个极简的模型，操作系统本身可以在这个模型基础上实现，OS X的&lt;a href=&quot;https://en.wikipedia.org/wiki/XNU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XNU&lt;/a&gt;是UNIX（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/FreeBSD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FreeBSD&lt;/a&gt; 4.4）在Mach上的一个具体实现，Windows也采用了一些Mach的原则，不过其实现方式与Mac OS则完全不同。&lt;/p&gt;
&lt;p&gt;Mach内核成为了一个底层的基础，它只关心驱动操作系统的最少需求，其余的功能则需要由上层来实现，尽管Mach对用户态也是可见的，使用Mach都是实现了深层次的核心功能，在这个基础上可以实现更大的内核，而Mach则是内核中的内核，&lt;code&gt;XNU的官方API是BSD的POSIX API,Apple保持了Mach绝对的极简，基于Mach外层则有丰富的Cocoa API来支撑，因此Mach是Mac OS X操作系统中最关键最基础的部分&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OS Kernal" scheme="http://kobeluo.com/categories/OS-Kernal/"/>
    
    
      <category term="Mach" scheme="http://kobeluo.com/tags/Mach/"/>
    
      <category term="MAC OS" scheme="http://kobeluo.com/tags/MAC-OS/"/>
    
      <category term="Mac内核" scheme="http://kobeluo.com/tags/Mac%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>git深入理解</title>
    <link href="http://kobeluo.com/2018/10/16/git-deep/"/>
    <id>http://kobeluo.com/2018/10/16/git-deep/</id>
    <published>2018-10-16T01:53:11.000Z</published>
    <updated>2018-11-16T05:41:19.833Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://www.kobeluo.com/TECH/2016/07/15/git-useage" target="_blank" rel="noopener">git使用</a>这篇文章中，博主列出了常用的git命令和一些使用方法，可以应付日常的开发工作，熟悉git的朋友应该知道，git是一个非常强大的工具，能使用git的常规命令只能说你掌握了git的基本操作，如果还需要更深入的理解git，理解每一条命令背后执行的操作和含义，则需要更为深刻的理解git的运行机制和设计原理，博主对于git的理解也很浅显，该文在谈及git内涵外，也希望有更多的大神能够相互交流，以此增进对git的理解，毕竟进步源于分享嘛 ^.^。<br><a id="more"></a></p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>先列出官方文档:</p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a></li><li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">git常用命令</a></li><li><a href="https://git-scm.com/doc" target="_blank" rel="noopener">git权威指南</a></li></ul><h2 id="git仓库介绍"><a href="#git仓库介绍" class="headerlink" title="git仓库介绍"></a>git仓库介绍</h2><h3 id="关于git仓库基础构造的官方文档如下图"><a href="#关于git仓库基础构造的官方文档如下图" class="headerlink" title="关于git仓库基础构造的官方文档如下图"></a>关于git仓库基础构造的官方文档如下图</h3><p><img src="/TECH/2018/10/16/git-deep/git-structure.png" alt="git仓库基础结构"><br><img src="/TECH/2018/10/16/git-deep/git-structure-desc.png" alt="git仓库细节"></p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><h4 id="git仓库代码树的三大状态"><a href="#git仓库代码树的三大状态" class="headerlink" title="git仓库代码树的三大状态:"></a>git仓库代码树的三大状态:</h4><p><code>Modified：</code> 代表被检出的代码已经被更改，但是还没有添加到暂存区，当然也没有提交到本地仓库；<br><code>Staged：</code> 代表被检出的代码已经加入了暂存区，它将是你下一次执行commit时提交的变更内容；<br><code>Committed：</code> 代表你的代码已经安全永久的提交到了本地仓库。</p><h4 id="git仓库的三大仓库区"><a href="#git仓库的三大仓库区" class="headerlink" title="git仓库的三大仓库区"></a>git仓库的三大仓库区</h4><p><code>git repository</code> 本地仓库，git最重要的部分，存储了一个工程所有的git信息和数据对象。<br><code>Working Directory</code> 工作目录或工作区，是指当你执行<code>git checkout branch</code>时，存储branch所指的节点的数据和git信息，以提供你增删改查。<br><code>Staging Area</code> 暂存区 介于检出代码于modified和committed之间的一种状态区域，当你执行<code>git add -a</code>时，将已经modified的代码添加到暂存区，以供下一次commit时将暂存区的变更提交到本地仓库。</p><h4 id="从实际项目出发理解"><a href="#从实际项目出发理解" class="headerlink" title="从实际项目出发理解"></a>从实际项目出发理解</h4><p>1.执行<code>git clone</code>时，将远程代码clone到本地，此时建立了git本地仓库，同时默认工作区是master分支，此时暂存区为空；<br>2.执行<code>git checkout branch</code>时，将branch分支的代码作为工作区，此时工作区从master分支变更为branch分支的代码内容和git信息；<br>3.现在开始增删改查项目的内容；<br>4.当你保存更改时，git将变更的内容标记为modified；<br>5.此时你可能需要提交代码了；执行 <code>git add .</code>将 已更改的代码提交到暂存区，被更改的代码的状态从<code>Modified</code>变更为<code>Staged</code>；<br>6.此时执行命令<code>git commit</code>提交代码，将暂存区的变更快照提交到本地仓库，变更代码状态从<code>Staged</code>变更为<code>Committed</code>，自此你的变更内容将永久安全的存储到本地仓库。</p><h2 id="文件的记录过程"><a href="#文件的记录过程" class="headerlink" title="文件的记录过程"></a>文件的记录过程</h2><p>每个文件在working copy中的状态有两种: tracked(被跟踪) or untracked(未被跟踪)<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Remember</span> that each file <span class="keyword">in</span> your working directory can be <span class="keyword">in</span> one of two states: tracked or untracked. </span><br><span class="line"><span class="type">Tracked</span> files are files that were <span class="keyword">in</span> the last snapshot; they can be unmodified, modified, or staged.</span><br><span class="line"><span class="type">In</span> short, tracked files are files that <span class="type">Git</span> knows about.</span><br></pre></td></tr></table></figure></p><p>被跟踪的文件的文件状态存储在最后一次快照中。<br><img src="/TECH/2018/10/16/git-deep/file-status-all.png" alt="git文件全状态"></p><h2 id="忽略暂存区提交"><a href="#忽略暂存区提交" class="headerlink" title="忽略暂存区提交"></a>忽略暂存区提交</h2><p>常用的提交流程是：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></p><p>命令<code>git add .</code>会将已变更的代码添加到暂存区，然后通过<code>git commit</code>命令将暂存区的快照提交到本地仓库。</p><p>这儿还有一种方式提交代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></p><p>它的意思是绕过暂存区，直接将本地被追踪的变更代码提交到本地仓库。<br><em>相同点：</em></p><ul><li>被追踪的代码都可以直接提交到本地working copy。</li></ul><p><em>不同点：</em></p><ul><li>未被追踪的文件使用后者无法正常提交到本地working copy；</li><li>后者的代码将不被添加到暂存区；</li><li>前者是较为安全的提交方式，一旦你执行了<code>git reset --hard</code>且未push到远端，那么代码将永久丢失。</li></ul><h2 id="git-commit-实现"><a href="#git-commit-实现" class="headerlink" title="git commit 实现"></a>git commit 实现</h2><p>假如说当前是一个全新的仓库，并执行以下命令：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span> </span><br><span class="line">git add <span class="type">README</span> test.rb <span class="type">LICENSE</span></span><br><span class="line">git commit -m :<span class="type">The</span> <span class="type">Initial</span> commit of my project:</span><br></pre></td></tr></table></figure></p><p>当你运行<code>git commit</code>创建commit时，git checksums所有的子目录和git仓库中存储这些文件的<code>tree object</code>，同时git创建一个拥有元数据和一个指向<code>root project tree</code>的指针的<code>commit object</code>, 一个<code>commit object</code>其实质上就是一个<code>snapshot</code>.</p><p>现在，git仓库包含了五个object,分别是三个文件(README test.rb LICENSE),一个包含跟目录下所有内容<br>和指定<code>name&lt;--&gt;file匹配</code>的列表的<code>tree</code>和一个包含所有提交元数据和指向<code>root true</code>的指针，<br>比较抽象，其实就是三个文件和一个snapshot和一个指向<code>root commit</code>的指针，如下图所示：<br><img src="/TECH/2018/10/16/git-deep/commit-root.png" alt="commit-root"></p><p>此时如果你又提交了几次，那么关于snapshot和指针的关系图，如下所示：<br><img src="/TECH/2018/10/16/git-deep/snap-pointer-relation.png" alt="snap-pointer-relation"></p><p>通过上图可以理解到git commit背后运行的规律：<br><div class="note info"><p>1.git commit并不是存储的变化的文件，而是存储的一些列snapshot和一个带链表结构的指向父指针的指针。<br>2.整个分支结构路由是靠链表结构的指针来运作的，所以当你<code>git branch newbranch</code>时，其实就是创建了一个新的指针，该指针指向当前的指针加上一个branch name,整个过程非常高效快速。<br>3.当通过<code>git checkout commitId</code>去切换到以前的某个分支时，其实是通过指针去挨个找寻父指针，并从父指针指向的snapshot中去将变更挨个恢复，因此你可以感觉到chekout越早的分支速度越慢，git需要遍历更多的指针去恢复变更数据。</p></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://www.kobeluo.com/TECH/2016/07/15/git-useage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git使用&lt;/a&gt;这篇文章中，博主列出了常用的git命令和一些使用方法，可以应付日常的开发工作，熟悉git的朋友应该知道，git是一个非常强大的工具，能使用git的常规命令只能说你掌握了git的基本操作，如果还需要更深入的理解git，理解每一条命令背后执行的操作和含义，则需要更为深刻的理解git的运行机制和设计原理，博主对于git的理解也很浅显，该文在谈及git内涵外，也希望有更多的大神能够相互交流，以此增进对git的理解，毕竟进步源于分享嘛 ^.^。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kobeluo.com/categories/Tools/"/>
    
    
      <category term="git理解" scheme="http://kobeluo.com/tags/git%E7%90%86%E8%A7%A3/"/>
    
      <category term="git" scheme="http://kobeluo.com/tags/git/"/>
    
      <category term="git进阶" scheme="http://kobeluo.com/tags/git%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Swift 桥接OC代码重构</title>
    <link href="http://kobeluo.com/2018/07/05/codesnapshot/"/>
    <id>http://kobeluo.com/2018/07/05/codesnapshot/</id>
    <published>2018-07-05T02:48:11.000Z</published>
    <updated>2018-11-16T05:44:39.738Z</updated>
    
    <content type="html"><![CDATA[<p>博主目前从事NAVER旗下公司的一个虚拟云盘工作开发，开发语言选择了Swift，但是Objective-C中有一些非常方便的API函数在Swift中并没有提供，早起博主直接使用了官方提供的<a href="https://stackoverflow.com/questions/24002369/how-to-call-objective-c-code-from-swift" target="_blank" rel="noopener">bridge</a>方案来桥接OC部分代码，这样可以方便的使用OC的API，但是这也带来一个性能问题，每次桥接的过程会有一定的耗时；</p><p>如果你的项目只是一个普通的信息展示，调用的频次不高，对于性能的优化要求可能就相对较低，但如果你的项目是高频次调用这些API，<a id="more"></a>并且对性能的要求极尽所能，可能你就会对每一行代码的执行效率和耗时做严格的审查，为了提供性能，可能需要将OC函数自己实现，分享部分代码，以供参考。</p><h3 id="String-Extension"><a href="#String-Extension" class="headerlink" title="String Extension"></a>String Extension</h3><h4 id="lastPathComponents"><a href="#lastPathComponents" class="headerlink" title="lastPathComponents"></a>lastPathComponents</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> lastPathComponent: <span class="type">String</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.decomposedStringWithCanonicalMapping</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> str.<span class="built_in">count</span> &lt;= <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="number">_</span>, value) <span class="keyword">in</span> str.enumerated().reversed() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">"/"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> name != <span class="string">""</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; name = <span class="type">String</span>(value) + name &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于String的格式 FormC 和 FormD，请<a href="http://www.kobeluo.com/TECH/2018/11/05/StringEncode/" target="_blank" rel="noopener">右转</a></p><h4 id="pathComponents"><a href="#pathComponents" class="headerlink" title="pathComponents"></a>pathComponents</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> pathComponents: [<span class="type">String</span>] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = [<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">var</span> resultCnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">let</span> strcnt = str.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">var</span> component: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">"/"</span> &#123; results.append(<span class="string">"/"</span>); <span class="keyword">return</span> results &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pre: <span class="type">Character</span>? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">var</span> pathRepeat = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (index,value) <span class="keyword">in</span> str.enumerated() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">"/"</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pre == <span class="string">"/"</span> &#123; pathRepeat = <span class="literal">true</span> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> com = component &#123; results.append(com); resultCnt += <span class="number">1</span> &#125;</span><br><span class="line">                component = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pathRepeat || (resultCnt == <span class="number">0</span> &amp;&amp; pre == <span class="string">"/"</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                pathRepeat = <span class="literal">false</span>; results.append(<span class="string">"/"</span>); resultCnt += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> component == <span class="literal">nil</span> &#123; component = <span class="string">""</span> &#125;</span><br><span class="line">            component?.append(value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index == strcnt - <span class="number">1</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> com = component &#123; results.append(com) &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; results.append(<span class="string">"/"</span>) &#125;</span><br><span class="line">            </span><br><span class="line">            resultCnt += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pathRegularly"><a href="#pathRegularly" class="headerlink" title="pathRegularly"></a>pathRegularly</h4><p>该函数是一个基础函数，服务于其它函数，服务于其它函数的内部函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pathRegularly</span><span class="params">(of str: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> prechar: <span class="type">Character</span> = <span class="string">"1"</span></span><br><span class="line">    <span class="keyword">let</span> strcnt = str.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">for</span> (index,char) <span class="keyword">in</span> str.enumerated() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> char != <span class="string">"/"</span> || prechar != <span class="string">"/"</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> index == strcnt - <span class="number">1</span> &amp;&amp; char == <span class="string">"/"</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">            result.append(char)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prechar = char</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastchar = result.last, lastchar == <span class="string">"/"</span> &#123; result.removeLast() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="appendingPathComponent"><a href="#appendingPathComponent" class="headerlink" title="appendingPathComponent"></a>appendingPathComponent</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">appendingPathComponent</span><span class="params">(path: String?, regularly: Bool = <span class="literal">false</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> path = path <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> str = <span class="keyword">self</span>; <span class="keyword">var</span> name = path</span><br><span class="line">    <span class="keyword">if</span> regularly == <span class="literal">false</span> &#123;</span><br><span class="line">        </span><br><span class="line">        str = pathRegularly(of: <span class="keyword">self</span>); name = pathRegularly(of: path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> firstchar = name.first, firstchar == <span class="string">"/"</span> &#123; <span class="keyword">return</span> str + name &#125;</span><br><span class="line"><span class="keyword">return</span> str + <span class="string">"/"</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="String+Path.swift">点我下载String+path.swift</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博主目前从事NAVER旗下公司的一个虚拟云盘工作开发，开发语言选择了Swift，但是Objective-C中有一些非常方便的API函数在Swift中并没有提供，早起博主直接使用了官方提供的&lt;a href=&quot;https://stackoverflow.com/questions/24002369/how-to-call-objective-c-code-from-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bridge&lt;/a&gt;方案来桥接OC部分代码，这样可以方便的使用OC的API，但是这也带来一个性能问题，每次桥接的过程会有一定的耗时；&lt;/p&gt;
&lt;p&gt;如果你的项目只是一个普通的信息展示，调用的频次不高，对于性能的优化要求可能就相对较低，但如果你的项目是高频次调用这些API，&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="代码共享" scheme="http://kobeluo.com/tags/%E4%BB%A3%E7%A0%81%E5%85%B1%E4%BA%AB/"/>
    
      <category term="片段代码" scheme="http://kobeluo.com/tags/%E7%89%87%E6%AE%B5%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>FinderSync插件的使用及调试</title>
    <link href="http://kobeluo.com/2018/01/15/FinderSync/"/>
    <id>http://kobeluo.com/2018/01/15/FinderSync/</id>
    <published>2018-01-15T10:01:23.000Z</published>
    <updated>2019-01-21T05:44:48.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FinderSync-简要描述"><a href="#FinderSync-简要描述" class="headerlink" title="FinderSync 简要描述"></a><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html" target="_blank" rel="noopener">FinderSync</a> 简要描述</h3><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html" target="_blank" rel="noopener">FinderSync</a>是苹果官方提供的一个用来扩展Finder进程的一个插件，它通过监控Finder进程的一个URL组来实现对指定路径下的文件及文件夹的指定事件进行回调，一般它用于文件同步产品或者Finder相关的开发产品，它主要的功能有以下几点:</p><ul><li><strong>在Finder上创建一个自定义的右键菜单按钮以及点击后的事件回调</strong><a id="more"></a></li><li><strong>在Finder上创建toolbar快捷按钮及事件回调</strong></li><li><strong>自定义sidebarIcon(侧边栏图标)</strong></li><li><strong>控制的目录及其递归子目录下的文件和文件夹的图标变化</strong></li></ul><p>关于如何是用FinderSync插件博主就不介绍了，很简单，<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html" target="_blank" rel="noopener">苹果官方文档</a>.</p><p>这篇文章的主要目的是介绍如何手动调试<code>FinderSync</code>。</p><h3 id="FinderSync调试"><a href="#FinderSync调试" class="headerlink" title="FinderSync调试"></a>FinderSync调试</h3><p>在早期时间，<code>FinderSync</code>可以通过挂在到Finder进程上直接启动调试，不知道从什么时候开始，直接调试<code>FinderSync</code>时，它会一直处于<strong>Waiting to Attch</strong>这样一直状态，该进程一直停留在这个状态上，调试<code>FinderSync</code>变成了一件非常恶心的事情，它是独立于主进程(main application)之外的另一个进程，因此你无法直接在主进程中进行断点调试，如果你直接使用NSLog来查看日志也是行不通的，博主这里提供两种调试方式:</p><h4 id="记录日志到磁盘"><a href="#记录日志到磁盘" class="headerlink" title="记录日志到磁盘"></a>记录日志到磁盘</h4><p>通过<code>writeToFile</code>方法将log日志记录到本地指定文件下，通过文件的内容变更来调试FinderSync,这种方式可以通过查看本地日志来完成<code>FinderSync</code>的调试，但效率非常低。</p><h4 id="创建额外的FinderSync"><a href="#创建额外的FinderSync" class="headerlink" title="创建额外的FinderSync"></a>创建额外的FinderSync</h4><p>通过调试发现，如果你的产品项目有多个Target,并且有多个FinderSync插件的时候，通过启动其它的插件可以把你想调试的插件一并启动起来，设置断点后可以直接进行调试，博主并不知道这是为什么，但它的确是可行并有效地，具体处理方法如下:</p><ol><li>假设有一个工程叫<code>SmartSync</code>,<code>SmartSync</code>中的主进程叫<code>remoteSync</code>,它用于做远程文件系统同步相关工作。</li><li>你可能需要FinderSync插件来完成一些特殊的功能，此时你可以直接从target中选中FinderSync插件，并命名为<strong>FinderSync_main</strong>，并将它作为<code>remoteSync</code>的插件。</li><li>为了调试方便，现在你再创建一个<em>target</em>叫做<code>remoteSync_help</code>,然后再从target中选取一个Findersync插件，命名为<strong>FinderSync_helper</strong>,将它作为<code>remoteSync_help</code>的插件。</li><li>正常启动你的主进程<code>remoteSync</code>，<code>FinderSync_main</code>会跟随主进程自动启动起来，此时你可以在系统进程监视窗口<code>ActivityMonitor</code>中直接把<code>FinderSync_main</code>Kill掉，或者干脆什么也不做。</li><li>选中target<code>FinderSync_helper</code>并运行他，<code>Xcode</code>会让你选择一个app来加载，选择Finder,然后<code>FinderSync_helper</code>会加载起来，并主动将<code>FinderSync_main</code>也附带加载起来。</li><li>此时在<code>FinderSync_main</code>的代码中打断点，就可以直接调试了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;FinderSync-简要描述&quot;&gt;&lt;a href=&quot;#FinderSync-简要描述&quot; class=&quot;headerlink&quot; title=&quot;FinderSync 简要描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FinderSync&lt;/a&gt; 简要描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FinderSync&lt;/a&gt;是苹果官方提供的一个用来扩展Finder进程的一个插件，它通过监控Finder进程的一个URL组来实现对指定路径下的文件及文件夹的指定事件进行回调，一般它用于文件同步产品或者Finder相关的开发产品，它主要的功能有以下几点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在Finder上创建一个自定义的右键菜单按钮以及点击后的事件回调&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="FinderSync" scheme="http://kobeluo.com/tags/FinderSync/"/>
    
      <category term="Finder插件" scheme="http://kobeluo.com/tags/Finder%E6%8F%92%E4%BB%B6/"/>
    
      <category term="右键菜单" scheme="http://kobeluo.com/tags/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    
      <category term="文件图标" scheme="http://kobeluo.com/tags/%E6%96%87%E4%BB%B6%E5%9B%BE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS/Mac OS下的 Crash 崩溃分析</title>
    <link href="http://kobeluo.com/2017/11/16/crashAnalysis/"/>
    <id>http://kobeluo.com/2017/11/16/crashAnalysis/</id>
    <published>2017-11-16T05:35:48.000Z</published>
    <updated>2018-12-07T05:23:19.885Z</updated>
    
    <content type="html"><![CDATA[<p>就普通的开发而言，普通需求的实现，对于大多数有经验的开发者只是时间问题，其实并没有太大的难度，需求的实现过程则相对轻松；</p><p>比较恶心的是发布产品后，遇到的各式奇葩的crash，如果你早有准备，在发布的时候打包了符号文件，那么恭喜你，你还可以通过符号文件来查找崩溃代码，否则，可能就是让bug出现者不停的复现crash，费事费力，可能最终还找不到问题。</p><p>符号文件可以通过一定规则将内存地址转换为可读的函数名和一些代码的行号，当你通过Xcode窗口产生的crash时，通常在console中看到的结果是已经被符号化的结果。</p><p>一般的崩溃日志都会产生一个线程回溯列表，让你去回溯到指定的crash函数，但是内存警告不会产生线程回溯，官方的解释是低内存发生时不需要线程回溯信息，当发生内存警告时，你必须要重视内存的使用模式并在内存警告发生时的回调函数处理相关的内存泄露。</p><p>本文大多数内容来源于Apple的官方文档，<a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="noopener">地址在这</a></p><p>这篇博文意在如何收集crash，如何分析crash.<br><a id="more"></a></p><h3 id="crash日志的收集"><a href="#crash日志的收集" class="headerlink" title="crash日志的收集"></a>crash日志的收集</h3><h4 id="常规发布和崩溃信息收集流程"><a href="#常规发布和崩溃信息收集流程" class="headerlink" title="常规发布和崩溃信息收集流程"></a>常规发布和崩溃信息收集流程</h4><p>先看苹果官方的一张流程图如下：</p><p><img src="https://developer.apple.com/library/archive/technotes/tn2151/Art/tn2151_crash_flow.png" alt="crash connect"></p><p>1.编译器将源码转化成机器码，并生成调试符号文件，用于将机器码回溯成源代码的行号和函数名，关于dsYM的设置可以在<code>BuildSettings</code>搜索<em>DEBUG_INFORMATION_FORMAT</em>设置，这些调试符号存储在二进制文件中或者.dsYM文件中，debug包的应用存储编译后的二进制文件中，而release包的的符号文件则伴随在<em>.dsYM</em>文件中，以便节省包的大小。</p><p>调试符号文件和产品二进制包被捆包在一个基于每次编译的一个UUID, 每次编译都会产生一个新的UUID,即使没有任何内容更改。</p><p>2.一旦你使用Archive了一个发布包，Xcode会生成一个带有.dsYM的二进制包到Xcode的oranizer下的Archived组。<br><img src="/TECH/2017/11/16/crashAnalysis/orgnizerArchived.png" alt="archived"></p><p>3.当你上传准备好的二进制包到iTunesConnect时，有一个可选项是让你选择二进制包是否包含.dSYM文件<em>Include app symbols for your application…</em>,为了后续分析问题方便，建议勾选。</p><p>4.产品发布后，关于你的产品的任何崩溃都将在用户的手机中创建并存储崩溃信息。</p><p>5.用户可以从设备中通过<a href="https://developer.apple.com/library/archive/qa/qa1747/_index.html" target="_blank" rel="noopener">调试发布的产品</a>中直接取到crash报告。如果你的包是“AdHoc”或”Enterprise”企业版发布，那么这种方式将是苹果提供的唯一一种读取崩溃报告的方式。</p><p>6.通过Xcode将你取到的.crash文件通过.dSYM文件反解析成崩溃的响应行号和函数名。</p><p>7.如果发送崩溃的用户愿意分享崩溃报告的数据，该crash文件将上传至App Store，你可以直接从App Store下载响应的崩溃文件。</p><p>8.Apple Store符号化崩溃报告，并将类似的崩溃报告组合在一起，形成一个相似的崩溃报告，这被称为崩溃点。</p><p>9.crash崩溃报告也可以在“Organizer的Crash组”中看到。 </p><h4 id="dsYM文件的获取方式"><a href="#dsYM文件的获取方式" class="headerlink" title=".dsYM文件的获取方式"></a>.dsYM文件的获取方式</h4><ul><li><p>通过“Organizer的Archived”找到你发布的相应包，然后右键“ShowInFinder”去找<br><img src="/TECH/2017/11/16/crashAnalysis/finderShowPackage.png" alt="finder"><br><img src="/TECH/2017/11/16/crashAnalysis/dsYM.png" alt="dSYM"></p></li><li><p>通过iTunes Connect查找。<br>具体方法是登录iTunesConnect,点击某个APP详情页，从所有的编译版本中找到需要的版本，然后点击下载相应的dSYM文件。</p></li></ul><h4 id="识别崩溃报告是否被符号化"><a href="#识别崩溃报告是否被符号化" class="headerlink" title="识别崩溃报告是否被符号化"></a>识别崩溃报告是否被符号化</h4><p>一个崩溃报告的符号化状态有三种:“未符号化”、”部分符号化”和”完全符号化”，下面是官方给的符号化示意图:<br><img src="https://developer.apple.com/library/archive/technotes/tn2151/Art/tn2151_symbolication_levels.png" alt=""></p><h4 id="符号化的方式"><a href="#符号化的方式" class="headerlink" title="符号化的方式"></a>符号化的方式</h4><h5 id="使用Xcode来符号化崩溃报告"><a href="#使用Xcode来符号化崩溃报告" class="headerlink" title="使用Xcode来符号化崩溃报告"></a>使用Xcode来符号化崩溃报告</h5><p>对于可直接获取设备的崩溃可以采用以下方式</p><blockquote><p>1.Connect an iOS device to your Mac<br>2.Choose “Devices” from the “Window” menu<br>3.Under the “DEVICES” section in the left column, choose a device<br>4.Click the “View Device Logs” button under the “Device Information” section on the right hand panel<br>5.Drag your crash report onto the left column of the presented panel<br>6.Xcode will automatically symbolicate the crash report and display the results</p></blockquote><h5 id="使用atos来符号化崩溃报告"><a href="#使用atos来符号化崩溃报告" class="headerlink" title="使用atos来符号化崩溃报告"></a>使用atos来符号化崩溃报告</h5><p>atos命令可以将地址转化成可读的行号和函数名，它可以符号化线程回溯中的一个独立的地址，换言之，他可以做部分符号化，<br>其命令如下:<br><img src="https://developer.apple.com/library/archive/technotes/tn2151/Art/tn2151_atos_info.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</span><br></pre></td></tr></table></figure></p><p>其中 Binary Architecture指的是崩溃设备的架构，在.crash文件顶部的Code Type,mac上一般是x86-64的架构。</p><p>简单的使用方法总结如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.找到crash文件相应版本号下的dSYM文件</span><br><span class="line">2.下载相应.crash文件，并打开。</span><br><span class="line">3.找到.crash文件顶部信息中的CodeType并记录,它包含ARM-64, ARM, x86-64, or x86.</span><br><span class="line">4.在.crash文件中搜索Binary Images:,并记下你的包对应的 loadAddress</span><br><span class="line">loadAddress也可以通过计算得到，等于（symbolicateAddress转10进制 - 偏移量）再转16进制，</span><br><span class="line">loadAddress的后三位通常都是000，如果不是，则可能计算有误。</span><br><span class="line"></span><br><span class="line">5.终端cd到 dSYM文件package contents下的DWARF目录</span><br><span class="line">6.执行: atos -arch x86_64 -o appNameInDWARF -l loadAddress symbolicateAdress</span><br></pre></td></tr></table></figure></p><h3 id="分析崩溃报告"><a href="#分析崩溃报告" class="headerlink" title="分析崩溃报告"></a>分析崩溃报告</h3><p>这部分内容讨论当你获取到<code>.crash</code>文件时，如何分析崩溃信息。</p><h4 id="Header信息"><a href="#Header信息" class="headerlink" title="Header信息"></a>Header信息</h4><p>每一个<code>.crash</code>文件的第一部分内容都是一个格式相同的header信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: B6FD1E8E-B39F-430B-ADDE-FC3A45ED368C</span><br><span class="line">CrashReporter Key: f04e68ec62d3c66057628c9ba9839e30d55937dc</span><br><span class="line">Hardware Model: iPad6,8</span><br><span class="line">Process: TheElements [303]</span><br><span class="line">Path: /private/var/containers/Bundle/Application/888C1FA2-3666-4AE2-9E8E-62E2F787DEC1/TheElements.app/TheElements</span><br><span class="line">Identifier: com.example.apple-samplecode.TheElements</span><br><span class="line">Version: 1.12</span><br><span class="line">Code Type: ARM-64 (Native)</span><br><span class="line">Role: Foreground</span><br><span class="line">Parent Process: launchd [1]</span><br><span class="line">Coalition: com.example.apple-samplecode.TheElements [402]</span><br><span class="line"> </span><br><span class="line">Date/Time: 2016-08-22 10:43:07.5806 -0700</span><br><span class="line">Launch Time: 2016-08-22 10:43:01.0293 -0700</span><br><span class="line">OS Version: iPhone OS 10.0 (14A5345a)</span><br><span class="line">Report Version: 104</span><br></pre></td></tr></table></figure></p><p>相关字段解释如下：</p><ul><li>Incident Identifier: 每一份<code>.crash</code>文件的唯一标志，不同的崩溃文件的唯一标志不重复</li><li>CrashReporter Key: 匿名的设备标志，只要来自该设备的崩溃信息的crashReporterKey都是一样的</li><li>Process: 崩溃进程的可执行名称，匹配项目<code>info.plist</code>文件中的<code>CFBundleExecutable</code> key</li><li>Version: 崩溃进程的版本号，匹配项目<code>info.plist</code>文件中的<code>CFBundleVersion</code>和<code>CFBundleVersionString</code> key</li><li>Code Type: 崩溃进程所在机器的架构模式，目前的架构模式有<code>ARM-64, ARM, x86-64, x86</code></li><li>OS Version: OS系统版本号</li><li>Role: 在进程crash时分配给进程的<a href="http://opensource.apple.com/source/xnu/xnu-3248.60.10/osfmk/mach/task_policy.h" target="_blank" rel="noopener">task role</a></li></ul><p>通过以上Header信息的分析，可以获取到崩溃报告的环境内容，通过符号化可以将符号文件符号到的代码行，这样基本上可以获取到崩溃的大致情况。</p><h4 id="Mach-异常信息解析"><a href="#Mach-异常信息解析" class="headerlink" title="Mach 异常信息解析"></a>Mach 异常信息解析</h4><h5 id="Mach信息解读"><a href="#Mach信息解读" class="headerlink" title="Mach信息解读"></a>Mach信息解读</h5><p>这里所说的Mach 异常信息解析跟Objective-C/C++的异常信息不同，它表示在内核态的崩溃信息，当然并不是所有的崩溃都来自内核态，但当进程崩溃时，内核态会有一个信息表示在<code>.crash</code>文件中，以供参考</p><p>比如以下崩溃信息来自一段未被捕获的OC代码崩溃时的内核态信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception Type: EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note: EXC_CORPSE_NOTIFY</span><br><span class="line">Triggered by Thread: 0</span><br></pre></td></tr></table></figure></p><p>而以下是来自一个NULL指针的取消引用引发的崩溃是内核态信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception Type: EXC_BAD_ACCESS (SIGSEGV)</span><br><span class="line">Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000</span><br><span class="line">Termination Signal: Segmentation fault: 11</span><br><span class="line">Termination Reason: Namespace SIGNAL, Code 0xb</span><br><span class="line">Terminating Process: exc handler [0]</span><br><span class="line">Triggered by Thread: 0</span><br></pre></td></tr></table></figure></p><p>相关字段解释如下:</p><ul><li>Exception Code: 当进程崩溃时，崩溃信息被编码成一个或多个64位的十六进制号码，一般情况下这个字段不会展示因为都以更友好的方式展示到了其它字段</li><li>Exception Subtype: 对<code>Exception Code</code>的可视化解释</li><li>Exception Message: 对<code>Exception Code</code>的附加解释和说明</li><li>Exception Note: 对崩溃信息的另一种附加说明，如果该字段包括<code>SIMULATED</code>则说明进程并不是真正的产生了崩溃，而是因为系统要求而被Kill掉，典型的例子:<a href="https://en.wikipedia.org/wiki/Watchdog_timer" target="_blank" rel="noopener">看门狗</a></li><li>Terminal Reason: 进程的内部和外部关键组件在进程发送错误时将进程结束时的原因</li><li>Triggered by Thread: 进程崩溃的线程号</li></ul><h3 id="常规异常类型解读"><a href="#常规异常类型解读" class="headerlink" title="常规异常类型解读"></a>常规异常类型解读</h3><h5 id="内存访问错误-EXC-BAD-ACCESS、-SIGSEGV、SIGBUS"><a href="#内存访问错误-EXC-BAD-ACCESS、-SIGSEGV、SIGBUS" class="headerlink" title="内存访问错误 (EXC_BAD_ACCESS、 SIGSEGV、SIGBUS)"></a>内存访问错误 (EXC_BAD_ACCESS、 SIGSEGV、SIGBUS)</h5><p>进程尝试访问一个无效的内存地址，或者尝试访问没有权限的访问的内存地址都将引发内存访问错误。当内存访问错误发生时，<code>.crash</code>文件的<code>Exception Subtype1</code>会包含一个<code>kern_return_t</code>的描述错误和读取时的错误内存地址。</p><p>以下是调试内存访问错误的提示:</p><ul><li>如果<code>objc_msgSend</code>或<code>objc_release</code>接近线程回溯的顶部，那么该进程可能尝试访问一个已经被销毁的内存地址。使用Instrument的<code>Zombies</code>对于定位crash可能是更好的方式</li><li>如果<code>gpus_ReturnNotPermittedKillClient</code>接近线程回溯的顶部，那么该进程可能是在后台尝试是用OpenGL或Metal来处理渲染工作，该问题的讨论地址<a href="https://developer.apple.com/library/archive/qa/qa1766/_index.html" target="_blank" rel="noopener">在这</a></li><li>在项目的Secheme中开启<code>Address Sanitizer</code>，当发送内存崩溃时，Xcode会自动提醒</li></ul><h5 id="异常退出-EXC-CRASH、-SIGABRT"><a href="#异常退出-EXC-CRASH、-SIGABRT" class="headerlink" title="异常退出 (EXC_CRASH、 SIGABRT)"></a>异常退出 (EXC_CRASH、 SIGABRT)</h5><p>进程异常退出最常见的原因就是一个未被捕获的Objective-C/C++的错误和调用了<code>abort()</code>函数<br>App的扩展程序也可能产生类似的崩溃信息，如果太多次的被初始化。如果一个扩展程序在launch过程中Hang了，Exception Subtype将报<code>LAUNCH_HANG</code>，因为扩展程序并没有<code>main（）</code>函数，扩展程序或其独立库的时间花销都在静态构造器和<code>+load()</code>函数中</p><h5 id="跟踪陷阱-EXC-BREAKPOINT、-SIGTRAP"><a href="#跟踪陷阱-EXC-BREAKPOINT、-SIGTRAP" class="headerlink" title="跟踪陷阱 (EXC_BREAKPOINT、 SIGTRAP)"></a>跟踪陷阱 (EXC_BREAKPOINT、 SIGTRAP)</h5><p>这种异常为附加调试者一个在进程执行体中的某个指定点中断进程的机会，你可以在代码中的某个位置添加函数<code>__builtin_trap()</code>来触发该异常，如果没有调试者被附加，那么进程将结束并生成一个崩溃报告</p><p>Apple底层的一些库（如libdispatch）也会使用这种方式在发生致命错误时来捕获进程，附加信息将会在console中体现，也可以<a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-APPINFO" target="_blank" rel="noopener">在这查询</a></p><p>Swift也经常用到trap机制来引发异常，比如在运行时状态下:</p><ul><li>一个不可选的value被置为nil时</li><li>类型强转失败时</li></ul><h5 id="非法指令-EXC-BAD-INSTRUCTION、-SIGILL"><a href="#非法指令-EXC-BAD-INSTRUCTION、-SIGILL" class="headerlink" title="非法指令 (EXC_BAD_INSTRUCTION、 SIGILL)"></a>非法指令 (EXC_BAD_INSTRUCTION、 SIGILL)</h5><p>当进程尝试执行一个非法的或未经定义的指令时，进程可能会尝试通过一个错误的函数指针跳转到一个错误的地址，从而会引发该错误。<br>在Inter处理器上面，<code>ud2</code>操作码会引发一个<code>EXC_BAD_INSTRUCTION</code>异常，但通常也是使用这个trap来达到调试的目的。而Inter处理器上的Swift代码在运行时遇到意外情况将引发该错误</p><h5 id="退出Quit-（SIGQUIT）"><a href="#退出Quit-（SIGQUIT）" class="headerlink" title="退出Quit （SIGQUIT）"></a>退出Quit （SIGQUIT）</h5><p>进程结束于另一个有权管理其生命周期的进程，因此<code>SIGOUT</code>并不意味这该进程发生了崩溃，但是它也可能以一种可以检测的方式发生异常。</p><p>在iOS系统中，如果键盘扩展加载时间过长，主机应用程序将退出键盘扩展。崩溃报告中显示的线程回溯不太可能指向具体的响应代码。而最有可能的情况是，扩展的启动路径上的其他一些代码花了很长时间才完成，但是在时间限制之前已经完成了，并且在退出扩展时将执行代码显示在线程回溯上。您应该对扩展进行概要分析，以便更好地理解启动期间的大部分工作发生在哪里，并将该工作转移到后台线程，或者将其延迟到稍后(在加载扩展之后)。</p><h5 id="被杀死-Killed-SIGKILL"><a href="#被杀死-Killed-SIGKILL" class="headerlink" title="被杀死 Killed (SIGKILL)"></a>被杀死 Killed (SIGKILL)</h5><p>说明该进程被系统杀死，并且在崩溃信息的Header的<code>Exception Reason</code>字段中会包含一个命名空间，后面跟随一个代码</p><div class="note info"><p>The following codes are specific to watchOS:</p><ul><li>The termination code 0xc51bad01 indicates that a watch app was terminated because it used too much CPU time while performing a background task. To address this issue, optimize the code performing the background task to be more CPU efficient, or decrease the amount of work that the app performs while running in the background.</li><li>The termination code 0xc51bad02 indicates that a watch app was terminated because it failed to complete a background task within the allocated time. To address this issue, decrease the amount of work that the app performs while running in the background.</li><li>The termination code 0xc51bad03 indicates that a watch app failed to complete a background task within the allocated time, and the system was sufficiently busy overall that the app may not have received much CPU time with which to perform the background task. Although an app may be able to avoid the issue by reducing the amount of work it performs in the background task, 0xc51bad03 does not indicate that the app did anything wrong. More likely, the app wasn’t able to complete its work because of overall system load.</li></ul></div><h5 id="违反受保护资源-（EXC-GUARD）"><a href="#违反受保护资源-（EXC-GUARD）" class="headerlink" title="违反受保护资源 （EXC_GUARD）"></a>违反受保护资源 （EXC_GUARD）</h5><p>当访问系统被保留或受保护的资源时，会引发一个<code>EXC_GUARD</code>错误，这些被保留的资源只允许在系统级的私有API才能访问。<br>在较新版本的iOS系统中，当违反了被保留的资源时，会在<code>Exception Subtype</code>和<code>Exception Message</code>字段中以更友好的方式提示给开发者，但是在Mac OS和早起的iOS系统中，该错误信息只会在<code>Exception Code</code>中体现，具体分解如下:<br><div class="note info"><p>as a bitfield which breaks down as follows:</p><p>[63:61] - Guard Type: The type of the guarded resource. A value of 0x2 indicates the resource is a file descriptor.<br>[60:32] - Flavor: The conditions under which the violation was triggered.</p><ul><li>If the first (1 &lt;&lt; 0) bit is set, the process attempted to invoke close() on a guarded file descriptor.</li><li>If the second (1 &lt;&lt; 1) bit is set, the process attempted to invoke dup(), dup2(), or fcntl() with the F_DUPFD or F_DUPFD_CLOEXEC commands on a guarded file descriptor.</li><li>If the third (1 &lt;&lt; 2) bit is set, the process attempted to send a guarded file descriptor via a socket.</li><li>If the fifth (1 &lt;&lt; 4) bit is set, the process attempted to write to a guarded file descriptor.</li></ul><p>[31:0] - File Descriptor: The guarded file descriptor that the process attempted to modify.</p></div></p><h5 id="超出资源限制-Resource-Limit-（EXC-RESOURCE）"><a href="#超出资源限制-Resource-Limit-（EXC-RESOURCE）" class="headerlink" title="超出资源限制 Resource Limit （EXC_RESOURCE）"></a>超出资源限制 Resource Limit （EXC_RESOURCE）</h5><p>该进程超出了资源消耗限制。这是来自操作系统的一个通知，进程使用了太多的资源。在<code>Exception Subtype</code>字段中列出了准确的信息。如果<code>Exception Note</code>字段包含<code>NON FATAL</code>,<code>CONDITION</code>，那么即使生成了崩溃报告，进程也不会被终止。</p><ul><li>如果<code>Exception Subtype</code>为<code>MEMORY</code>代表该进程已经超越了系统准予的内存限制，这可能是终止超量内存使用的前兆。</li><li>如果<code>Exception Subtype</code>为<code>WAKEUPS</code>代表该进程中的线程在每秒中被过于频繁的唤醒，这将会强制CPU频繁唤醒，进而影响到电池的使用寿命。</li></ul><p>通常情况下，发生这种情况的原因是线程与线程之间的通信(比如使用<code>performSelector:onThread:</code>或<code>dispatch_async</code>)，它们的通信频率远远超出了它们应该有的通信频率，当发生类似情况时，有很多个后台线程都有相同的线程回溯，都指向了调用源。</p><h5 id="其他异常类型"><a href="#其他异常类型" class="headerlink" title="其他异常类型"></a>其他异常类型</h5><p>有一些崩溃报告中，会出现一个未命名的<code>Exception Type</code>,这类型异常会以一个十六进制的值表示，对于类似情况，直接可以从<code>Exception Code</code>中读取该值</p><ul><li>0xbaaaaaad 该code不是崩溃信息，它表示该log为整个系统的堆栈快照</li><li>0xbad22222 表示该进程是一个VoIP进程，因为过于频繁的resume而发生异常崩溃</li><li>0x8badf00d 表示iOS进程因为看门狗超时而崩溃，可能是应用在launch、terminate或响应系统事件时消耗了太多时间而发生的超时，最常见的错误就是在主线程去同步做网络任务而导致的崩溃。</li><li>0xc00010ff indicates the app was killed by the operating system in response to a thermal event. This may be due to an issue with the particular device that this crash occurred on, or the environment it was operated in. For tips on making your app run more efficiently, see <a href="https://developer.apple.com/videos/wwdc/2011/?id=312" target="_blank" rel="noopener">WWDC session</a></li><li>0xdead10cc 表示死锁，锁被占用着，一直没有放弃锁导致其他线程无法拥有锁，总结起来就是死锁。</li><li>0x2bad45ec 表示进程因违反私密信息而被终止</li></ul><p>相关连接：</p><ul><li><p><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="noopener">理解和分析应用崩溃报告</a></p></li><li><p><a href="https://docs.fabric.io/apple/crashlytics/missing-dsyms.html" target="_blank" rel="noopener">dSYM For Fabric</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就普通的开发而言，普通需求的实现，对于大多数有经验的开发者只是时间问题，其实并没有太大的难度，需求的实现过程则相对轻松；&lt;/p&gt;
&lt;p&gt;比较恶心的是发布产品后，遇到的各式奇葩的crash，如果你早有准备，在发布的时候打包了符号文件，那么恭喜你，你还可以通过符号文件来查找崩溃代码，否则，可能就是让bug出现者不停的复现crash，费事费力，可能最终还找不到问题。&lt;/p&gt;
&lt;p&gt;符号文件可以通过一定规则将内存地址转换为可读的函数名和一些代码的行号，当你通过Xcode窗口产生的crash时，通常在console中看到的结果是已经被符号化的结果。&lt;/p&gt;
&lt;p&gt;一般的崩溃日志都会产生一个线程回溯列表，让你去回溯到指定的crash函数，但是内存警告不会产生线程回溯，官方的解释是低内存发生时不需要线程回溯信息，当发生内存警告时，你必须要重视内存的使用模式并在内存警告发生时的回调函数处理相关的内存泄露。&lt;/p&gt;
&lt;p&gt;本文大多数内容来源于Apple的官方文档，&lt;a href=&quot;https://developer.apple.com/library/archive/technotes/tn2151/_index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地址在这&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博文意在如何收集crash，如何分析crash.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="崩溃日志" scheme="http://kobeluo.com/tags/%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97/"/>
    
      <category term="崩溃解析" scheme="http://kobeluo.com/tags/%E5%B4%A9%E6%BA%83%E8%A7%A3%E6%9E%90/"/>
    
      <category term="crash analysis" scheme="http://kobeluo.com/tags/crash-analysis/"/>
    
      <category term=".dSYM .crash" scheme="http://kobeluo.com/tags/dSYM-crash/"/>
    
  </entry>
  
  <entry>
    <title>mac上建立基于osx fuse的虚拟磁盘</title>
    <link href="http://kobeluo.com/2017/07/24/osxfuse/"/>
    <id>http://kobeluo.com/2017/07/24/osxfuse/</id>
    <published>2017-07-24T12:25:04.000Z</published>
    <updated>2018-11-16T05:45:56.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>苹果文件系统<a href="https://www.google.co.kr/search?q=APFS&amp;oq=APFS&amp;aqs=chrome..69i57j0l5.5335j0j7&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">AFPS</a>允许用户挂载自己的磁盘(Mount disk)，类似<a href="https://www.pcloud.com/zh/" target="_blank" rel="noopener">PCloud</a>；也允许用户通过底层API来监控某个文件夹的变化来做同步，类似<a href="https://www.dropbox.com/" target="_blank" rel="noopener">DropBox</a>，最终目的都是为了实现本地文件与服务端同步来方便人们的工作和生活，博主对于两种方式来同步文件都有一定涉猎，国内外目前针对Mount盘的文献和资料相对较少，博主在工作过程中遇到过很多的坑，共享出来，希望能帮助到有缘人。</p></blockquote><a id="more"></a><h3 id="OSX-FUSE"><a href="#OSX-FUSE" class="headerlink" title="OSX FUSE"></a><a href="https://osxfuse.github.io/" target="_blank" rel="noopener">OSX FUSE</a></h3><hr><h4 id="osxfuse介绍"><a href="#osxfuse介绍" class="headerlink" title="osxfuse介绍"></a>osxfuse介绍</h4><p>关于osx fuse，官方的介绍已经非常详尽了，它主要针对Mac OS文件系统相关的一些操作提供底层的SDK帮助,其主要功能如下:<br><div class="note info"><ol><li>AccessibilityFS </li><li>LoopbackFS   </li><li>SpotlightFS    </li><li>SSHfs</li><li>other functions</li></ol></div></p><ul><li><strong>LoopbackFS</strong> 将Finder中某个文件夹作为一个独立的文件系统挂载起来;</li><li><strong>SpotlightFS</strong>   OS特有的文件系统，连接spotlight使用的，当使用spotlight搜索时，会存储搜索结果;</li><li><strong>SSHfs</strong>  基于SSH的文件系统，用于挂载远程的文件系统。<br>本篇文章将主要介绍使用OSX FUSE来搭建自己的mount盘.</li></ul><h4 id="osxfuse安装"><a href="#osxfuse安装" class="headerlink" title="osxfuse安装"></a>osxfuse安装</h4><p>下载<a href="https://github.com/osxfuse/osxfuse/releases" target="_blank" rel="noopener">osx fuse.dmg</a>，安装后<code>system preferences</code>底部会多一个FUSE item，<img src="/TECH/2017/07/24/osxfuse/fusePanel.png" alt="system preference screenshot"><br>下载<a href="https://github.com/osxfuse/framework" target="_blank" rel="noopener">osxfuse.framwork</a>，使用xcode编译后导入到自己自己工程中。</p><h4 id="osxfuse结构介绍"><a href="#osxfuse结构介绍" class="headerlink" title="osxfuse结构介绍"></a>osxfuse结构介绍</h4><p>这里以<a href="https://github.com/osxfuse/filesystems" target="_blank" rel="noopener">LookbackFS</a>的swift版本为例介绍fuse的基本概念及用法.<br><figure class="highlight swift"><figcaption><span>需要初始化的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> rootPath: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> loopFileSystem: <span class="type">LoopbackFS</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">LoopbackFS</span>(rootPath: <span class="keyword">self</span>.rootPath)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> userFileSystem: <span class="type">GMUserFileSystem</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">GMUserFileSystem</span>(delegate: <span class="keyword">self</span>.loopFileSystem, isThreadSafe: <span class="literal">false</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><ul><li>rootPath 由于LookbackFS是义某个文件夹作为mount的对象，因此rootPath就是本地某个文件夹地址；</li><li>loopFileSystem该参数作为osx回调的代理，用来接收所有从底层过来的消息；</li><li>userFileSystem该参数主要作为启动mount的载体，加载mount需要的各项参数。</li></ul><h4 id="Mount挂载"><a href="#Mount挂载" class="headerlink" title="Mount挂载"></a>Mount挂载</h4><figure class="highlight swift"><figcaption><span>Mount</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.rootPath = rootPath</span><br><span class="line"></span><br><span class="line">addNotifications()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options: [<span class="type">String</span>] = [<span class="string">"native_xattr"</span>, <span class="string">"volname=LoopbackFS"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> volumeIconPath = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"LoopbackFS"</span>,</span><br><span class="line">ofType: <span class="string">"icns"</span>) &#123;</span><br><span class="line"></span><br><span class="line">    options.insert(<span class="string">"volicon=<span class="subst">\(volumeIconPath)</span>"</span>, at: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">userFileSystem.mount(atPath: <span class="string">"/Volumes/loop"</span>, withOptions: options)</span><br></pre></td></tr></table></figure><p>该片段代码展示了mount 过程的细节，其中<a href="https://github.com/osxfuse/osxfuse/wiki/Mount-options" target="_blank" rel="noopener">options</a>是OSX FUSE指定的某些特定参数，用以实现不同的mount盘功能。<br>而<code>/Volumes/loop</code>则是在macbook上挂载的mount盘的地址,如下图:</p><p><img src="/TECH/2017/07/24/osxfuse/mountinfo.png" alt="mount disk info"><br>图中可以看出，mount盘在Macintosh中的地址是<code>/Volumes/loop</code>,而显示的名字是<code>LoopbackFS</code>。<br><img src="/TECH/2017/07/24/osxfuse/path.png" alt="mount disk info"><br>接下来是注册mount结果的通知<br><figure class="highlight swift"><figcaption><span>Notification</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNotifications</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemDidMount), object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got didMount notification."</span>)</span><br><span class="line">        <span class="comment">//do something.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemMountFailed), object: <span class="literal">nil</span>, queue: .main) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got mountFailed notification."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemDidUnmount), object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got didUnmount notification."</span>)</span><br><span class="line">        <span class="type">NSApplication</span>.shared().terminate(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当mount盘发生状态变更时会调用到该函数中，至此，mount盘就已经挂载到了APFS上。</p><h3 id="Event-Stream"><a href="#Event-Stream" class="headerlink" title="Event Stream"></a>Event Stream</h3><hr><h4 id="mount盘事件原理"><a href="#mount盘事件原理" class="headerlink" title="mount盘事件原理"></a>mount盘事件原理</h4><p>前文提到注册mount盘的过程实例化了一个loopFileSystem，以下简称loopInvoke，它主要用来接收从底层过来的所有的事件信息，loopInvoke实现了所有的GMUserFileSystem的代理方法。前文Mount的过程其实质是osxfuse向APFS注册了事件的回调反馈，用户在Mount盘中的任何行为，都将以flag的形式反馈给osx fuse，osx fuse通过解析这些flag并转化成上层可以读懂的事件反馈到loopInvoke实例，如果需要返回值，则将loopInvoke处理后的返回值返回给APFS。</p><div id="flowchart-0" class="flow-chart"></div><h4 id="loopInvoke事件详解"><a href="#loopInvoke事件详解" class="headerlink" title="loopInvoke事件详解"></a>loopInvoke事件详解</h4><h5 id="回调函数列表"><a href="#回调函数列表" class="headerlink" title="回调函数列表:"></a>回调函数列表:</h5><p>先看一下loopInvoke回调事件函数列表如下:<br><figure class="highlight swift"><figcaption><span>函数列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createDirectory</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:])</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//remove</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeDirectory</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeItem</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//other important</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">moveItem</span><span class="params">(atPath source: String!, toPath destination: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">openFile</span><span class="params">(atPath path: String!, mode: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">releaseFile</span><span class="params">(atPath path: String!, userData: Any!)</span></span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(atPath path: String!, userData: Any!, buffer: UnsafeMutablePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(atPath path: String!, userData: Any!, buffer: UnsafePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">exchangeDataOfItem</span><span class="params">(atPath path1: String!, withItemAtPath path2: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">contentsOfDirectory</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Any</span>]</span><br><span class="line"><span class="comment">//attributes</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">finderAttributes</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">resourceAttributes</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfItem</span><span class="params">(atPath path: String!, userData: Any!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfFileSystem</span><span class="params">(forPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setAttributes</span><span class="params">(<span class="number">_</span> attributes: [AnyHashable : Any]!, ofItemAtPath path: String!, userData: Any!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">extendedAttributesOfItem</span><span class="params">(atPath path: Any!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Any</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(ofExtendedAttribute name: String!, ofItemAtPath path: String!, position: off_t)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setExtendedAttribute</span><span class="params">(<span class="number">_</span> name: String!, ofItemAtPath path: String!, value: Data!, position: off_t, options: Int32)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeExtendedAttribute</span><span class="params">(<span class="number">_</span> name: String!, ofItemAtPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//link </span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">linkItem</span><span class="params">(atPath path: String!, toPath otherPath: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//symbolic link</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createSymbolicLink</span><span class="params">(atPath path: String!, withDestinationPath otherPath: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destinationOfSymbolicLink</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">//pre alloc</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">preallocateFile</span><span class="params">(atPath path: String!, userData: Any!, options: Int32, offset: off_t, length: off_t)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure></p><p>哇！！！乱七八糟一大堆函数回调，实际上仔细归类后发现，基本上涵盖了文件操作的所有细节。</p><div class="note danger"><p><strong>这些细节全部由你来掌控！</strong></p><ul><li>当用户创建一个文件A时，APFS会通过OSX FUSE传递到loopInvoke，告诉你现在收到一个信号是创建了一个A文件，问你怎么办？</li><li>当APFS需要读取A文件的属性时发出信号向你询问A文件的属性应该是怎样的？</li><li>当A文件被更名成B文件时，发出信号告诉你有这个事情，至于是否需要更名成B文件或者抛错，由你来决定！</li></ul></div><h5 id="事件详解"><a href="#事件详解" class="headerlink" title="事件详解"></a>事件详解</h5><p>以create函数为例来分析一下事件的过程。<br><figure class="highlight swift"><figcaption><span>create file event</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> mode = attributes[<span class="type">FileAttributeKey</span>.posixPermissions] <span class="keyword">as</span>? mode_t <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(posixErrorCode: <span class="type">EPERM</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalPath = rootPath.appending(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fileDescriptor = <span class="keyword">open</span>((originalPath <span class="keyword">as</span> <span class="type">NSString</span>).utf8String!, flags, mode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fileDescriptor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(posixErrorCode: errno)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userData.pointee = <span class="type">NSNumber</span>(value: fileDescriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参数解析</strong></p><ul><li>mode 是<a href="http://www.man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener">open2</a>函数的参数，该参数必须指定为<code>O_CREAT</code>或者<code>O_TMPFILE</code>flag，如果不是这两个参数，那么该参数将被忽略。<blockquote><p>以下是官方解释<br>The mode argument specifies the file mode bits be applied when a new file is created.<br>This argument must be supplied when O_CREAT or O_TMPFILE is specified in flags;<br>if neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</p></blockquote></li><li>originalPath 是指实际文件系统中文件的路劲</li><li>flags 用于指定文件创建时的打开方式的集合，官方的解释如下:<blockquote><p>以下是官方解释<br>The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.<br>These request opening the file read-only, write-only, or read/write, respectively.<br>In addition, zero or more file creation flags and file status flags can be bitwise-or’d in flags.<br>The file creation flags are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC.</p></blockquote></li><li>fileDescription 是指文件句柄，该文件句柄用于文件操作过程中的唯一标志符。</li><li>userData是一个指针，用来存储文件操作过程中用户定义的数据，该字段在实际项目中作用很大。<div class="note danger"><p><strong>总结:</strong></p><p>通过解析create函数，可以看出，APFS将所有的事件都会发送到loopInvoke，至于怎么处理事件，由开发者自己来决定！<br>也正因为如此，Mount开发需要谨慎对待，处理不善，可能就无法正常运转Mount盘。</p></div></li></ul><p><a href="http://blog.sina.com.cn/s/blog_8b94e9b40100w49w.html" target="_blank" rel="noopener">博客收录入口</a></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Starte=>end: Endevt=>operation: User Operationop1=>operation: APFS op2=>operation: Fuse parse and generateop3=>operation: loopInvoke handle eventcond=>condition: has return value?st->evt->op1->op2->op3(right)->condcond(yes,top)->op1cond(no,bottom)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;苹果文件系统&lt;a href=&quot;https://www.google.co.kr/search?q=APFS&amp;amp;oq=APFS&amp;amp;aqs=chrome..69i57j0l5.5335j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AFPS&lt;/a&gt;允许用户挂载自己的磁盘(Mount disk)，类似&lt;a href=&quot;https://www.pcloud.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCloud&lt;/a&gt;；也允许用户通过底层API来监控某个文件夹的变化来做同步，类似&lt;a href=&quot;https://www.dropbox.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DropBox&lt;/a&gt;，最终目的都是为了实现本地文件与服务端同步来方便人们的工作和生活，博主对于两种方式来同步文件都有一定涉猎，国内外目前针对Mount盘的文献和资料相对较少，博主在工作过程中遇到过很多的坑，共享出来，希望能帮助到有缘人。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="FUSE" scheme="http://kobeluo.com/tags/FUSE/"/>
    
      <category term="Mount Disk" scheme="http://kobeluo.com/tags/Mount-Disk/"/>
    
      <category term="LookbackFS" scheme="http://kobeluo.com/tags/LookbackFS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用笔记</title>
    <link href="http://kobeluo.com/2017/04/07/Hexo-useage-note/"/>
    <id>http://kobeluo.com/2017/04/07/Hexo-useage-note/</id>
    <published>2017-04-07T13:20:19.000Z</published>
    <updated>2018-12-03T10:05:13.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>博主使用过博客站点有简书、CSDN、博客园、都不同程度的遇到了各种不顺心，MarkDown使用起来也不是特别方便，决定使用GitPages+Hexo来实现编写博客，在完成完成Hexo配置的过程中，踩了不少坑，决定记录下来供大家参考。</p><p>个人博客站点:<a href="https://kobeluo.github.io/TECH/" target="_blank" rel="noopener">KobeLuo的博客</a></p></blockquote><a id="more"></a><h3 id="有关Github仓库"><a href="#有关Github仓库" class="headerlink" title="有关Github仓库"></a>有关<a href="https://github.com/" target="_blank" rel="noopener">Github</a>仓库</h3><hr><h4 id="创建一个Github账号，添加一个Repository"><a href="#创建一个Github账号，添加一个Repository" class="headerlink" title="创建一个Github账号，添加一个Repository"></a>创建一个Github账号，添加一个Repository</h4><div class="note danger"><p><strong>注意： 如果想要使用username.github.io这种方式访问你的博客站点，<br>Repository的名字一定要与用户名username相同</strong>(username/username.github.io)<br>仓库名创建之后一定像这样:KobeLuo/KobeLuo.github.io      </p></div><p>博主曾经在这里踩过坑，导致博客站点报404，一直无法访问</p><h4 id="git分支与关系"><a href="#git分支与关系" class="headerlink" title="git分支与关系"></a><a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="noopener">git分支与关系</a></h4><p>首先理解一个原理:<br><div class="note info"><p>github仓库下至少需要两个分支,这里我们假设为branch1和branch2，<br>如果branch1作为最后静态页面的发布分支，那么branch2就可以作为平时创作的源代码托管分支.<br>branch1不需要你通过git命令push代码，需要通过使用<code>hexo d</code>命令发布到该分支上，前提是本地_config.yml文件已经配置正确，关于本地配置后面会提到<br>branch2是平时写博客过程中，需要使用git命令push源代码的分支,当然你也可以创建更多的源代码托管分支。</p></div></p><p>通常情况下建的博客站点都是在username.github.io这一层，GitPages会默认master作为hexo的发布分支(上面提到的branch1)，此时settings-&gt;Gitpages-&gt;Source下的branch是不可选择的，在这种情况下，开发分支就必须要使用其它的分支(比如develop分支或其他分支)来存储Hexo主题下的源代码。</p><p>如果你的博客站点不是以username.github.io，那么需要按照<a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="noopener"><strong>git发布配置规范</strong></a>配置站点，此时settings-&gt;GitPages-&gt;Source可以选择，通常情况下会有master、gh-pages和/docs供你选择，选择好静态页面的发布分支后,再考虑源代码托管到哪个分支上面。</p><p><span id="jump"> </span></p><h4 id="关于SSHKey"><a href="#关于SSHKey" class="headerlink" title="关于SSHKey"></a>关于SSHKey</h4><p>首先进入用户目录下的.ssh目录<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>使用ssh keygen生成一个SSHKey,需要提供一个邮箱<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your@email.address"</span></span><br></pre></td></tr></table></figure></p><p>Enter file in which to save the key (/Users/name/.ssh/id_rsa):<strong><code>在此输入id_rsa的名字:id_rsa_name</code></strong><br>例如:id_rsa_person or id_rsa_company,如果只需要管理一个SSHKey,直接回车会默认生成id_rsa为名的SSHKey<br>配置了名字，后面一路回车<br>结束后，.ssh文件夹里边会包括id_rsa_name、id_rsa_name.pub两个文件，复制id_rsa_pub的内容拷贝到github设置的SSHKey选项中即可完成配置。</p><h4 id="多账号管理"><a href="#多账号管理" class="headerlink" title="多账号管理:"></a>多账号管理:</h4><p>如果你有多个Github账号，由于Github账号SSHKey的唯一性，就必须生成多个SSHKey，多个SSHKey只要生成的时候指定的名字不一样即可，假设你生成了两个rsa名为id_rsa_name1和id_rsa_name2,<br>那么你需要在.ssh目录里边创建一个名为<code>config</code>的文件，里边的配置信息如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host kobe_old <span class="comment">//所有使用id_rsa_kobe_old.pub作为公钥的github链接中的github.com需要换成kobe_old</span></span><br><span class="line">HostName github.com</span><br><span class="line">Usergit</span><br><span class="line">IdentityFile~/.ssh/id_rsa_kobe_old</span><br><span class="line"></span><br><span class="line">Host kobe_new <span class="comment">//所有使用id_rsa_kobe_new.pub作为公钥的github链接中的github.com需要换成kobe_new</span></span><br><span class="line">HostName github.com</span><br><span class="line">Usergit</span><br><span class="line">IdentityFile~/.ssh/id_rsa_kobe_new </span><br></pre></td></tr></table></figure><div class="note info"><p>从远程clone一个仓库时，例如<a href="https://github.com:KobeLuo/Kobeluo.github.io/" target="_blank" rel="noopener">https://github.com:KobeLuo/Kobeluo.github.io/</a><br>当有多个SSHKey时，<code>需要将github.io改成kobe_new</code>如果该账号使用kobe_new对应的SSHKey<br>更改后的远程地址是<a href="https://kobe_new:KobeLuo/Kobeluo.github.io/" target="_blank" rel="noopener">https://kobe_new:KobeLuo/Kobeluo.github.io/</a></p></div><p>最后使用<code>ssh-add</code>命令将你生成的rsa加入到keychain中,有时候push代码时会报Permission Error,如果你rsa配置正常，也需要执行一下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -K ~/.ssh/id_rsa_your_name</span><br></pre></td></tr></table></figure></p><h4 id="绑定你的独立域名"><a href="#绑定你的独立域名" class="headerlink" title="绑定你的独立域名"></a>绑定你的独立域名</h4><p>Github提供gitpages服务可以生成独立二级域名，如非必要，你大可不必自己购买独立域名，如果你购买了自己的域名，就按照以下步骤做:</p><ul><li><p>在静态页面托管分支创建一个CNAME文件，里边放你的独立域名，我的域名是kobeluo.com,因此CNAME中存放的就是kobeluo.com,如果你使用的是hexo模板，每次执行hexo g之后CNAME文件都将被清理掉，<strong>解决办法是把CNAME文件存放在本地hexo根目录下的source文件目录中，这样每次hexo d都会生成到发布静态网页分支</strong></p></li><li><p>配置DNS,在你的DNS配置域名解析页面中配置三组记录他们分别是:<br>我这里使用的是<a href="https://www.dnspod.cn" target="_blank" rel="noopener"><strong>DNSPod</strong></a>,关于如何使用DNSPod请自行查阅。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机记录记录类型记录值</span><br><span class="line">@A<span class="number">192.30</span><span class="number">.252</span><span class="number">.153</span></span><br><span class="line">@A<span class="number">192.30</span><span class="number">.252</span><span class="number">.154</span></span><br><span class="line">www<span class="built_in">CNAME</span>your.blog.address(我这里是:KobeLuo.github.io)</span><br></pre></td></tr></table></figure><p>配置完成之后，等10分钟，等待域名生效。</p><h3 id="关于Hexo主题模板"><a href="#关于Hexo主题模板" class="headerlink" title="关于Hexo主题模板"></a>关于<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Hexo主题</a>模板</h3><hr><h4 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h4><p>请自行查阅<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方安装教程</a></p><h4 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h4><p>hexo有自己独立的一套命令</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"article"</span></span><br><span class="line"><span class="comment">//创建一篇新文章</span></span><br><span class="line">hexo new page <span class="string">"foldername"</span></span><br><span class="line"><span class="comment">//创建一个新页面</span></span><br><span class="line">hexo g  (hexo generate)</span><br><span class="line"><span class="comment">//生成静态页面</span></span><br><span class="line">hexo s  (hexo server) ,如果报错就执行代码 </span><br><span class="line"><span class="comment">//链接本地服务器</span></span><br><span class="line">hexo d  (hexo deploy)</span><br><span class="line"><span class="comment">//发布到指定服务器</span></span><br><span class="line">hexo clean <span class="comment">//清理静态页面站点，博主使用过一次，会把git配置和hexo搞乱，慎用。</span></span><br><span class="line"></span><br><span class="line">npm install --save hexo-filter-flowchart </span><br><span class="line"><span class="comment">//画流程图的[插件](https://github.com/bubkoo/hexo-filter-flowchart)</span></span><br></pre></td></tr></table></figure><p>执行hexo s可能会报错，如果报错则执行以下命令：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo站点配置"><a href="#hexo站点配置" class="headerlink" title="hexo站点配置"></a>hexo站点配置</h4><p>hexo根目录下的<code>_config.yml</code>就是站点配置文件，使用编辑软件打开,搜索<code>deploy:</code>,<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: your.blog.site(like:xxx.github.io)</span><br><span class="line">branch: gh-pages or master or docs</span><br></pre></td></tr></table></figure></p><div class="note info"><p>填写_config.yml配置文件里边的值前都需要添加一个空格，<br>例如 <code>type: git</code> 注意中间有一个空格</p></div><p>配置好这一项后，使用<code>Hexo d</code>就可以把代码deploy到远程仓库了<br><div class="note warnning"><p>如果你的Github站点不是以github.io结束的，需要配置<code>root:</code>字段，例如，我的技术博客地址是kobeluo.github.io/TECH/ , 那么root:配置就是 <strong><code>/TECH/</code></strong>,否则github无法连接CSS和JS</p></div></p><h3 id="2018-10-12日更新"><a href="#2018-10-12日更新" class="headerlink" title=" 2018.10.12日更新"></a><center> 2018.10.12日更新</center></h3><hr><p>由于自己懒惰，博客已经停更一年多了，近日再次捡起博客，发现Hexo已经有一些变化，记载于此。<br>首先hexo不再像以前一样安装之后就可以直接使用, <a href="http://coderunthings.com/2017/08/20/howhexoworks/" target="_blank" rel="noopener">hexo是怎么工作的</a>,这篇文章说得非常清楚了。</p><h4 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h4><p>hexo分为三个分支：</p><ul><li>HEXO<ol><li>hexo-cli</li><li>hexo (hexo-core)</li><li>hexo plugins</li></ol></li></ul><p>使用命令<code>npm install -g hexo-cli</code> 后可以使用命令<br><code>hexo generate (hexo g) 和 hexo new</code>但是无法使用<code>hexo s 和hexo d</code>,<br>此时需要使用npm安装启动本地服务和发布的插件,命令是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>安装好插件后,应该就可以使用<code>hexo s</code>了，此时启动本地服务,网页可能弹出Can not GET /XX/XX目录,此时你需要执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>再次执行hexo s,本地网页应该就可以正常显示了.</p><p>假设你已经安装好了<a href="https://treehouse.github.io/installation-guides/mac/node-mac.html" target="_blank" rel="noopener">npm</a>,这里针对已有的博客,需要再次编辑博客的一个完整流程:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:xxxxxxx /A/B/C  将仓库clone到你本地/A/B/C的位置</span><br><span class="line">npm install -g hexo-cli 安装hexo</span><br><span class="line">npm install  </span><br><span class="line">npm install hexo-server --save 安装hexo s</span><br><span class="line">npm install hexo-deployer-git --save 安装 hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>如果你本地有多个github账号，因此而产生的权限问题，请左转<a href="#多账号管理">ssh key</a><br>hexo d实质是将你本地public文件夹的内容push到博客<code>_config.yml</code>所指定的分支上去,如果<code>hexo d</code>报权限错误，<br>请一定检查</p><pre><code class="ruby"><span class="symbol">deploy:</span><span class="symbol">type:</span> git<span class="symbol">repo:</span> git@github.<span class="symbol">com:</span>KobeLuo/TECH.git<span class="symbol">branch:</span> gh-pages</code></pre><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><hr><p>下面是一些记录的hexo站点:</p><p>官方站点</p><ul><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><p>hexo建站教程</p><ul><li><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30836436</a></li><li><a href="http://www.jianshu.com/p/ab21abc31153" target="_blank" rel="noopener">http://www.jianshu.com/p/ab21abc31153</a>    </li><li><a href="http://www.jianshu.com/p/35e197cb1273" target="_blank" rel="noopener">http://www.jianshu.com/p/35e197cb1273</a>     </li><li><a href="https://www.jianshu.com/p/35e197cb1273" target="_blank" rel="noopener">https://www.jianshu.com/p/35e197cb1273</a></li></ul><p>hexo 用法教程</p><ul><li><a href="https://www.jianshu.com/p/9a56f7c13a79" target="_blank" rel="noopener">https://www.jianshu.com/p/9a56f7c13a79</a>     </li></ul><div class="note info"><p><strong>特别鸣谢:</strong><br>建站过程中，<a href="http://liuhongjiang.github.io/hexotech/" target="_blank" rel="noopener"><strong>Andrew Liu</strong></a>提供了非常多的帮助，再次感谢！.</p></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;博主使用过博客站点有简书、CSDN、博客园、都不同程度的遇到了各种不顺心，MarkDown使用起来也不是特别方便，决定使用GitPages+Hexo来实现编写博客，在完成完成Hexo配置的过程中，踩了不少坑，决定记录下来供大家参考。&lt;/p&gt;
&lt;p&gt;个人博客站点:&lt;a href=&quot;https://kobeluo.github.io/TECH/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KobeLuo的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://kobeluo.com/categories/Hexo/"/>
    
    
      <category term="hexo使用" scheme="http://kobeluo.com/tags/hexo%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>GCD系列:信号量(dispatch_semaphore)</title>
    <link href="http://kobeluo.com/2017/03/28/dispatch-semaphore/"/>
    <id>http://kobeluo.com/2017/03/28/dispatch-semaphore/</id>
    <published>2017-03-28T12:44:35.000Z</published>
    <updated>2018-11-16T05:44:06.495Z</updated>
    
    <content type="html"><![CDATA[<p>信号量有点像具备N个task并行能力的channel,当channel的并行能力未达到上限时可以任意往里边加task，当达到channel上限时，需要task完成才可以加入新的task.<br><a id="more"></a></p><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_semaphore_t</span><br><span class="line">dispatch_semaphore_create(<span class="keyword">long</span> value);</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t sema, dispatch_time_t timeout);</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.申明一个信号量:dispatch_semaphore_t dsema;<br>2.创建一个具有n个并行能力的semaphore:dsema = dispatch_semaphore_create(2); 这里创建一个具备2个并行能力的信号量dsema.<br>3.消耗1个并行能力,例子中当重复调用2次此函数，代码将造成阻塞,阻塞的时间是timeout，实际开发中，可以创建一dispatch_time_t实例，也可使用DISPATCH_TIME_FOREVER,将永远等待知道发送一个signal为止.因此,如果不能确定一定会发送signal，慎用DISPATCH_TIME_FOREVER.<br>4.发送1个signal.</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><hr><ol><li>当前线程执行代码等待其它线程代码执行结束   </li><li>控制异步task并发数量</li></ol><ul><li>实例1: 当前Thread同步执行等待其他Thread返回结果：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> normalizedSemaphore() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread begin..."</span>);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSUInteger</span> index = <span class="number">0</span> ; index &lt; <span class="number">3</span> ; index ++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"other thread message:%lu"</span>,index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread continue..."</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中，创建了一个同时允许并发为1的semaphore,当执行到current thread continue…这条log时,执行被卡住了，等待异步代码块调用dispatch_semaphore_signal(semaphore)继续往下执行.<br>输出结果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392620</span> Semaphore[<span class="number">61812</span>:<span class="number">11351508</span>] current thread begin...</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392751</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392772</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392784</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392848</span> Semaphore[<span class="number">61812</span>:<span class="number">11351508</span>] current thread <span class="keyword">continue</span>...</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实例2：控制异步并发数量</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)managerAsynTaskDemo &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *tasks = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span> ; index &lt; <span class="number">10</span>; index ++) &#123;</span><br><span class="line"></span><br><span class="line">[tasks addObject:@(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">[tasks enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> logTaskIndex:[obj unsignedIntegerValue]];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t _dsema;</span><br><span class="line"><span class="keyword">void</span> (^logTaskIndexHandle)(<span class="built_in">NSUInteger</span>) = ^(<span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"task index:%lu"</span>,index);</span><br><span class="line">&#125;;</span><br><span class="line">-(<span class="keyword">void</span>)logTaskIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dsema) _dsema = dispatch_semaphore_create(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">logTaskIndexHandle(index);</span><br><span class="line">dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_semaphore_signal(_dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们产生了10个异步的task,创建了一个并发量为5的信号量dsema,并且在很短的时间内都异步调用logTaskIndex方法,</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579778</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579822</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579838</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579850</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579862</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">02.580413</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">03.585241</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">04.589975</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">05.592348</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">06.596368</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>通过日志看到,前5个任务完成时间间隔非常短，从index=5的task开始每隔1秒钟执行一个task。是因为，打印日志的时候，并没有调用dispatch_semaphore_signal(semaphore);函数，所以只能等待超时时间1秒.<br>如果这里的超时时间设置成了DISPATCH_TIME_FOREVER，请思考一下，最终的打印结果是什么呢？</p><hr><p><strong>推荐一个封装的semaphore函数:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_semaphore_async_handle(dispatch_semaphore_t dsema,dispatch_time_t timeout, <span class="keyword">void</span> (^block)(dispatch_semaphore_t dsema)) &#123;</span><br><span class="line"></span><br><span class="line">dsema = dsema ?: dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">timeout = timeout ?: DISPATCH_TIME_FOREVER;</span><br><span class="line">dispatch_semaphore_wait(dsema, timeout);</span><br><span class="line">block(dsema);</span><br><span class="line">dispatch_semaphore_wait(dsema, timeout);</span><br><span class="line">dispatch_semaphore_signal(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方法如下:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_async_handle(<span class="literal">nil</span>, <span class="number">0</span>, ^(dispatch_semaphore_t dsema)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        some code...</span></span><br><span class="line">dispatch_semaphore_signal(dsema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>推荐一篇不错的GCD文章  <a href="http://www.cocoachina.com/ios/20160225/15422.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160225/15422.html</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号量有点像具备N个task并行能力的channel,当channel的并行能力未达到上限时可以任意往里边加task，当达到channel上限时，需要task完成才可以加入新的task.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="GCD" scheme="http://kobeluo.com/tags/GCD/"/>
    
      <category term="dispatch_semaphore" scheme="http://kobeluo.com/tags/dispatch-semaphore/"/>
    
      <category term="信号量" scheme="http://kobeluo.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>GCD系列:代码块(dispatch_block)</title>
    <link href="http://kobeluo.com/2017/03/27/dispatch-block/"/>
    <id>http://kobeluo.com/2017/03/27/dispatch-block/</id>
    <published>2017-03-27T12:25:04.000Z</published>
    <updated>2018-11-16T05:44:14.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dispatch-block"><a href="#dispatch-block" class="headerlink" title="dispatch_block"></a>dispatch_block</h3><p>dispatch_block系列函数可以对一段代码进行准确控制，最显著的功能就是可以取消执行的代码块，在实际项目开发中非常有用。<br><a id="more"></a></p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_perform(dispatch_block_flags_t flags,DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_cancel(dispatch_block_t block);</span><br><span class="line"><span class="keyword">long</span> dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_notify(dispatch_block_t block, <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">dispatch_block_t notification_block);</span><br><span class="line"><span class="keyword">long</span> dispatch_block_testcancel(dispatch_block_t block);</span><br></pre></td></tr></table></figure><h3 id="函数理解"><a href="#函数理解" class="headerlink" title="函数理解"></a>函数理解</h3><hr><p>1.使用dispatch_create创建一个基于GCD的代码块,参数flag，指定代码块的执行环境，block是代码执行体。</p><p><strong>关于flag的定义</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ENUM_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)</span><br><span class="line">DISPATCH_ENUM(dispatch_block_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">DISPATCH_BLOCK_BARRIER = <span class="number">0x01</span>,</span><br><span class="line">DISPATCH_BLOCK_DETACHED = <span class="number">0x02</span>,</span><br><span class="line">DISPATCH_BLOCK_ASSIGN_CURRENT = <span class="number">0x04</span>,</span><br><span class="line">DISPATCH_BLOCK_NO_QOS_CLASS = <span class="number">0x08</span>,</span><br><span class="line">DISPATCH_BLOCK_INHERIT_QOS_CLASS = <span class="number">0x10</span>,</span><br><span class="line">DISPATCH_BLOCK_ENFORCE_QOS_CLASS = <span class="number">0x20</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><ul><li>DISPATCH_BLOCK_BARRIER 保证代码块用于原子性，代码块的代码未执行结束前，下一次调用将进入一个FIFO的等待队列，等待本次代码块执行结束，使用较为安全,若不考虑线程安全可使用DISPATCH_BLOCK_DETACHED，其它flag自行查阅文档。</li></ul><p>2.dispatch_block_perform 没有实际使用过，可能是在当前线程中将闭包的执行体放在指定的flag环境中去执行（待认证）.</p><p>3.dispatch_block_cancel 取消执行某个block，只有当block还未执行前执行cancel有效，block正在执行无法取消.<br>4.dispatch_block_wait 等待block执行，直到timeout后继续往下执行代码,如果timeout=DISPATCH_TIME_FOREVER且block永远不被执行，代码将永远等待。<br>5.dispatch_block_notify(block1,queue,notification_block);注册一个block1的监听，当block1已经完成的时候，会在queue里立即执行notification_block.</p><h3 id="简要Demo："><a href="#简要Demo：" class="headerlink" title="简要Demo："></a>简要Demo：</h3><hr><p><strong>Demo1.简单用法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_index &lt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">executingBlockOrCancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362374</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362444</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362471</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362491</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362511</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Demo2.当block在延时函数中使用</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> delayExecutingTask() &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, <span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>), dispatch_get_main_queue(), _dblock);</span><br><span class="line"><span class="comment">//sometimes ,you need cancel the block,use dispatch_block_cancel </span></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Demo3.dispatch_block_waite</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">executingBlockOrCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"wait BEGIN "</span>);</span><br><span class="line">dispatch_block_wait(_dblock, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"wait END "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">27.484894</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] wait BEGIN </span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">29.485858</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] wait END </span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">34.487206</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] index -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>demo中，在函数createBlockIfNeeded函数中，输出waite BEGIN之后，dispatch_block_waite函数将等待两秒，再输出waite END,之后才执行函数executingBlockOrCancel();</p><p><strong>Demo4.dispatch_block_notify</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BEGIN"</span>);</span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">_dblock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_notify(_dblock, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BLOCK EXECUT COMPLETED"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">30.105075</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] BEGIN</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">35.106363</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] index -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">35.122696</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] BLOCK EXECUT COMPLETED</span><br></pre></td></tr></table></figure><div class="note info"><p>目前，使用了一些Dispatch_block的基本用法，更复杂的在多线程中的用法会陆续记载。 </p></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;dispatch-block&quot;&gt;&lt;a href=&quot;#dispatch-block&quot; class=&quot;headerlink&quot; title=&quot;dispatch_block&quot;&gt;&lt;/a&gt;dispatch_block&lt;/h3&gt;&lt;p&gt;dispatch_block系列函数可以对一段代码进行准确控制，最显著的功能就是可以取消执行的代码块，在实际项目开发中非常有用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="GCD" scheme="http://kobeluo.com/tags/GCD/"/>
    
      <category term="Dispatch block" scheme="http://kobeluo.com/tags/Dispatch-block/"/>
    
      <category term="dispatch代码块" scheme="http://kobeluo.com/tags/dispatch%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>GCD系列:队列(dispatch_queue)</title>
    <link href="http://kobeluo.com/2017/03/20/dispatch_queue/"/>
    <id>http://kobeluo.com/2017/03/20/dispatch_queue/</id>
    <published>2017-03-20T03:44:22.000Z</published>
    <updated>2018-11-16T05:43:59.445Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">GCD是基于C封装的函数,具备非常高的效率,<br>在ARC环境下,无须主动管理内存,<br>无须dispatch_retain和dispatch_release,<br>可以将重点关注在业务逻辑上。<br>GCD是基于队列的封装，<strong>下面浅要解析GCD的队列</strong>。<br></blockquote><br><a id="more"></a></p><h3 id="GCD获取线程的方式"><a href="#GCD获取线程的方式" class="headerlink" title="GCD获取线程的方式"></a>GCD获取线程的方式</h3><hr><p>下面是Apple官方提供的获取线程相关函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//获取一个异步线程队列，queue用于指定block执行体所在的队列</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable contex,dispatch_function_t work); </span><br><span class="line"><span class="comment">//跟dispatch_sync类似，只不过接收的是一个dispatch_function_t的函数。</span></span><br><span class="line">- <span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block); </span><br><span class="line"><span class="comment">//获取一个异步线程，接收一个闭包block.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//获取一个异步线程,接收一个函数指针.</span></span><br></pre></td></tr></table></figure><h3 id="GCD获取队列的方式"><a href="#GCD获取队列的方式" class="headerlink" title="GCD获取队列的方式"></a>GCD获取队列的方式</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(); </span><br><span class="line"><span class="comment">//获取主队列</span></span><br><span class="line">- <span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">long</span> identifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags); </span><br><span class="line"><span class="comment">//获取全局队列,由系统分配,分配完成后不可更改,flags是预留字段，传递任何非0值将返回一个NULL值引发异常，identifier指定全局队列的级别，队列的级别如下:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure><ul><li>推荐使用基于QOS_CLASS的属性级别.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QOS_CLASS_USER_INTERACTIVE  </span><br><span class="line"><span class="comment">//最高优先级,用于UI更新等与用户交互的操作.</span></span><br><span class="line">QOS_CLASS_USER_INITIATED        </span><br><span class="line"><span class="comment">//初始化优先级，用于初始化等，等同于DISPATCH_QUEUE_PRIORITY_HIGH</span></span><br><span class="line">QOS_CLASS_DEFAULT                   </span><br><span class="line"><span class="comment">//默认优先级，等同于DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">QOS_CLASS_UTILITY                     </span><br><span class="line"><span class="comment">//低优先级，等同于DISPATCH_QUEUE_PRIORITY_LOW</span></span><br><span class="line">QOS_CLASS_BACKGROUND         </span><br><span class="line"><span class="comment">//后台级,用户用户无法感知的一些数据处理，等同于DISPATCH_QUEUE_PRIORITY_BACKGROUND</span></span><br></pre></td></tr></table></figure><ul><li>自己创建的队列</li></ul><p>GCD中使用<code>dispatch_queue_t dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);</code>来创建一个队列，其中label表示该队列的唯一标识字符串，使用<code>const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);</code>来获取该字符串,参数attr指定队列的执行顺序，有以下参数:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_SERIAL        </span><br><span class="line"><span class="comment">//指定串行（FIFO）队列,等同于传入参数NULL</span></span><br><span class="line">DISPATCH_QUEUE_CONCURRENT    </span><br><span class="line"><span class="comment">//指定并发队列,</span></span><br><span class="line">dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t _Nullable attr,dispatch_qos_class_t qos_class, <span class="keyword">int</span> relative_priority);</span><br><span class="line"><span class="comment">//产生一个基于QOS_CLASS的队列.</span></span><br></pre></td></tr></table></figure><h4 id="dispatch-apply应用"><a href="#dispatch-apply应用" class="headerlink" title="dispatch_apply应用"></a>dispatch_apply应用</h4><hr><p>dispatch_apply必须要结合dispatch_async 或者dispatch_async_f函数一起使用,如果脱离了dispatch_async函数,程序很容易crash，需要特别关注.<br>在指定的queue中去直接执行dispatch_apply(count,queue,block);会直接引发crash!</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue,DISPATCH_NOESCAPE <span class="keyword">void</span> (^block)(size_t));</span><br></pre></td></tr></table></figure><p>应用一个block,循环执行block代码块的次数是iterations次，每次执行的index通过size_t参数传递到block代码块内部<br><em>queue</em>:指定apply函数接收的闭包block执行对应的队列方式,如果是串行队列,跟for循环功能一致，无法达到优化性能的目的。<br>如果是并行队列,则重复执行block的顺序不定,以达到优化性能的目的，下面是2个简单的例子:</p><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatchApply() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义</span></span><br><span class="line"><span class="comment">//Dispatch_apply函数主要的功能是提高性能.</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index....%lu"</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ddddd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:  <strong>可以看出，是并行执行的，达到了apply优化性能的目的.</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856182</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856182</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856205</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130337</span>] index...<span class="number">.1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856240</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856251</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856208</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130335</span>] index...<span class="number">.3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856272</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856278</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856280</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130337</span>] index...<span class="number">.7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856293</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130335</span>] index...<span class="number">.9</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856327</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] ddddd</span><br></pre></td></tr></table></figure></p><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatchApplySerial() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义</span></span><br><span class="line"><span class="comment">//Dispatch_apply函数主要的功能是提高性能.</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index....%lu"</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ddddd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472788</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472830</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472842</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472851</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472860</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472868</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472877</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472885</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472893</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472902</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.9</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472931</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128223</span>] ddddddddd</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_apply_f(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,<span class="keyword">void</span> (*work)(<span class="keyword">void</span> *_Nullable, size_t));</span><br></pre></td></tr></table></figure><p>跟dispatch_apply功能一致,方法接收一个函数指针.</p><h3 id="void-dispatch-set-target-queue-dispatch-object-t-object-dispatch-queue-t-Nullable-queue"><a href="#void-dispatch-set-target-queue-dispatch-object-t-object-dispatch-queue-t-Nullable-queue" class="headerlink" title="void dispatch_set_target_queue(dispatch_object_t object,dispatch_queue_t _Nullable queue);"></a>void dispatch_set_target_queue(dispatch_object_t object,dispatch_queue_t _Nullable queue);</h3><hr><p>dispatch_set_target_queue可以将object指向的dispatch_object_t对象的队列方式按照参数2的queue的队列方式去执行，它的一大功能就是可以把并发的函数变为串行执行,下面是例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setTargetQueue() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue = dispatch_queue_create(<span class="string">"this.is.serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _concurrcyQueue = dispatch_queue_create(<span class="string">"this.is.concurrency.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">//dispatch_set_target_queue(_concurrcyQueue,_serialQueue);</span></span><br><span class="line"><span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index ++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(_concurrcyQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"11111111111"</span>); &#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(_concurrcyQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"22222222222"</span>); &#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"3333333333"</span>); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果如下：</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853347</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853346</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853367</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853375</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853437</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853475</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853482</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853499</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853507</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853519</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853529</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853538</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853546</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853557</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853585</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出，执行结果很混乱，属于并发执行,现在打开set_target_queue注释,得到以下结果:</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510355</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510405</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510423</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510438</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510452</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510465</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510477</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510491</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510501</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510512</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510524</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510536</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510548</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510560</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510575</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line">这就是典型的dispatch_set_target并发变FIFO串行执行功能.</span><br></pre></td></tr></table></figure></p><h3 id="延时函数-dispatch-after"><a href="#延时函数-dispatch-after" class="headerlink" title="延时函数 dispatch_after"></a>延时函数 dispatch_after</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_after(dispatch_time_t when,<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><ol><li>参数1 when指定block执行的时间，</li><li>参数2 queue指定block执行的队列形式，</li><li>参数3 block指定延时函数接收的闭包.</li></ol><ul><li>void dispatch_after_f(dispatch_time_t when,dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);<br>1.跟dispatch_after功能一样.<br>2.参数3 work指定延时函数接收一个函数指针.</li></ul><h3 id="原子性操作-Dispatch-barrier"><a href="#原子性操作-Dispatch-barrier" class="headerlink" title="原子性操作 Dispatch_barrier"></a>原子性操作 Dispatch_barrier</h3><hr><p>dispatch_barrier在多线程编程中用来保证某个值域的原子性。在多线程操作中，同时对于同一个值的读取不会有问题，但如果同时对一个值进行修改就会产生冲突，此时dispatch_barrier可以很好的解决这个问题，dispatch_barrier就像一个盒子，当盒子内的任务没有出来前，盒子外的任务全部维护到一个队列中。<br><strong>相关函数如下:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_barrier_sync(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//将闭包放入同步环境的queue队列中执行.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//将函数放入同步环境中的queue执行</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//将闭包放入异步环境的queue队列中执行.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_async_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//将函数放入异步环境中的queue执行</span></span><br></pre></td></tr></table></figure></p><p><strong>事例代码如下：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *_vars;</span><br><span class="line"><span class="keyword">void</span> setVars(<span class="built_in">NSMutableDictionary</span> *vars) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue = dispatch_queue_create(<span class="string">"this.is.serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_barrier_async(_serialQueue, ^&#123;</span><br><span class="line"></span><br><span class="line">_vars = vars;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为一个队列添加属性和获取属性"><a href="#为一个队列添加属性和获取属性" class="headerlink" title="为一个队列添加属性和获取属性"></a>为一个队列添加属性和获取属性</h3><p>GCD允许给一个队列通过特定的key值关联属性contenxt,有点类似于使用runtime的objc_associated,在类别中给一个类添加属性，用于实际业务需要.<br>当key对应的context发生变化时，会触发C函数destructor.</p><ul><li>void dispatch_queue_set_specific(dispatch_queue_t queue, const void <em>key,void </em>_Nullable context, dispatch_function_t _Nullable destructor);<br>//通过key,为一个queue设置context</li><li>void <em>_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void </em>key);<br>//通过key,从一个queue读取context</li><li>void <em>_Nullable dispatch_get_specific(const void </em>key);<br>//测试当前队列是否是key对应的queue队列（有待认证。。）<br>示例代码如下:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> destructorInvoke(<span class="keyword">const</span> <span class="keyword">void</span> *string) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"destructor -----&gt;%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithUTF8String:(<span class="keyword">char</span> *)string]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue;</span><br><span class="line"><span class="keyword">void</span> dispatchSpecific() &#123;</span><br><span class="line"></span><br><span class="line">setSpecific(<span class="string">@"1"</span>);</span><br><span class="line">setSpecific(<span class="string">@"2"</span>);</span><br><span class="line">setSpecific(<span class="string">@"3"</span>);</span><br><span class="line">setSpecific(<span class="string">@"4"</span>);</span><br><span class="line">setSpecific(<span class="string">@"5"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> setSpecific(<span class="built_in">NSString</span> *context) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_serialQueue) &#123;</span><br><span class="line"></span><br><span class="line">_serialQueue = dispatch_queue_create(<span class="string">"serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"set one context"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"set string:%@"</span>,context);</span><br><span class="line">dispatch_queue_set_specific(_serialQueue, key, context.UTF8String, &amp;destructorInvoke);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"context is : %@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:dispatch_queue_get_specific(_serialQueue,key)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026095</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026151</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026166</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026194</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026206</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026212</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026225</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026228</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026241</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026298</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026307</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026315</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026335</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026338</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info"><p>PS：<br>dispatch_queue的知识大致如此，水平有限，如有错误之处，请及时指出 </p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;GCD是基于C封装的函数,具备非常高的效率,&lt;br&gt;在ARC环境下,无须主动管理内存,&lt;br&gt;无须dispatch_retain和dispatch_release,&lt;br&gt;可以将重点关注在业务逻辑上。&lt;br&gt;GCD是基于队列的封装，&lt;strong&gt;下面浅要解析GCD的队列&lt;/strong&gt;。&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac Develop" scheme="http://kobeluo.com/categories/Mac-Develop/"/>
    
    
      <category term="GCD" scheme="http://kobeluo.com/tags/GCD/"/>
    
      <category term="Dispatch queue" scheme="http://kobeluo.com/tags/Dispatch-queue/"/>
    
      <category term="队列" scheme="http://kobeluo.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>开发的一些站点记录</title>
    <link href="http://kobeluo.com/2016/11/16/developerSites/"/>
    <id>http://kobeluo.com/2016/11/16/developerSites/</id>
    <published>2016-11-16T06:22:21.000Z</published>
    <updated>2019-01-11T08:00:02.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="About-Debug："><a href="#About-Debug：" class="headerlink" title="About Debug："></a>About Debug：</h3><p><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-SYMBOLICATIONTROUBLESHOOTING" target="_blank" rel="noopener">理解和分析崩溃报告</a><br><a href="https://developer.apple.com/library/archive/qa/qa1669/_index.html" target="_blank" rel="noopener">Objective-C 中提高log的方法</a></p><h3 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h3><p><a href="https://developer.apple.com/videos/wwdc2018/" target="_blank" rel="noopener">2018</a></p><h3 id="About-filesystem"><a href="#About-filesystem" class="headerlink" title="About filesystem"></a>About filesystem</h3><p><a href="http://www.westwind.com/reference/OS-X/invisibles.html" target="_blank" rel="noopener">Mac OS X Hidden Files &amp; Directories</a></p><!-- [![DSC-5880.jpg](https://i.postimg.cc/59QjfzcQ/DSC-5880.jpg)](https://i.postimg.cc/m489N38j/DSC-5880.jpg)![123](https://i.postimg.cc/m489N38j/DSC-5880.jpg) --><h3 id="Inter-Process-Communication"><a href="#Inter-Process-Communication" class="headerlink" title="Inter Process Communication"></a>Inter Process Communication</h3><p><a href="http://mirror.informatimago.com/next/developer.apple.com/documentation/MacOSX/Conceptual/SystemOverview/InverEnvironissues/chapter_52_section_4.html" target="_blank" rel="noopener">IPC For Mac</a><br><a href="https://www.objc.io/issues/14-mac/xpc/" target="_blank" rel="noopener">XPC原文</a><br><a href="https://objccn.io/issue-14-4/" target="_blank" rel="noopener">XPC译文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;About-Debug：&quot;&gt;&lt;a href=&quot;#About-Debug：&quot; class=&quot;headerlink&quot; title=&quot;About Debug：&quot;&gt;&lt;/a&gt;About Debug：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.app
      
    
    </summary>
    
      <category term="Tools" scheme="http://kobeluo.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="http://kobeluo.com/2016/07/15/git-useage/"/>
    <id>http://kobeluo.com/2016/07/15/git-useage/</id>
    <published>2016-07-15T11:15:50.000Z</published>
    <updated>2018-11-16T05:40:28.035Z</updated>
    
    <content type="html"><![CDATA[<p>该文记录git常用命令和使用方法，记录的博主平时工作所需的一些基础命令，并不能保证完整性和正确性，一般情况下的git使用基本上是满足的，当然如果您有一些特殊的需求，还是需要多查阅<a href="https://git-scm.com/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">git权威指南</a></p><h2 id="git-help-查看帮助文档"><a href="#git-help-查看帮助文档" class="headerlink" title="git help 查看帮助文档"></a>git help 查看帮助文档</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help <span class="keyword">init</span></span><br><span class="line"><span class="comment">//查看git init 的帮助文档命令，其余的类推</span></span><br></pre></td></tr></table></figure><h2 id="git-init-初始化Git仓库"><a href="#git-init-初始化Git仓库" class="headerlink" title="git init 初始化Git仓库"></a>git init 初始化Git仓库</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><code>Create an empty Git repository or reinitialize an existing one</code><br>命令执行后，在当前目录生成一个.git的隐藏目录，内含git仓库需要的资源。<br><a href="https://git-scm.com/docs/git-init" target="_blank" rel="noopener">更多用法</a></p><a id="more"></a>    <h2 id="git-clone-克隆仓库"><a href="#git-clone-克隆仓库" class="headerlink" title="git clone 克隆仓库"></a>git clone 克隆仓库</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">http:</span>/<span class="regexp">/code.site.you.clone  localpath</span></span><br></pre></td></tr></table></figure><p><code>http://code.site.you.clone</code> 更换成你克隆的地址<br><code>localpath</code> 指定你本地克隆的地址，也可省去，默认是克隆到当前路径下<br><a href="https://git-scm.com/docs/git-clone" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-remote-远程仓库"><a href="#git-remote-远程仓库" class="headerlink" title="git remote 远程仓库"></a>git remote 远程仓库</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git remote</span><br><span class="line"><span class="comment">//显示本地已设置的远程仓库的key</span></span><br><span class="line"></span><br><span class="line">git remote -v </span><br><span class="line"><span class="comment">//查看本地仓库指向的远程仓库地址, `-v` == `--verbose`</span></span><br><span class="line"></span><br><span class="line">git remote <span class="keyword">set</span>-url origin https:<span class="comment">//remote.site.com   </span></span><br><span class="line"><span class="comment">//设置远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote add origin https:<span class="comment">//remote.site1.com</span></span><br><span class="line">git remote add bookmark1 https:<span class="comment">//remote.site2.com</span></span><br><span class="line"><span class="comment">//添加远程仓库地址，注意origin bookmark1在本地是唯一的，多个远程地址bookmark不能重复</span></span><br><span class="line"></span><br><span class="line">git remote <span class="keyword">get</span>-url origin</span><br><span class="line">git remote <span class="keyword">get</span>-url bookmark1</span><br><span class="line"><span class="comment">//获取指定bookmark对应的远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote rename bookmark1 bookmark2</span><br><span class="line"><span class="comment">//更改bookmark名</span></span><br><span class="line"></span><br><span class="line">git remote remove bookmark2</span><br><span class="line"><span class="comment">//通过bookmark删除本地远程仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-remote" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-config-配置"><a href="#git-config-配置" class="headerlink" title="git config 配置"></a>git config 配置</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git config --global</span><br><span class="line"><span class="comment">//使用全局配置文件</span></span><br><span class="line"></span><br><span class="line">git config --system</span><br><span class="line"><span class="comment">//使用系统配置文件</span></span><br><span class="line"></span><br><span class="line">git config --local</span><br><span class="line"><span class="comment">//使用本地仓库的配置文件</span></span><br><span class="line"></span><br><span class="line">git config -f filepath</span><br><span class="line"><span class="comment">//使用指定路径下的配置文件</span></span><br><span class="line"></span><br><span class="line">git config -l </span><br><span class="line"><span class="comment">//列出配置文件信息列表</span></span><br><span class="line"></span><br><span class="line">git config --global/--systme/--local user.name <span class="string">"yourname"</span></span><br><span class="line"><span class="comment">//配置全局/系统/本地仓库的commit时的用户名</span></span><br><span class="line"></span><br><span class="line">git config --global/--systme/--local user.email <span class="string">"youremail"</span></span><br><span class="line"><span class="comment">//配置全局/系统/本地仓库的commit时的邮箱</span></span><br></pre></td></tr></table></figure><p>以上内容熟悉后，本地仓库克隆及commit及push基本已经可以了，<br>关于多账号的sshkey问题，请<a href="http://www.kobev5.com/TECH/2017/04/07/Hexo-useage-note/#jump" target="_blank" rel="noopener">左转</a></p><h2 id="git-branch-分支操作"><a href="#git-branch-分支操作" class="headerlink" title="git branch 分支操作"></a>git branch 分支操作</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br><span class="line">git branch --list</span><br><span class="line"><span class="comment">//显示本地已有的分支</span></span><br><span class="line"></span><br><span class="line">git branch newBranch</span><br><span class="line"><span class="comment">//创建本地newBranch分支，不切换当前分支</span></span><br><span class="line"></span><br><span class="line">git branch -a </span><br><span class="line"><span class="comment">//显示本地和远程已有的分支列表</span></span><br><span class="line"></span><br><span class="line">git branch -d theBranch</span><br><span class="line"><span class="comment">//删除theBranch,有两种情况无法删除.</span></span><br><span class="line"><span class="comment">//1.当前分支就是theBranch,你需要切换到其它分支删除theBranch分支；</span></span><br><span class="line"><span class="comment">//2.theBranch分支的代码没有完全合并，首先你需要把代码合并到其它需要合并的分支。</span></span><br><span class="line"></span><br><span class="line">git branch -<span class="type">D</span> theBranch</span><br><span class="line"><span class="comment">//强行删除theBranch,如果当前分支在theBranch,则删除失败。</span></span><br><span class="line"></span><br><span class="line">git push origin :theBranch</span><br><span class="line"><span class="comment">//删除远程theBranch分支</span></span><br><span class="line"></span><br><span class="line">git branch -m theBranch newBranch</span><br><span class="line"><span class="comment">//将theBranch分支 更名为 newBranch分支，git reflog的所有结果也将同时变更</span></span><br><span class="line"></span><br><span class="line">git branch -<span class="type">M</span> theBranch newBranch</span><br><span class="line"><span class="comment">//官方定义，`move/rename a branch, even if target exists`，个人感觉非常不安全的操作方式.</span></span><br><span class="line"></span><br><span class="line">git branch -v</span><br><span class="line"><span class="comment">//打印当前分支最后一次commit的文件列表</span></span><br><span class="line"></span><br><span class="line">git branch --merged</span><br><span class="line"><span class="comment">//仅打印已经合并过的分支列表</span></span><br><span class="line"></span><br><span class="line">git branch --no-merged</span><br><span class="line"><span class="comment">//仅打印未合并的分支列表</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-branch" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-status-代码状态"><a href="#git-status-代码状态" class="headerlink" title="git status 代码状态"></a>git status 代码状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br><span class="line"><span class="comment">//获取working copy的代码状态</span></span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line"><span class="comment">//更简单的展示working copy代码变更</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-status" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-stash-代码暂存"><a href="#git-stash-代码暂存" class="headerlink" title="git stash 代码暂存"></a>git stash 代码暂存</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash </span><br><span class="line"><span class="comment">//将当前分支的代码暂存</span></span><br><span class="line"></span><br><span class="line">git stash pop </span><br><span class="line"><span class="comment">//将最后一次暂存的代码恢复</span></span><br><span class="line"></span><br><span class="line">git stash -p path/to/file</span><br><span class="line"><span class="comment">//暂存某一个文件的内容，执行命令后要选择'y',暂存成功后，该文件将从本地变更中移出。</span></span><br><span class="line"></span><br><span class="line">git stash -p -- path/to/file1 path/to/file2</span><br><span class="line"><span class="comment">//暂存多个文件内容，执行命令后需要多次选择‘y’,使用git stash pop即可恢复暂存代码</span></span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment">//列出所有stash列表</span></span><br><span class="line"></span><br><span class="line">git stash drop</span><br><span class="line"><span class="comment">//丢弃最后一次代码暂存内容</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-stash" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-add-添加到本地仓库"><a href="#git-add-添加到本地仓库" class="headerlink" title="git add 添加到本地仓库"></a>git add 添加到本地仓库</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="comment">//将当前变更添加到本地仓库</span></span><br><span class="line"></span><br><span class="line">git add . -v</span><br><span class="line"><span class="comment">//将当前变更添加到本地仓库，并显示细节 `-v` == `--verbose`</span></span><br><span class="line"></span><br><span class="line">git add . -e</span><br><span class="line"><span class="comment">//使用vim打开已变更内容文件，可编辑，:wq保存后添加到本地仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-add" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-rm-删除文件"><a href="#git-rm-删除文件" class="headerlink" title="git rm 删除文件"></a>git rm 删除文件</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git rm filepath</span><br><span class="line"><span class="comment">//删除指定的文件，该文件必须被git标记为tracked的文件</span></span><br><span class="line"></span><br><span class="line">git rm --cached filepath</span><br><span class="line"><span class="comment">//从staged中删除filepath，filepath文件将变更为untracked状态，不会真正将文件删除掉</span></span><br><span class="line"></span><br><span class="line">git rm -f filepath</span><br><span class="line"><span class="comment">//强制将filepath文件删除掉，同时该文件的所有记录也将从git的快照中删除。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-rm" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-commit-提交代码"><a href="#git-commit-提交代码" class="headerlink" title="git commit 提交代码"></a>git commit 提交代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span> </span><br><span class="line"><span class="comment">//直接通过命令行输入提交信息，并将代码提交到本地仓库</span></span><br><span class="line"></span><br><span class="line">git commit</span><br><span class="line"><span class="comment">//使用vim打开本次提交内容，在vim中输入详细的提交信息,一般`git merge`后解决冲突使用这种方式更恰当</span></span><br><span class="line"></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="comment">//使用vim打开上次提交message,`:wq`保存后作为本次提交信息提交到本地仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-commit" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-checkout-分支创建切换"><a href="#git-checkout-分支创建切换" class="headerlink" title="git checkout 分支创建切换"></a>git checkout 分支创建切换</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git checkout anotherBranch</span><br><span class="line"><span class="comment">//从当前分支切换到anotherBranch分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b newBranch</span><br><span class="line"><span class="comment">//创建一个新的分支newBranch并切换到newBranch分支</span></span><br><span class="line"></span><br><span class="line">git checout -<span class="type">B</span> oneBranch</span><br><span class="line"><span class="comment">//创建或重置oneBranch分支并切换到oneBranch分支。</span></span><br><span class="line"></span><br><span class="line">git checkout .</span><br><span class="line"><span class="comment">//将本地所有变更内容reset到当前分支的HEAD状态，即undo本地所有变更内容</span></span><br><span class="line"></span><br><span class="line">git checkout -- path/to/file1 path/to/file2</span><br><span class="line"><span class="comment">//undo部分本地文件变更</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line"><span class="comment">//默认拉取当前所在分支的全程分支代码，并合并到本地分支</span></span><br><span class="line"></span><br><span class="line">git pull origin branch</span><br><span class="line"><span class="comment">//拉取远程变更历史，并合并变更</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-pull" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch </span><br><span class="line"><span class="comment">//拉取仓库默认远端的所有历史</span></span><br><span class="line"></span><br><span class="line">git fetch bookmark</span><br><span class="line"><span class="comment">//拉取仓库指定的bookmark指向的远端所有历史</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase branch</span><br><span class="line"><span class="comment">//将branch分支的代码rebase到当前分支</span></span><br></pre></td></tr></table></figure><p>rebase 和 merge 之间的使用，一直是比较有争议的，博主两个都使用，都遇到一些不好处理的地方，这里不做评价，请自行查阅官方文档。<br><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge branch</span><br><span class="line"><span class="comment">//合并本地branch分支代码到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge bookmark branch</span><br><span class="line"><span class="comment">//合并bookmark所在的远程branch分支代码到当前分支</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git push </span><br><span class="line"><span class="comment">//将已提交至本地仓库代码push到远程分支，默认push到本地分支所对应的远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch</span><br><span class="line"><span class="comment">//将已提交至本地仓库代码push到远程指定的thebranch分支上，如果没有则创建.</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -v</span><br><span class="line"><span class="comment">//功能同上，同时展示更多细节</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -q</span><br><span class="line"><span class="comment">//功能同上，尽可能的省略更多细节 跟`-v`相反</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -f </span><br><span class="line">git push -f</span><br><span class="line"><span class="comment">//强制push到远程thebranch分支或当前分支所对应的远程分支</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-push" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-mv-文件移动"><a href="#git-mv-文件移动" class="headerlink" title="git mv 文件移动"></a>git mv 文件移动</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br><span class="line"><span class="comment">//将file_from文件更名为file_to</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-mv" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log </span><br><span class="line"><span class="comment">//查看当前分支提交记录,按`q`退出</span></span><br><span class="line"></span><br><span class="line">git log --oneline --decorate</span><br><span class="line"><span class="comment">//查看提交记录，可在头部查看当前HEAD指针指向哪个分支</span></span><br><span class="line"></span><br><span class="line">git log --oneline --decorate --graph --all</span><br><span class="line"><span class="comment">//查看提交记录，并且可以看到当前HEAD指针指向，同时可以看到分支结构图。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line"><span class="comment">//查看tag列表</span></span><br><span class="line"></span><br><span class="line">git tag -l </span><br><span class="line"><span class="comment">//查看tag列表,等同于 git tag --list</span></span><br><span class="line"></span><br><span class="line">git tag -l <span class="string">"v1.2*"</span></span><br><span class="line"><span class="comment">//列出所有tag中包括v1.2前缀的tag列表</span></span><br><span class="line"></span><br><span class="line">git tag -a v1.<span class="number">2</span> -m <span class="string">"your tag descrption”"</span></span><br><span class="line"><span class="comment">//以当前分支创建v1.2tag，tag的信息为“your tag descrption”</span></span><br><span class="line"></span><br><span class="line">git show v1.<span class="number">2</span></span><br><span class="line"><span class="comment">//显示tag v1.2的详细信息</span></span><br><span class="line"></span><br><span class="line">git tag v1.<span class="number">3</span> -lw</span><br><span class="line"><span class="comment">//轻量级的tag,仅仅是打一个tag名，不支持跟-a -s或-m可选参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//将v1.4的tag push到远端仓库</span></span><br><span class="line"></span><br><span class="line">git push origin --tags</span><br><span class="line"><span class="comment">//将一对tagspush到服务端</span></span><br><span class="line"></span><br><span class="line">git tag -d v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//删除v1.4所指的tag</span></span><br><span class="line"></span><br><span class="line">git checkout v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//将当前working copydetach到HEAD状态，显示v1.4tag所指的内容</span></span><br><span class="line"></span><br><span class="line">git checkout -b v14branch v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//以v1.4tag为基准创建一个新的分支v14branch，并切换当前working copy到v14branch</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-tag" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog </span><br><span class="line"><span class="comment">//查看所有分支的提交记录和操作过程，按`q`退出</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-reflog" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff filepath</span><br><span class="line"><span class="comment">//查看filepath下的文件的变更  </span></span><br><span class="line"></span><br><span class="line">git diff branchName filepath</span><br><span class="line"><span class="comment">//当前分支的filepath文件与branchName分支的filepath文件对比 </span></span><br><span class="line"></span><br><span class="line">git diff <span class="type">HEAD</span> filepath</span><br><span class="line"><span class="comment">//查看filepath文件与HEAD所指向的节点的filepath文件对比</span></span><br><span class="line"></span><br><span class="line">git diff commitId filepath</span><br><span class="line"><span class="comment">//当前分支的filepath文件与指定commitId的提交时的filepath文件对比</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-diff" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-reset-代码回滚"><a href="#git-reset-代码回滚" class="headerlink" title="git reset 代码回滚"></a>git reset 代码回滚</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset <span class="type">HEAD</span></span><br><span class="line"><span class="comment">//将当前分支节点指向HEAD节点，其实没任何变化</span></span><br><span class="line"></span><br><span class="line">git reset <span class="type">HEAD</span>~<span class="number">1</span></span><br><span class="line"><span class="comment">//将当前分支指向HEAD节点的上一个节点,并将上一次提交的内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset commitID</span><br><span class="line"><span class="comment">//将当前分支指向commitID指向的节点,并将commit节点之后所提交的所有内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset --soft commitID</span><br><span class="line"><span class="comment">//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset --hard commitID</span><br><span class="line"><span class="comment">//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容全部删除.</span></span><br><span class="line"><span class="comment">//如果commitID之后的内容没有被push到远端服务器，那么`git reset --hard`将是非常危险的操作。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-reset" target="_blank" rel="noopener">更多用法</a></p><p>git reset 是具有一定危险性的操作方式，博主希望大家在执行命令前，一定先测试一下命令是否正确，是否能达到你想要的要求，千万不可带着试一试的态度去执行<code>git reset --hard</code>命令，很可能会导致你的代码丢失.</p><h2 id="git-alias"><a href="#git-alias" class="headerlink" title="git alias"></a>git alias</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git co branch </span><br><span class="line"><span class="comment">//等同于  git checkout branch</span></span><br><span class="line"></span><br><span class="line">git config --global alias. br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.unstage 'reset <span class="type">HEAD</span> --'</span><br><span class="line">git unstage filepath</span><br><span class="line"><span class="comment">//等同于 git reset HEAD -- filepath</span></span><br><span class="line"></span><br><span class="line">git config --global alias.last 'log -<span class="number">1</span> <span class="type">HEAD'</span></span><br><span class="line">git last</span><br><span class="line"><span class="comment">//查看最后一次commit日志</span></span><br><span class="line"></span><br><span class="line">git config --global alias.visual '!gitk'</span><br><span class="line"><span class="comment">//maybe you want to run an external command, rather than a Git subcommand. In that case, </span></span><br><span class="line"><span class="comment">//you start the command with a ! character. This is useful if you write your own tools that work with a Git repository.</span></span><br></pre></td></tr></table></figure><h2 id="git-version-查看版本信息"><a href="#git-version-查看版本信息" class="headerlink" title="git version 查看版本信息"></a>git version 查看版本信息</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="comment">//查看当前系统下的git版本信息</span></span><br></pre></td></tr></table></figure><h2 id="git-fsck-–lost-found"><a href="#git-fsck-–lost-found" class="headerlink" title="git fsck –lost-found"></a>git fsck –lost-found</h2><p>找回已经删除的文件，但是存在着add记录，博主未测试<a href="https://www.cnblogs.com/hope-markup/p/6683522.html" target="_blank" rel="noopener">链接</a></p><h2 id="git-ls-files-列出工程的所有忽略文件"><a href="#git-ls-files-列出工程的所有忽略文件" class="headerlink" title="git ls-files 列出工程的所有忽略文件"></a>git ls-files 列出工程的所有忽略文件</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --other --ignored --exclude-standard</span><br></pre></td></tr></table></figure><h2 id="友情推荐"><a href="#友情推荐" class="headerlink" title="友情推荐"></a>友情推荐</h2><ul><li><a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">git学习网站</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文记录git常用命令和使用方法，记录的博主平时工作所需的一些基础命令，并不能保证完整性和正确性，一般情况下的git使用基本上是满足的，当然如果您有一些特殊的需求，还是需要多查阅&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git权威指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;git-help-查看帮助文档&quot;&gt;&lt;a href=&quot;#git-help-查看帮助文档&quot; class=&quot;headerlink&quot; title=&quot;git help 查看帮助文档&quot;&gt;&lt;/a&gt;git help 查看帮助文档&lt;/h2&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git help &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//查看git init 的帮助文档命令，其余的类推&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;git-init-初始化Git仓库&quot;&gt;&lt;a href=&quot;#git-init-初始化Git仓库&quot; class=&quot;headerlink&quot; title=&quot;git init 初始化Git仓库&quot;&gt;&lt;/a&gt;git init 初始化Git仓库&lt;/h2&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Create an empty Git repository or reinitialize an existing one&lt;/code&gt;&lt;br&gt;命令执行后，在当前目录生成一个.git的隐藏目录，内含git仓库需要的资源。&lt;br&gt;&lt;a href=&quot;https://git-scm.com/docs/git-init&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;更多用法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kobeluo.com/categories/Tools/"/>
    
    
      <category term="常用命令" scheme="http://kobeluo.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="git" scheme="http://kobeluo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用笔记</title>
    <link href="http://kobeluo.com/2016/04/06/Mac%20useage/"/>
    <id>http://kobeluo.com/2016/04/06/Mac useage/</id>
    <published>2016-04-06T09:48:11.000Z</published>
    <updated>2018-12-05T08:40:30.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="显示隐藏文件："><a href="#显示隐藏文件：" class="headerlink" title="显示隐藏文件："></a>显示隐藏文件：</h4><div class="note info"><p>显示: <code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br>隐藏: <code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></p><p><strong>restart your mac</strong></p></div><a id="more"></a><h4 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h4><ul><li><a href="https://opensource.apple.com" target="_blank" rel="noopener">MAC OS OpenSource</a></li><li><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" target="_blank" rel="noopener">Mach IPC Interface</a><blockquote class="blockquote-center"><p>xxxx xxxx xxxx </p></blockquote></li></ul><ul><li><a href="https://github.com/KobeLuo/class-dump" target="_blank" rel="noopener">Class-dump</a><br>通过可执行文件反解析头文件<br>class-dump -H [.app文件的路径] -o [输出文件夹路径]</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;显示隐藏文件：&quot;&gt;&lt;a href=&quot;#显示隐藏文件：&quot; class=&quot;headerlink&quot; title=&quot;显示隐藏文件：&quot;&gt;&lt;/a&gt;显示隐藏文件：&lt;/h4&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;显示: &lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool true&lt;/code&gt;&lt;br&gt;隐藏: &lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;restart your mac&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kobeluo.com/categories/Tools/"/>
    
    
      <category term="常用命令" scheme="http://kobeluo.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Unicode Forms</title>
      <link href="/TECH/2018/11/05/StringEncode/"/>
      <url>/TECH/2018/11/05/StringEncode/</url>
      
        <content type="html"><![CDATA[<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a></h3><p>Unicode是计算机领域的一项业界标准，主要为了解决世界上大部分的文字系统的统一编码问题而存在，因此它记录了差不多世界上全部主流的语言的编码集合。Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0[2]，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p><a id="more"></a><h4 id="Unicode的设计原则"><a href="#Unicode的设计原则" class="headerlink" title="Unicode的设计原则"></a>Unicode的设计原则</h4><p>一下内容列举了Unciode设计的十大原则：</p><ul><li>Universality：提供单一、综合的字符集，编码一切现代与大部分历史文献的字符。</li><li>Efficiency：易于处理与分析。</li><li>Characters, not glyphs：字符，而不是字形。</li><li>Semantics：字符要有良好定义的语义</li><li>Plain text：仅限于文本字符</li><li>Logical order：默认内存表示是其逻辑序</li><li>Unification：把不同语言的同一书写系统（scripts）中相同字符统一起来。</li><li>Dynamic composition：附加符号可以动态组合。</li><li>Stability：已分配的字符与语义不再改变。</li><li>Convertibility：Unicode与其他著名字符集可以精确转换。</li></ul><h4 id="Unicode的编码与实现"><a href="#Unicode的编码与实现" class="headerlink" title="Unicode的编码与实现"></a>Unicode的编码与实现</h4><p>大体上来说，Unicode 编码系统可分为<code>编码方式</code>和<code>实现方式</code>两个层次.</p><h5 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h5><p>统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。</p><p>上述16位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。</p><p>基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。</p><p>关于统一码和ISO 10646及UCS的详细关系，见<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">通用字符集</a>。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为<code>UTF</code>）</p><p>Unicode实现方式的主流编码格式有：</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>:<br>  是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为邮箱、网页及其他存储或发送文字的应用中，优先采用的编码。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>:<br>  Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区块是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区块的码位来对辅助平面的字符的码位进行编码。</p></li><li><p>其它的一些编码方式(UTF-7、UTF-32、Punycode、CESU-8、SCSU、GB18030…etc)</p></li></ul><h3 id="Unicode-Form"><a href="#Unicode-Form" class="headerlink" title="Unicode Form"></a><a href="https://unicode.org/reports/tr15/" target="_blank" rel="noopener">Unicode Form</a></h3><p>Unicode主要有四种标准化格式，分别是</p><p>标准模式：</p><ul><li>Form C (Normalization Form C)</li><li>Form D (Normalization Form D)</li></ul><p>兼容模式：</p><ul><li>Form KC (Normalization Form KC)</li><li>Form KD (Normalization Form KD)</li></ul><p>关于标准化格式的内容,请自行查阅相关资料。</p><p>这里着重强调的是，Window使用的是UTF-16作为标注的编码方式，而并未使用Unicode的标准化格式，这就意味着你可以使用两个肉眼看上去一模一样的名字（实际上他们的代码点不一样），而Mac OS系统使用的是UTF-8作为标注编码方式，使用Form C作为标准文本格式，这意味着当你使用两个看上去一样的名字时，OS系统会自动将名字区分开。</p><p>由于使用上的操作系统的差异，就导致了有时候从服务端返回的名称看上去跟本地一致，其实不一致的问题。</p><p>对于采用了其它标准格式或未使用标准格式的服务端，对于服务端返回的名称，则需要把源字符串转化为标准的FormD格式（Mac OS系统底层默认格式），这样才能正常的比较字符串<br>而当你上传本地文件到服务端时，指定名字也需要反向的使用服务端相应的名字格式。</p><p>Mac OS/iOS系统下Foundation库中String的属性代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Form D</span><br><span class="line">@property (readonly, copy) NSString *decomposedStringWithCanonicalMapping; </span><br><span class="line"></span><br><span class="line">//Form C</span><br><span class="line">@property (readonly, copy) NSString *precomposedStringWithCanonicalMapping;</span><br><span class="line"></span><br><span class="line">//Form KD</span><br><span class="line">@property (readonly, copy) NSString *decomposedStringWithCompatibilityMapping;</span><br><span class="line"></span><br><span class="line">//Form KC</span><br><span class="line">@property (readonly, copy) NSString *precomposedStringWithCompatibilityMapping;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码格式 </tag>
            
            <tag> FormC </tag>
            
            <tag> FormD </tag>
            
            <tag> unicode Encode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mach 同步机制</title>
      <link href="/TECH/2018/10/31/mach-synchronization/"/>
      <url>/TECH/2018/10/31/mach-synchronization/</url>
      
        <content type="html"><![CDATA[<p>消息传递机制是 Mach IPC架构中的一个组件，另一个组件是同步机制(synchronization)，同步机制用于判定多个并发的操纵时，如何访问共享资源的问题。同步机制的本质是:<br><code>排他访问的能力，即：在使用一个资源时，排除其它对象对该资源的访问的能力。</code><br>最基本的同步原语是互斥(mutual exclusion)对象，也叫互斥体(mutex)。互斥体只不过是内核内存中的普通变量，硬件必须对这些变量进行原子(atomic)操作。意思是对互斥体的操作决不允许被打断，即使硬件中断也不能打断，在SMP系统上，互斥体还有一个要求就是要求硬件实现某种屏障(fence或barrier)。</p><a id="more"></a><p>下面是一些同步原语：</p><table><thead><tr><th>对象</th><th>实现的文件</th><th>所有者</th><th>可见性</th><th>等待</th></tr></thead><tbody><tr><td>互斥体(lck_mtx_t)</td><td>i386/i386_locks.c</td><td>1个</td><td>内核态</td><td>阻塞</td></tr><tr><td>信号量(semaphore_t)</td><td>kern/sync_sema.c</td><td>多个</td><td>用户态</td><td>阻塞</td></tr><tr><td>自旋锁(hw_lock_t等)</td><td>i386/i386_locks.s</td><td>1个</td><td>内核态</td><td>忙等</td></tr><tr><td>锁集(lock_set_t)</td><td>kern/sync_lock.c</td><td>1个</td><td>用户态</td><td>阻塞(同互斥体)</td></tr></tbody></table><p>Mach锁由两个层次组成：</p><ul><li>硬件相关层: 通过硬件的特性，通过特定的汇编指令实现的原子性和互斥性。</li><li>硬件无关层: 通过API包装硬件特定的调用，是通过简单的宏来实现的；这些API使得基于Mach的上层完全不用关心细节的实现。</li></ul><h3 id="锁组对象"><a href="#锁组对象" class="headerlink" title="锁组对象"></a><a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/locks.h.auto.html" target="_blank" rel="noopener">锁组对象</a></h3><p>大部分Mach的同步对象都不是独立存在的，而是属于<code>lck_grp_t</code>对象,<code>typedef struct __lck_grp__ lck_grp_t;</code>;<br>锁组(lock group)对象定义结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LCK_GRP_MAX_NAME64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> _<span class="title">lck_grp_</span> &#123;</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>lck_grp_link;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_refcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_spincnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_mtxcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_rwcnt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lck_grp_attr;</span><br><span class="line"><span class="keyword">char</span>lck_grp_name[LCK_GRP_MAX_NAME];</span><br><span class="line"><span class="keyword">lck_grp_stat_t</span>lck_grp_stat;</span><br><span class="line">&#125; <span class="keyword">lck_grp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCK_GRP_NULL(lck_grp_t *)0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lck_grp__</span> <span class="title">lck_grp_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><code>lck_grp_t</code>就是一个链表中的一个元素，有一个指定的名字，以及最多三种类型的锁:自旋锁、互斥体和读写锁。其中<code>lck_grp_stat_t</code>提供锁组的统计信息功能，用于调试和同步相关的问题。<code>lck_grp_attr</code>可以用来设置一个LCK_ATTR_DEBUG属性。</p><p>锁组的创建和销毁API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新的锁组； 锁组通过grp_name标识，拥有attr指定的属性，一般情况下，都是通过lck_grp_attr_alloc_init()设置默认属性。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_grp_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">const</span> <span class="keyword">char</span> *grp_name, <span class="keyword">lck_grp_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//接触分配锁组</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_grp_free</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在Mach和BSD中，几乎每个子系统在初始化时都会创建一个自己使用的锁组。</p><h3 id="互斥体对象"><a href="#互斥体对象" class="headerlink" title="互斥体对象"></a>互斥体对象</h3><p>互斥体(lck_mtx_t)是最常用的锁对象,它必须属于一个锁组，相关的API如下表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过指定的grp和attr,创建并初始化新的互斥体对象</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> lck_mtx_t *<span class="title">lck_mtx_alloc_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化已经分配的互斥体lck.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_init</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体上锁，如果重复上锁会产生阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_lock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体尝试上锁，如果不成功则返回失败</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> boolean_t <span class="title">ck_mtx_try_lock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥体解锁</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_unlock</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将互斥体标记为销毁，互斥体将不可以继续使用，但依然占据内存空间，可以重新对其初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_destroy</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将互斥体标记为销毁，并释放其内存空间。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_mtx_free</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,<span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程置于睡眠状态，直到lck变为可用状态</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_mtx_sleep</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck, <span class="keyword">ck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程置于睡眠状态，直到lck变为可用状态或到达deadline的时限</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_mtx_sleep_deadline</span><span class="params">(<span class="keyword">lck_mtx_t</span> *lck,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">lck_sleep_action_t</span> lck_sleep_action, <span class="keyword">event_t</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wait_interrupt_t</span> interruptible, <span class="keyword">uint64_t</span> deadline)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥锁有一个很大的缺点：<code>就是一次只能由一个线程持有锁对象。</code><br>在很多情况下，多线程可能对资源请求只读的访问。在这些情况下，使用互斥体会阻止并发的访问，即使这些线程之间并不会相互影响，这就带来了性能的瓶颈。</p><h3 id="读写锁对象"><a href="#读写锁对象" class="headerlink" title="读写锁对象"></a>读写锁对象</h3><p>读写锁(read-write lock)的设计初衷就是为了解决互斥锁的缺点。它是更智能的互斥锁，能够区分读写访问，多个只读的线程可以同时持有读写锁，而一次只允许一个写的线程可以获得锁，当一个写的线程持有锁是，其余线程的锁都将被阻塞。<br>跟mutex lock相似，下面是读写锁相关的API:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> lck_rw_t *<span class="title">lck_rw_alloc_init</span><span class="params">(<span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_init</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp, <span class="keyword">lck_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock_shared</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock_shared</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock_exclusive</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock_exclusive</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="comment">//如果当前线程是读，当有写的线程持有锁时，当前线程调用会被阻塞</span></span><br><span class="line"><span class="comment">//如果当前线程是写，当有其他线程获得锁时，调用会被阻塞</span></span><br><span class="line"><span class="comment">//这个API等同于lck_rw_lock_shared + lck_rw_lock_exclusion </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_lock</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_rw_type_t</span> lck_rw_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////这个API等同于lck_rw_unlock_shared + lck_rw_unlock_exclusion</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_unlock</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_rw_type_t</span> lck_rw_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_destroy</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">lck_rw_free</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_grp_t</span> *grp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//action 可以是LCK_SLEEP_SHARED 和 LCK_SLEEP_EXCLUSION.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_rw_sleep</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> wait_result_t <span class="title">lck_rw_sleep_deadline</span><span class="params">(<span class="keyword">lck_rw_t</span> *lck, <span class="keyword">lck_sleep_action_t</span> lck_sleep_action,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">event_t</span> event, <span class="keyword">wait_interrupt_t</span> interruptible, <span class="keyword">uint64_t</span> deadline)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><p>Mach提供了信号量(Semaphore)，信号量是一种泛化的互斥体，互斥体只能是0和1，而信号量是可以将取值达到某个整数时就允许持有信号量的线程同时执行的这样一种互斥体，信号量在用户态使用，而互斥体只能在内核态使用。</p><div class="note info"><p>Mach中的信号量和POSIX中的信号量不同，API也不同，因此两者不相容，在XNU上，POSIX信号量的底层实现是通过Mach的信号量实现的。<br>POSIX中的<code>sem_open()</code>函数其实调用了Mach的<code>semaphore_create()</code>函数</p></div><p>信号量本身是一个不可锁的对象，拥有很小的结构体，包含了所有者和端口的引用，还包括了一个wait_queue_t用来保证正在等待这个信号量的线程的链表，<br>wait_queue_t会通过硬件锁的方式锁定。<br>下面是信号量对象的结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MACH_KERNEL_PRIVATE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>  task_link;  <span class="comment">/* chain of semaphores owned by a task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> <span class="title">wait_queue</span>;</span> <span class="comment">/* queue of blocked threads &amp; lock     */</span></span><br><span class="line"><span class="keyword">task_t</span>  owner;      <span class="comment">/* task that owns semaphore            */</span></span><br><span class="line"><span class="keyword">ipc_port_t</span>  port;      <span class="comment">/* semaphore port      */</span></span><br><span class="line"><span class="keyword">int</span>  ref_count;  <span class="comment">/* reference count     */</span></span><br><span class="line"><span class="keyword">int</span>  count;      <span class="comment">/* current count value             */</span></span><br><span class="line"><span class="keyword">boolean_t</span>  active;     <span class="comment">/* active status     */</span></span><br><span class="line">&#125; Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> semaphore_lock(semaphore)   wait_queue_lock(&amp;(semaphore)-&gt;wait_queue)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> semaphore_unlock(semaphore) wait_queue_unlock(&amp;(semaphore)-&gt;wait_queue)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">semaphore_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span><span class="keyword">void</span><span class="title">semaphore_reference</span><span class="params">(<span class="keyword">semaphore_t</span> semaphore)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span><span class="keyword">void</span><span class="title">semaphore_dereference</span><span class="params">(<span class="keyword">semaphore_t</span> semaphore)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MACH_KERNEL_PRIVATE */</span></span></span><br></pre></td></tr></table></figure></p><p>下面列出了Mach中 信号量的相关API:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_create</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Creates a semaphore.</span></span><br><span class="line"><span class="comment"> *The port representing the semaphore is returned as a parameter.</span></span><br><span class="line"><span class="comment"> *为task创建一个信号量new_semaphore,policy表示阻塞的线程如何被唤醒，使用的是和锁策略相同的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_create(<span class="keyword">task_t</span> task, <span class="keyword">semaphore_t</span> *new_semaphore, <span class="keyword">int</span> policy, <span class="keyword">int</span> value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_destroy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Destroys a semaphore.  This call will only succeed if the</span></span><br><span class="line"><span class="comment"> *specified task is the SAME task name specified at the semaphore's</span></span><br><span class="line"><span class="comment"> *creation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *All threads currently blocked on the semaphore are awoken.  These</span></span><br><span class="line"><span class="comment"> *threads will return with the KERN_TERMINATED error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_destroy( <span class="keyword">task_t</span> task, <span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_signal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Traditional (in-kernel client and MIG interface) semaphore</span></span><br><span class="line"><span class="comment"> *signal routine.  Most users will access the trap version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *This interface in not defined to return info about whether</span></span><br><span class="line"><span class="comment"> *this call found a thread waiting or not.  The internal</span></span><br><span class="line"><span class="comment"> *routines (and future external routines) do.  We have to</span></span><br><span class="line"><span class="comment"> *convert those into plain KERN_SUCCESS returns.</span></span><br><span class="line"><span class="comment"> *增加信号量计数，如果计数器大于等于0，则唤醒一个阻塞的线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_signal(<span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_signal_all</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Awakens ALL threads currently blocked on the semaphore.</span></span><br><span class="line"><span class="comment"> *The semaphore count returns to zero.</span></span><br><span class="line"><span class="comment"> *将计数器值置为0，并唤醒所有阻塞的线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_signal_all(<span class="keyword">semaphore_t</span> semaphore)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:semaphore_wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Traditional (non-continuation) interface presented to</span></span><br><span class="line"><span class="comment"> * in-kernel clients to wait on a semaphore.</span></span><br><span class="line"><span class="comment"> * 减去一个信号量计数，如果小于0，则阻塞知道计数器再次变为非负数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span> semaphore_wait(<span class="keyword">semaphore_t</span> semaphore)</span><br></pre></td></tr></table></figure></p><p>信号量的属性可以让信号量转换为端口，也可以由端口转换回来，<a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/ipc_sync.c.auto.html" target="_blank" rel="noopener">ipc_sync.c</a>中定义了这些操作的函数，但该功能并不为用户态暴露，内核态也未使用。</p><h3 id="自旋锁对象"><a href="#自旋锁对象" class="headerlink" title="自旋锁对象"></a>自旋锁对象</h3><p>互斥体和信号量都是阻塞等待的对象。如果所被其他线程持有，那么请求将被加入到等待队列，当前线程处于阻塞状态，阻塞线程意味着放弃线程的时间片，把处理器让给调度器认为下一个要执行的线程。当锁可用时，调度器得到通知再根据判断将线程从等待队列中取出并重新调度。然而这种方式可能会严重的影响性能，在大多数情况下，锁对象可能只需要短短几个周期的时间，因为造成两次或更多次的上下文切换带来的开销非常大，在这种case下，如果线程不阻塞而是继续重复尝试访问锁对象所带来的开销可能会小得多，这种方式被称为“忙等(busy-wait)”。</p><p>然而上面说的case只是一种假设，按照这种方式自旋等待的线程很可能会陷入无限的循环等待中，这会造成一个非常恐怖的死锁场景，甚至整个系统会因此陷入停滞状态。</p><p>基础的自旋锁(spinlock)类型是硬件相关的<code>hw_lock_t</code>。其它的自旋锁类型都是实现在它之上： <code>lck_spin_t</code>、<code>simple_lock_t</code>、<code>usimple_lock_t</code>等。</p><p>这些自旋锁的的API和其它类型所得API都差不多，详参:</p><ul><li><a href="https://www.kernel.org/doc/Documentation/locking/spinlocks.txt" target="_blank" rel="noopener">自旋锁API</a></li><li><a href="https://opensource.apple.com/source/xnu/xnu-792.6.76/osfmk/kern/simple_lock.h.auto.html" target="_blank" rel="noopener">simple lock</a></li></ul><h3 id="锁集对象"><a href="#锁集对象" class="headerlink" title="锁集对象"></a><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" target="_blank" rel="noopener">锁集对象</a></h3><p>任务在用户态可以使用锁集，概念上，锁集对象就是锁的数组，实际上是互斥体的数组，通过给定的ID可以访问锁，锁可在线程之间传递，锁集是lck_mtx_t的封装<br>下面是相关的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为task创建一个lock_set,锁的数量是locks个，policy用于指定唤醒锁的策略，主要有</span></span><br><span class="line"><span class="comment">// SYNC_POLICY_FIFO 先进先出原则</span></span><br><span class="line"><span class="comment">// SYNC_POLICY_FIXED_PROIRITY 根据指定的优先级原则</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_set_create(<span class="keyword">task_t</span> task, <span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> locks, <span class="keyword">int</span> policy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁锁集及所包含的锁</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_set_destroy(<span class="keyword">task_t</span> task, <span class="keyword">lock_set_t</span> lock_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock_id从lock_set中获取指定的锁，该函数可能会永久阻塞如果指定的锁已经被另外的线程控制了。</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_acquire(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock_id释放锁集中指定的锁，如果调用的线程不拥有该锁，则会调用失败</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_release(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试获取锁，如果锁已经被持有了则立即返回KERN_LOCK_OWNED</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_try(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数清除锁集的不稳定状态，将锁集置于稳定状态。</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_make_stable(<span class="keyword">lock_set_t</span> lock_set,<span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程拥有的锁交出，并传递给匿名的接受线程，如果接受线程没有等待接收该锁，则会造成线程阻塞，知道接收线程接收为止。</span></span><br><span class="line"><span class="comment">//The lock_handoff function passes lock ownership from the calling thread to an anonymous accepting thread. </span></span><br><span class="line"><span class="comment">//The lock must be owned by the calling thread. If the accepting thread is not waiting to receive the lock, </span></span><br><span class="line"><span class="comment">//the calling thread will block until the hand-off is accepted.</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_handoff(<span class="keyword">lock_set_t</span> lock_set, <span class="keyword">int</span> lock_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个匿名线程通过lock_handoff传递的锁，如果发送锁的线程没有等待切换锁，</span></span><br><span class="line"><span class="comment">//则调用的线程将造成阻塞，知道锁切换完成，任何指定的时间只能有一个线程可能正在接受锁切换</span></span><br><span class="line"><span class="keyword">kern_return_t</span> lock_handoff_accept(<span class="keyword">lock_set_t</span> lock_set,<span class="keyword">int</span> lock_id);</span><br></pre></td></tr></table></figure></p><p>锁集的有趣之处在于允许锁在线程之间传递。Mach在调度中也使用了这个概念，允许一个线程放弃处理器并指定由另一个线程来接替运行。</p>]]></content>
      
      
      <categories>
          
          <category> Mac OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mach同步机制，同步，mutex，自旋锁，信号量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IPC-进程间通信</title>
      <link href="/TECH/2018/10/31/IPC/"/>
      <url>/TECH/2018/10/31/IPC/</url>
      
        <content type="html"><![CDATA[<p>进程间通信的基础原语: 消息、端口、已经确保并发安全的信号量和锁。这篇文章主要对于这些原语的底层实现和端口的内部实现做一些探讨。</p><p>Mach任务是一个对应于进程的高层次抽象，Mach任务包含了一个指向自己的IPC namespace（命名空间），在命名空间中保存了自己的端口，此外mach任务也可以获得系统范围内的端口，如：主机端口、特权端口和其它端口。</p><a id="more"></a><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><hr><p>导出给用户空间的端口对象(mach_port_t)实际上是对”真正”端口对象的一个句柄，后者是<a href="https://opensource.apple.com/source/xnu/xnu-344/osfmk/ipc/ipc_port.h" target="_blank" rel="noopener">ipc_port_t</a>，其数据结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  A receive right (port) can be in four states:</span></span><br><span class="line"><span class="comment"> *1) dead (not active, ip_timestamp has death time)</span></span><br><span class="line"><span class="comment"> *2) in a space (ip_receiver_name != 0, ip_receiver points</span></span><br><span class="line"><span class="comment"> *to the space but doesn't hold a ref for it)</span></span><br><span class="line"><span class="comment"> *3) in transit (ip_receiver_name == 0, ip_destination points</span></span><br><span class="line"><span class="comment"> *to the destination port and holds a ref for it)</span></span><br><span class="line"><span class="comment"> *4) in limbo (ip_receiver_name == 0, ip_destination == IP_NULL)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  If the port is active, and ip_receiver points to some space,</span></span><br><span class="line"><span class="comment"> *  then ip_receiver_name != 0, and that space holds receive rights.</span></span><br><span class="line"><span class="comment"> *  If the port is not active, then ip_timestamp contains a timestamp</span></span><br><span class="line"><span class="comment"> *  taken when the port was destroyed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">ipc_port_timestamp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">ipc_port_flags_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initial sub-structure in common with ipc_pset and rpc_port</span></span><br><span class="line"><span class="comment"> * First element is an ipc_object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span> <span class="comment">//ipc对象，初始化子结构跟ipc_pset和rpc_port一致。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span> <span class="comment">//指向接收者的IPC指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span> <span class="comment">//指向全局端口的指针</span></span><br><span class="line"><span class="keyword">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">&#125; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ipc_kobject_t</span> ip_kobject;</span><br><span class="line"><span class="keyword">mach_port_mscount_t</span> ip_mscount;</span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_srights;</span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_sorights;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_dnrequests</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ip_pset_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span> <span class="comment">//消息队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">ip_premsg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>NORMA_VM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *These fields are needed for the use of XMM.</span></span><br><span class="line"><span class="comment"> *Few ports need this information; it should</span></span><br><span class="line"><span class="comment"> *be kept in XMM instead (TBD).  XXX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span>ip_norma_xmm_object_refs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span>*<span class="title">ip_norma_xmm_object</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>MACH_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>IP_NSPARES10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>IP_CALLSTACK_MAX10</span></span><br><span class="line"><span class="keyword">queue_chain_t</span>ip_port_links;<span class="comment">/* all allocated ports */</span></span><br><span class="line"><span class="keyword">natural_t</span>ip_thread;<span class="comment">/* who made me?  thread context */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>ip_timetrack;<span class="comment">/* give an idea of "when" created */</span></span><br><span class="line"><span class="keyword">natural_t</span>ip_callstack[IP_CALLSTACK_MAX]; <span class="comment">/* stack trace */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>ip_spares[IP_NSPARES]; <span class="comment">/* for debugging */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* MACH_ASSERT */</span></span></span><br><span class="line"><span class="keyword">int</span>alias;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="消息传递的实现"><a href="#消息传递的实现" class="headerlink" title="消息传递的实现"></a>消息传递的实现</h3><hr><p>用户态的Mach消息传递使用的函数是<code>mach_msg()</code>函数，这个函数通过内核的Mach trap调用内核函数<code>mach_msg_trap()</code>。然后<code>mach_msg_trap</code>调用<code>mach_msg_overwrite_trap()</code>,<code>mach_msg_overwrite_trap</code>通过测试<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>标志位来判断是发送操作还是接收操作。</p><p>下面分析IPC最重要的两个函数<code>mach_msg_send()</code>和<code>mach_msg_receive()</code>的实现</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Mach 消息发送的核心逻辑在内核中有两处实现: <code>mach_msg_overwrite_trap()</code>和<code>mach_msg_send()</code>。后者只用于内核态的消息传递，对用户态不可见。两处实现的逻辑大同小异并遵循以下流程：</p><ul><li>调用<code>current_space()</code>来获取当前的IPC空间。</li><li>调用<code>current_map()</code>来获取当前VM空间(<a href="https://www.freebsd.org/cgi/man.cgi?query=vm_map&amp;sektion=9&amp;apropos=0&amp;manpath=FreeBSD+11-current" target="_blank" rel="noopener">vm_map</a>)</li><li>对消息的大小进行正确性检查。</li><li>计算要分配的消息大小，从send_size参数获得大小再加上硬编码的MAX_TRAILER_SIZE。</li><li>通过ipc_kmsg_alloc分配消息。</li><li>复制消息(复制消息send_size字节的部分)，然后在消息头设置msgh_size。</li><li>复制消息关联的端口权限，然后通过ipc_kmsg_copyin将所有的OOL数据的内存复制到当前的vm_map。 ipc_kmsg_copyin函数调用了ipc_kmsg_copyin_header和ipc_kmsg_copyin_body。</li><li>调用ipc_kmsg_send()发送消息：<ul><li>获得msgh_remote_port引用，并锁定端口。</li><li>如果该端口是一个内核端口（即端口的ip_receiver是内核的IPC空间），那么通过ipc_kobject_server()函数处理消息。该函数会在内核中找到相应的函数来执行消息，还会生成消息的应答。</li><li>不论哪种端口，调用ipc_mqueue_send(),这个函数将消息直接复制到端口的ip_messages队列中并唤醒任何正在等待的线程处理消息。</li></ul></li></ul><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>Mach接收消息的方式个发送类似，也体现在内核的两个地方，<code>mach_msg_overwrite_trap()</code>用用户态接收请求，而内核通过<code>mach_msg_receive()</code>函数接收消息。</p><ul><li>调用current_space()来获取当前的IPC空间</li><li>调用current_map()</li><li>不校对消息大小，因为发送的时候已经校对过了</li><li>通过调用ipc_mqueue_copyin()获取IPC队列</li><li>持有当前线程的一个引用。使用当前线程的引用可使它适合使用Mach的续体模型，续体(continuation)模型可以表面维护完整线程栈的必要性。<code>续体是撒玩意儿博主也弄不明白</code></li><li>调用ipc_mqueue_receive()从队列中取出消息</li><li>调用mach_msg_receive_results()函数，该函数也可以从续体中调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> Process Communication </tag>
            
            <tag> 进程间通信 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mach_trap (未完结)</title>
      <link href="/TECH/2018/10/31/mach-trap/"/>
      <url>/TECH/2018/10/31/mach-trap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mac OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac OS内核 </tag>
            
            <tag> Mach陷阱 </tag>
            
            <tag> Mach trap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mach 原语 笔记-基础篇</title>
      <link href="/TECH/2018/10/31/Mach/"/>
      <url>/TECH/2018/10/31/Mach/</url>
      
        <content type="html"><![CDATA[<h3 id="Mach-概述"><a href="#Mach-概述" class="headerlink" title="Mach 概述"></a><a href="https://zh.wikipedia.org/wiki/Mach" target="_blank" rel="noopener">Mach</a> 概述</h3><hr><h4 id="Mach设计原则"><a href="#Mach设计原则" class="headerlink" title="Mach设计原则"></a>Mach设计原则</h4><p>Mac OS X采用Mach作为锡系统的内核，其源头可以追溯到乔老爷创立的NeXT。Mach采用了极简主义概念:<br><code>具有一个简单最小的核心，支持面向对象的模型，使得独立的具有良好定义的组件可以通过消息的方式互相通信。</code><br>Mach只提供了一个极简的模型，操作系统本身可以在这个模型基础上实现，OS X的<a href="https://en.wikipedia.org/wiki/XNU" target="_blank" rel="noopener">XNU</a>是UNIX（<a href="https://zh.wikipedia.org/zh-hans/FreeBSD" target="_blank" rel="noopener">FreeBSD</a> 4.4）在Mach上的一个具体实现，Windows也采用了一些Mach的原则，不过其实现方式与Mac OS则完全不同。</p><p>Mach内核成为了一个底层的基础，它只关心驱动操作系统的最少需求，其余的功能则需要由上层来实现，尽管Mach对用户态也是可见的，使用Mach都是实现了深层次的核心功能，在这个基础上可以实现更大的内核，而Mach则是内核中的内核，<code>XNU的官方API是BSD的POSIX API,Apple保持了Mach绝对的极简，基于Mach外层则有丰富的Cocoa API来支撑，因此Mach是Mac OS X操作系统中最关键最基础的部分</code></p><a id="more"></a><p>在Mach的所有都是通过自己的对象实现的。进程、线程、虚拟内存其实都是对象，所有的对象都有自己的属性，所谓的对象其实就是C语言的结构体加上函数指针实现的。</p><p>Mach的独特之处在于选择了通过消息传递的方式实现对象与对象之间的通信。而其他架构中一个对象要访问另一个对象则需要一个接口来实现。而Mach对象不能直接调用另一个对象，而是通过消息传递的方式，源发送一条消息，这条消息被加入到目标对象的队列中等待处理，类似，消息处理中可能会产生一个应答，该应答则通过另一条消息被发送回源对象，消息发送的方式是以FIFIO的方式保证了传输的可靠性，而内容则由发送者和接收者协商。</p><h4 id="Mach-设计目标"><a href="#Mach-设计目标" class="headerlink" title="Mach 设计目标"></a>Mach 设计目标</h4><p>其最重要的目标是将所有的功能都移出内核，将功能放在用户态中去实现，保持内核极简，其主要功能如下:</p><ul><li>控制点和执行单元(线程)管理</li><li>线程和线程组的资源分配</li><li>虚拟内存的分配和管理</li><li>底层物理资源的分配(即CPU、内存和其他任何物理设备)</li></ul><p>Mach只提供了实行策略的方法，而不提供策略本身，Mach也不会识别任何安全特性、优先级和选项(Options)，所有这些都需要上层去定义和实现。</p><p>Mach设计中有一个强大的优点:<strong>多处理(multi process)</strong>。<br>内核中大部分的功能都是由独立的组件实现，组件之间的传递具有良好定义的消息，之间没有公共作用域，因此，没有必要所有的组件都在同一个处理器上执行，甚至不要求在同一台计算机上执行。<br><strong>理论上：Mach可以轻松扩展成计算机集群使用的操作系统。</strong></p><h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><hr><p>消息是Mach中最基本的概念，通过短点(endpoint)或端口(port)之间传递，消息是Mach IPC的核心模块。</p><h4 id="简单消息"><a href="#简单消息" class="headerlink" title="简单消息"></a>简单消息</h4><p>一条消息就像一个网络数据包，通过固定的包头进行封装，定义为BLOB(binary large object,二进制大对象)，在Mach中，消息定义在<code>&lt;mach/message.h&gt;</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span>body;</span><br><span class="line">&#125;<span class="keyword">mach_msg_base_t</span>;</span><br></pre></td></tr></table></figure></p><p>而消息头是强制要求的，其中定义了相关的元数据，内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>msgh_bits; <span class="comment">//消息头的标识位</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>msgh_size;<span class="comment">//大小，以字节为单位</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>msgh_remote_port;<span class="comment">//目标(发出的消息)或源(接收的消息)</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>msgh_local_port;<span class="comment">//源(发出的消息)或目标(接收的消息)</span></span><br><span class="line">  <span class="keyword">mach_port_name_t</span>msgh_voucher_port;<span class="comment">//</span></span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>msgh_id;<span class="comment">//唯一ID</span></span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure></p><p>一条消息就是一个BLOB,通过端口发送到另一个端口并带有可选的标识；<br>消息还可以选择带有一个消息尾(trailer),其定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">mach_msg_trailer_type_t</span>;</span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">mach_msg_trailer_size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_trailer_type_t</span>msgh_trailer_type;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_size_t</span>msgh_trailer_size;</span><br><span class="line">&#125; <span class="keyword">mach_msg_trailer_t</span>;</span><br></pre></td></tr></table></figure></p><p>每一种trailer类型都定义了一种特殊的trailer格式，这些格式都是为未来可以实现扩展的，下面是一些已经定义好的类型：</p><table><thead><tr><th style="text-align:left">trailer</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">mach_msg_trailer_t</td><td style="text-align:left">空trailer</td></tr><tr><td style="text-align:left">mach_msg_security_trailer_t</td><td style="text-align:left">发送者安全令牌</td></tr><tr><td style="text-align:left">mach_msg_seqno_trailer_t</td><td style="text-align:left">顺序编号</td></tr><tr><td style="text-align:left">mach_msg_audit_trailer_t，mach_msg_context_trailer_t</td><td style="text-align:left">审计令牌(用于BSM)</td></tr><tr><td style="text-align:left">mach_msg_mac_trailer_t</td><td style="text-align:left">MAC策略标签</td></tr></tbody></table><p>应答消息和内核消息使用到了trailer.</p><h4 id="复杂消息"><a href="#复杂消息" class="headerlink" title="复杂消息"></a>复杂消息</h4><p>除了简单的消息外，有一些带有额外的字段和结构的消息被称为”复杂消息”，它们是通过消息头标志中的MACH_MSGH_BITS_COMPLEX位来表示的，而且数据结构也不同：<br><code>消息头后面跟着一个描述符计数字段，再接一个串行化的描述符</code></p><table><thead><tr><th style="text-align:left">trailer</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">MACH_MSG_PORT_DESCRIPTOR</td><td style="text-align:left">传递一个端口权限</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_DESCRIPTOR</td><td style="text-align:left">传递 out-of-line 数据</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_PORTS_DESCRIPTOR</td><td style="text-align:left">传递 out-of-line 端口</td></tr><tr><td style="text-align:left">MACH_MSG_OOL_VOLATILE_DESCRIPTOR</td><td style="text-align:left">传递有可能发生变化(volatile)的out-of-line数据</td></tr></tbody></table><p>以上是一些已规定的复杂消息描述符，其中<code>out-of-line</code>是Mach消息的一个重要特性，允许添加各种数据的分散指针，类似于电子邮件添加附件的功能，其64位的数据结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span>*address;<span class="comment">//指向数据的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       size;<span class="comment">//数据大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean_t</span>     deallocate: <span class="number">8</span>;<span class="comment">//发送之后是否解除分配</span></span><br><span class="line">  <span class="keyword">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;<span class="comment">//复制指令</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     pad1: <span class="number">8</span>;<span class="comment">//预留参数</span></span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;<span class="comment">//MACH_MSG_OOL_DESCRIPTOR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">mach_msg_ool_descriptor_t</span>;</span><br></pre></td></tr></table></figure></p><p>OOL描述了要附加的数据的地址和大小，一级如何处理数据的指令，例如是否可以解除分配，以及复制选项(如物理内存和虚拟内存的复制)。<br>OOL描述符常用语传递大块的数据，能避免昂贵的复制操作。</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Mach消息的发送和接收都是通过同一个API函数mach_msg()来完成的，该函数在用户态和内核态都有实现，其原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:mach_msg</span></span><br><span class="line"><span class="comment"> *Purpose:</span></span><br><span class="line"><span class="comment"> *Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="function"><span class="keyword">extern</span> mach_msg_return_t<span class="title">mach_msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify)</span></span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Routine:mach_msg_overwrite</span></span><br><span class="line"><span class="comment"> *Purpose:</span></span><br><span class="line"><span class="comment"> *Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Distinct send and receive buffers may be specified.  If</span></span><br><span class="line"><span class="comment"> *no separate receive buffer is specified, the msg parameter</span></span><br><span class="line"><span class="comment"> *will be used for both send and receive operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *In addition to a distinct receive buffer, that buffer may</span></span><br><span class="line"><span class="comment"> *already contain scatter control information to direct the</span></span><br><span class="line"><span class="comment"> *receiving of the message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="function"><span class="keyword">extern</span> mach_msg_return_t<span class="title">mach_msg_overwrite</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *rcv_msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_limit)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接受一个消息缓冲区参数，对于发送操作是一个输入指针，对于接收操作是一个输出指针。该函数还有一个姊妹函数<code>mach_msg_overwrite</code>，允许调用者指定另外两个参数:一个是<code>mach_msg_header_t*</code>指向接收缓冲区，一个是<code>mach_msg_size_t</code>用于表示缓冲区大小。<br>无论哪个函数，都可以通过按位操作选项来指定，具体的操作如下表：</p><table><thead><tr><th style="text-align:left">选项标志位</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">MACH_RCV_MSG</td><td style="text-align:left">接收一条消息放在msg缓冲区</td></tr><tr><td style="text-align:left">MACH_RCV_LARGE</td><td style="text-align:left">如果接收缓冲区太小，则将过大的消息放在队列中，并且出错返回MACH_RCV_TOO_LARGE。在这种情况下，只返回消息头(指定消息的大小)，因此调用者可以分配更多的内存</td></tr><tr><td style="text-align:left">MACH_RCV_TIMEOUT</td><td style="text-align:left">单位是毫秒，如果接收超时，则出错返回MACH_RCV_TIMED_OUT。timeout值可以指定为0</td></tr><tr><td style="text-align:left">MACH_RCV_NOTIFY</td><td style="text-align:left">带通知的接收操作</td></tr><tr><td style="text-align:left">MACH_RCV_INTERRUPT</td><td style="text-align:left">允许操作被打断(返回MACH_RCV_INTERRUPT)</td></tr><tr><td style="text-align:left">MACH_RCV_OVERWRITW</td><td style="text-align:left">在mach_msg_overwrite中，指定额外的参数：接收缓冲区参数，输入还是输出</td></tr><tr><td style="text-align:left">MACH_SEND_MSG</td><td style="text-align:left">发送msg缓冲区中的消息</td></tr><tr><td style="text-align:left">MACH_SEND_INTERRUPT</td><td style="text-align:left">允许发送操作被打断</td></tr><tr><td style="text-align:left">MACH_SEND_TIMEOUT</td><td style="text-align:left">发送超时，单位是毫秒。如果发送timeout秒后还未发送完成，则返回MACH_SEND_TIME_OUT</td></tr><tr><td style="text-align:left">MACH_SEND_NOTIFY</td><td style="text-align:left">向通知端口通知消息的传递 </td></tr><tr><td style="text-align:left">MACH_SEND_ALWAYS</td><td style="text-align:left">内部使用</td></tr><tr><td style="text-align:left">MACH_SEND_TRAILER</td><td style="text-align:left">表示一个已知的Mach trailer位于位置大小偏移的位置(也就是紧跟着消息缓冲区之后的位置，有点晦涩，笔者没看明白)</td></tr><tr><td style="text-align:left">MACH_SEND_CANCEL</td><td style="text-align:left">取消一条消息(Lion中已经被移出了)</td></tr></tbody></table><p>Mach消息原本是为真正的微内核框架而设计的，也就是说<code>mach_msg()</code>必须在发送者和接收者之间复制消息所在的内存，这种实现方式忠于微内核的范式，但事实证明：频繁的复制内存所带来的性能消耗是无法忍受的。<br>因此，XNU通过单一内核方式:所有的内核组件都共享同一个地址空间，这样传递消息的过程中只需要传递消息的指针的就可以了，从而省去了昂贵的内存复制操作。</p><p>为了实现消息的发送和接收，<code>mach_msg()</code>函数调用了一个Mach trap（<a href="http://www.kobeluo.com/TECH/2018/10/31/mach-trap/" target="_blank" rel="noopener">Mach 陷阱</a>）,在用户态调用<code>mach_msg_trap()</code>函数会引发陷阱机制，切换到内核态，而在内核态中，内核实现的<code>mach_msg()</code>会完成实际的工作。</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是一个32位整型的标识符，不能按整数来操作，而是要按照透明的对象来操作。<br><code>像一个端口发送消息实际是将消息放在一个队列中，直到消息能被接收者处理。</code><br>所有的Mach原生对象都是通过对应的端口访问的，查找一个对象的句柄(Handle)时，实际上请求的是这个对象端口的句柄，访问端口是通过访问端口权限的方式进行的，Mach端口权限的定义如下:</p><table><thead><tr><th style="text-align:left">MACH_PORT_RIGHT_</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SEND</td><td style="text-align:left">向端口发送消息。允许多个发送者</td></tr><tr><td style="text-align:left">RECEIVE</td><td style="text-align:left">从端口读取消息，实际上这是对端口的所有权</td></tr><tr><td style="text-align:left">SEND_ONCE</td><td style="text-align:left">只发送一次消息，该权限在使用后立即被撤销(revoke)，成为DEAD_NAME</td></tr><tr><td style="text-align:left">PORT_SET</td><td style="text-align:left">同时拥有多个端口的接受权限</td></tr><tr><td style="text-align:left">DEAD_NAME</td><td style="text-align:left">端口在SEND_ONCE之后用完了权限</td></tr></tbody></table><p>关键是SEND和RECEIVE,而SEND_ONCE跟SEND一样，只不过只能发送一次。MACH_PORT_RIGHT_RECEIVE权限的持有者实际上是端口的所有者，这是允许从该端口读取队列消息的唯一实体。</p><p>&lt;mach/mach_port.h&gt;中的函数可以用于操纵任何端口，甚至可以在任务之外操纵。其中，<code>mach_port_names</code>函数可以导出给定任务的端口空间名称。</p><p>端口和权限也可以从一个实体传递到另一个实体。实际上，通过复杂消息将端口从一个任务传递到另一个任务并不罕见，这是IPC设计中的一个非常强大的特性，有点类似于UNIX中的<code>domain socket</code>允许在进程间传递描述符。<br>Lion允许UNIX文件描述符和Mach端口相互转换。这些对象称为fileport，主要有通知系统使用。</p><p>Mach通过端口命名服务器注册全局的端口-即系统范围内的端口。在XNU中，这个“自举服务器”正是PID为1的launchd(8)，该进程注册自举服务器端口，由于系统的所有进程都是launchd的后代，因此从诞生起都集成了这个端口。</p><h4 id="Mach-接口生成器-MIG"><a href="#Mach-接口生成器-MIG" class="headerlink" title="Mach 接口生成器(MIG)"></a>Mach 接口生成器(MIG)</h4><p>Mach没有使用专门的端口映射器(不过launchd(8)处理了一部分端口映射的逻辑）,但是Mach中有一个类似于<a href="https://en.wikipedia.org/wiki/RPCGEN" target="_blank" rel="noopener">rpcgen</a>的组件，即Mach接口生成器(Mach Interface Generator)，简称MIG。rpcgen在经典UNIX中的SUN-RPC中，通过rpcgen编译器从IDL(Interface Definition Language, IDL)生成代码。<br>在/usr/include/mach目录下，可以看到一些.defs文件，这些文件包含了各种Mach子系统的IDL定义。</p>]]></content>
      
      
      <categories>
          
          <category> Mac OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mach </tag>
            
            <tag> MAC OS </tag>
            
            <tag> Mac内核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git深入理解</title>
      <link href="/TECH/2018/10/16/git-deep/"/>
      <url>/TECH/2018/10/16/git-deep/</url>
      
        <content type="html"><![CDATA[<p>在<a href="http://www.kobeluo.com/TECH/2016/07/15/git-useage" target="_blank" rel="noopener">git使用</a>这篇文章中，博主列出了常用的git命令和一些使用方法，可以应付日常的开发工作，熟悉git的朋友应该知道，git是一个非常强大的工具，能使用git的常规命令只能说你掌握了git的基本操作，如果还需要更深入的理解git，理解每一条命令背后执行的操作和含义，则需要更为深刻的理解git的运行机制和设计原理，博主对于git的理解也很浅显，该文在谈及git内涵外，也希望有更多的大神能够相互交流，以此增进对git的理解，毕竟进步源于分享嘛 ^.^。<br><a id="more"></a></p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>先列出官方文档:</p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a></li><li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">git常用命令</a></li><li><a href="https://git-scm.com/doc" target="_blank" rel="noopener">git权威指南</a></li></ul><h2 id="git仓库介绍"><a href="#git仓库介绍" class="headerlink" title="git仓库介绍"></a>git仓库介绍</h2><h3 id="关于git仓库基础构造的官方文档如下图"><a href="#关于git仓库基础构造的官方文档如下图" class="headerlink" title="关于git仓库基础构造的官方文档如下图"></a>关于git仓库基础构造的官方文档如下图</h3><p><img src="/TECH/2018/10/16/git-deep/git-structure.png" alt="git仓库基础结构"><br><img src="/TECH/2018/10/16/git-deep/git-structure-desc.png" alt="git仓库细节"></p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><h4 id="git仓库代码树的三大状态"><a href="#git仓库代码树的三大状态" class="headerlink" title="git仓库代码树的三大状态:"></a>git仓库代码树的三大状态:</h4><p><code>Modified：</code> 代表被检出的代码已经被更改，但是还没有添加到暂存区，当然也没有提交到本地仓库；<br><code>Staged：</code> 代表被检出的代码已经加入了暂存区，它将是你下一次执行commit时提交的变更内容；<br><code>Committed：</code> 代表你的代码已经安全永久的提交到了本地仓库。</p><h4 id="git仓库的三大仓库区"><a href="#git仓库的三大仓库区" class="headerlink" title="git仓库的三大仓库区"></a>git仓库的三大仓库区</h4><p><code>git repository</code> 本地仓库，git最重要的部分，存储了一个工程所有的git信息和数据对象。<br><code>Working Directory</code> 工作目录或工作区，是指当你执行<code>git checkout branch</code>时，存储branch所指的节点的数据和git信息，以提供你增删改查。<br><code>Staging Area</code> 暂存区 介于检出代码于modified和committed之间的一种状态区域，当你执行<code>git add -a</code>时，将已经modified的代码添加到暂存区，以供下一次commit时将暂存区的变更提交到本地仓库。</p><h4 id="从实际项目出发理解"><a href="#从实际项目出发理解" class="headerlink" title="从实际项目出发理解"></a>从实际项目出发理解</h4><p>1.执行<code>git clone</code>时，将远程代码clone到本地，此时建立了git本地仓库，同时默认工作区是master分支，此时暂存区为空；<br>2.执行<code>git checkout branch</code>时，将branch分支的代码作为工作区，此时工作区从master分支变更为branch分支的代码内容和git信息；<br>3.现在开始增删改查项目的内容；<br>4.当你保存更改时，git将变更的内容标记为modified；<br>5.此时你可能需要提交代码了；执行 <code>git add .</code>将 已更改的代码提交到暂存区，被更改的代码的状态从<code>Modified</code>变更为<code>Staged</code>；<br>6.此时执行命令<code>git commit</code>提交代码，将暂存区的变更快照提交到本地仓库，变更代码状态从<code>Staged</code>变更为<code>Committed</code>，自此你的变更内容将永久安全的存储到本地仓库。</p><h2 id="文件的记录过程"><a href="#文件的记录过程" class="headerlink" title="文件的记录过程"></a>文件的记录过程</h2><p>每个文件在working copy中的状态有两种: tracked(被跟踪) or untracked(未被跟踪)<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Remember</span> that each file <span class="keyword">in</span> your working directory can be <span class="keyword">in</span> one of two states: tracked or untracked. </span><br><span class="line"><span class="type">Tracked</span> files are files that were <span class="keyword">in</span> the last snapshot; they can be unmodified, modified, or staged.</span><br><span class="line"><span class="type">In</span> short, tracked files are files that <span class="type">Git</span> knows about.</span><br></pre></td></tr></table></figure></p><p>被跟踪的文件的文件状态存储在最后一次快照中。<br><img src="/TECH/2018/10/16/git-deep/file-status-all.png" alt="git文件全状态"></p><h2 id="忽略暂存区提交"><a href="#忽略暂存区提交" class="headerlink" title="忽略暂存区提交"></a>忽略暂存区提交</h2><p>常用的提交流程是：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></p><p>命令<code>git add .</code>会将已变更的代码添加到暂存区，然后通过<code>git commit</code>命令将暂存区的快照提交到本地仓库。</p><p>这儿还有一种方式提交代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></p><p>它的意思是绕过暂存区，直接将本地被追踪的变更代码提交到本地仓库。<br><em>相同点：</em></p><ul><li>被追踪的代码都可以直接提交到本地working copy。</li></ul><p><em>不同点：</em></p><ul><li>未被追踪的文件使用后者无法正常提交到本地working copy；</li><li>后者的代码将不被添加到暂存区；</li><li>前者是较为安全的提交方式，一旦你执行了<code>git reset --hard</code>且未push到远端，那么代码将永久丢失。</li></ul><h2 id="git-commit-实现"><a href="#git-commit-实现" class="headerlink" title="git commit 实现"></a>git commit 实现</h2><p>假如说当前是一个全新的仓库，并执行以下命令：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span> </span><br><span class="line">git add <span class="type">README</span> test.rb <span class="type">LICENSE</span></span><br><span class="line">git commit -m :<span class="type">The</span> <span class="type">Initial</span> commit of my project:</span><br></pre></td></tr></table></figure></p><p>当你运行<code>git commit</code>创建commit时，git checksums所有的子目录和git仓库中存储这些文件的<code>tree object</code>，同时git创建一个拥有元数据和一个指向<code>root project tree</code>的指针的<code>commit object</code>, 一个<code>commit object</code>其实质上就是一个<code>snapshot</code>.</p><p>现在，git仓库包含了五个object,分别是三个文件(README test.rb LICENSE),一个包含跟目录下所有内容<br>和指定<code>name&lt;--&gt;file匹配</code>的列表的<code>tree</code>和一个包含所有提交元数据和指向<code>root true</code>的指针，<br>比较抽象，其实就是三个文件和一个snapshot和一个指向<code>root commit</code>的指针，如下图所示：<br><img src="/TECH/2018/10/16/git-deep/commit-root.png" alt="commit-root"></p><p>此时如果你又提交了几次，那么关于snapshot和指针的关系图，如下所示：<br><img src="/TECH/2018/10/16/git-deep/snap-pointer-relation.png" alt="snap-pointer-relation"></p><p>通过上图可以理解到git commit背后运行的规律：<br><div class="note info"><p>1.git commit并不是存储的变化的文件，而是存储的一些列snapshot和一个带链表结构的指向父指针的指针。<br>2.整个分支结构路由是靠链表结构的指针来运作的，所以当你<code>git branch newbranch</code>时，其实就是创建了一个新的指针，该指针指向当前的指针加上一个branch name,整个过程非常高效快速。<br>3.当通过<code>git checkout commitId</code>去切换到以前的某个分支时，其实是通过指针去挨个找寻父指针，并从父指针指向的snapshot中去将变更挨个恢复，因此你可以感觉到chekout越早的分支速度越慢，git需要遍历更多的指针去恢复变更数据。</p></div></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git理解 </tag>
            
            <tag> git </tag>
            
            <tag> git进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift 桥接OC代码重构</title>
      <link href="/TECH/2018/07/05/codesnapshot/"/>
      <url>/TECH/2018/07/05/codesnapshot/</url>
      
        <content type="html"><![CDATA[<p>博主目前从事NAVER旗下公司的一个虚拟云盘工作开发，开发语言选择了Swift，但是Objective-C中有一些非常方便的API函数在Swift中并没有提供，早起博主直接使用了官方提供的<a href="https://stackoverflow.com/questions/24002369/how-to-call-objective-c-code-from-swift" target="_blank" rel="noopener">bridge</a>方案来桥接OC部分代码，这样可以方便的使用OC的API，但是这也带来一个性能问题，每次桥接的过程会有一定的耗时；</p><p>如果你的项目只是一个普通的信息展示，调用的频次不高，对于性能的优化要求可能就相对较低，但如果你的项目是高频次调用这些API，<a id="more"></a>并且对性能的要求极尽所能，可能你就会对每一行代码的执行效率和耗时做严格的审查，为了提供性能，可能需要将OC函数自己实现，分享部分代码，以供参考。</p><h3 id="String-Extension"><a href="#String-Extension" class="headerlink" title="String Extension"></a>String Extension</h3><h4 id="lastPathComponents"><a href="#lastPathComponents" class="headerlink" title="lastPathComponents"></a>lastPathComponents</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> lastPathComponent: <span class="type">String</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> str = <span class="keyword">self</span>.decomposedStringWithCanonicalMapping</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> str.<span class="built_in">count</span> &lt;= <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="number">_</span>, value) <span class="keyword">in</span> str.enumerated().reversed() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">"/"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> name != <span class="string">""</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; name = <span class="type">String</span>(value) + name &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于String的格式 FormC 和 FormD，请<a href="http://www.kobeluo.com/TECH/2018/11/05/StringEncode/" target="_blank" rel="noopener">右转</a></p><h4 id="pathComponents"><a href="#pathComponents" class="headerlink" title="pathComponents"></a>pathComponents</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> pathComponents: [<span class="type">String</span>] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = [<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">var</span> resultCnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">let</span> strcnt = str.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">var</span> component: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">"/"</span> &#123; results.append(<span class="string">"/"</span>); <span class="keyword">return</span> results &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pre: <span class="type">Character</span>? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">var</span> pathRepeat = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (index,value) <span class="keyword">in</span> str.enumerated() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">"/"</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pre == <span class="string">"/"</span> &#123; pathRepeat = <span class="literal">true</span> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> com = component &#123; results.append(com); resultCnt += <span class="number">1</span> &#125;</span><br><span class="line">                component = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pathRepeat || (resultCnt == <span class="number">0</span> &amp;&amp; pre == <span class="string">"/"</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                pathRepeat = <span class="literal">false</span>; results.append(<span class="string">"/"</span>); resultCnt += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> component == <span class="literal">nil</span> &#123; component = <span class="string">""</span> &#125;</span><br><span class="line">            component?.append(value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index == strcnt - <span class="number">1</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> com = component &#123; results.append(com) &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; results.append(<span class="string">"/"</span>) &#125;</span><br><span class="line">            </span><br><span class="line">            resultCnt += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pathRegularly"><a href="#pathRegularly" class="headerlink" title="pathRegularly"></a>pathRegularly</h4><p>该函数是一个基础函数，服务于其它函数，服务于其它函数的内部函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pathRegularly</span><span class="params">(of str: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> prechar: <span class="type">Character</span> = <span class="string">"1"</span></span><br><span class="line">    <span class="keyword">let</span> strcnt = str.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">for</span> (index,char) <span class="keyword">in</span> str.enumerated() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> char != <span class="string">"/"</span> || prechar != <span class="string">"/"</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> index == strcnt - <span class="number">1</span> &amp;&amp; char == <span class="string">"/"</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">            result.append(char)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prechar = char</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastchar = result.last, lastchar == <span class="string">"/"</span> &#123; result.removeLast() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="appendingPathComponent"><a href="#appendingPathComponent" class="headerlink" title="appendingPathComponent"></a>appendingPathComponent</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">appendingPathComponent</span><span class="params">(path: String?, regularly: Bool = <span class="literal">false</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> path = path <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> str = <span class="keyword">self</span>; <span class="keyword">var</span> name = path</span><br><span class="line">    <span class="keyword">if</span> regularly == <span class="literal">false</span> &#123;</span><br><span class="line">        </span><br><span class="line">        str = pathRegularly(of: <span class="keyword">self</span>); name = pathRegularly(of: path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> firstchar = name.first, firstchar == <span class="string">"/"</span> &#123; <span class="keyword">return</span> str + name &#125;</span><br><span class="line"><span class="keyword">return</span> str + <span class="string">"/"</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码共享 </tag>
            
            <tag> 片段代码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac上建立基于osx fuse的虚拟磁盘</title>
      <link href="/TECH/2017/07/24/osxfuse/"/>
      <url>/TECH/2017/07/24/osxfuse/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>苹果文件系统<a href="https://www.google.co.kr/search?q=APFS&amp;oq=APFS&amp;aqs=chrome..69i57j0l5.5335j0j7&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">AFPS</a>允许用户挂载自己的磁盘(Mount disk)，类似<a href="https://www.pcloud.com/zh/" target="_blank" rel="noopener">PCloud</a>；也允许用户通过底层API来监控某个文件夹的变化来做同步，类似<a href="https://www.dropbox.com/" target="_blank" rel="noopener">DropBox</a>，最终目的都是为了实现本地文件与服务端同步来方便人们的工作和生活，博主对于两种方式来同步文件都有一定涉猎，国内外目前针对Mount盘的文献和资料相对较少，博主在工作过程中遇到过很多的坑，共享出来，希望能帮助到有缘人。</p></blockquote><a id="more"></a><h3 id="OSX-FUSE"><a href="#OSX-FUSE" class="headerlink" title="OSX FUSE"></a><a href="https://osxfuse.github.io/" target="_blank" rel="noopener">OSX FUSE</a></h3><hr><h4 id="osxfuse介绍"><a href="#osxfuse介绍" class="headerlink" title="osxfuse介绍"></a>osxfuse介绍</h4><p>关于osx fuse，官方的介绍已经非常详尽了，它主要针对Mac OS文件系统相关的一些操作提供底层的SDK帮助,其主要功能如下:<br><div class="note info"><ol><li>AccessibilityFS </li><li>LoopbackFS   </li><li>SpotlightFS    </li><li>SSHfs</li><li>other functions</li></ol></div></p><ul><li><strong>LoopbackFS</strong> 将Finder中某个文件夹作为一个独立的文件系统挂载起来;</li><li><strong>SpotlightFS</strong>   OS特有的文件系统，连接spotlight使用的，当使用spotlight搜索时，会存储搜索结果;</li><li><strong>SSHfs</strong>  基于SSH的文件系统，用于挂载远程的文件系统。<br>本篇文章将主要介绍使用OSX FUSE来搭建自己的mount盘.</li></ul><h4 id="osxfuse安装"><a href="#osxfuse安装" class="headerlink" title="osxfuse安装"></a>osxfuse安装</h4><p>下载<a href="https://github.com/osxfuse/osxfuse/releases" target="_blank" rel="noopener">osx fuse.dmg</a>，安装后<code>system preferences</code>底部会多一个FUSE item，<img src="/TECH/2017/07/24/osxfuse/fusePanel.png" alt="system preference screenshot"><br>下载<a href="https://github.com/osxfuse/framework" target="_blank" rel="noopener">osxfuse.framwork</a>，使用xcode编译后导入到自己自己工程中。</p><h4 id="osxfuse结构介绍"><a href="#osxfuse结构介绍" class="headerlink" title="osxfuse结构介绍"></a>osxfuse结构介绍</h4><p>这里以<a href="https://github.com/osxfuse/filesystems" target="_blank" rel="noopener">LookbackFS</a>的swift版本为例介绍fuse的基本概念及用法.<br><figure class="highlight swift"><figcaption><span>需要初始化的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> rootPath: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> loopFileSystem: <span class="type">LoopbackFS</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">LoopbackFS</span>(rootPath: <span class="keyword">self</span>.rootPath)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> userFileSystem: <span class="type">GMUserFileSystem</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">GMUserFileSystem</span>(delegate: <span class="keyword">self</span>.loopFileSystem, isThreadSafe: <span class="literal">false</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><ul><li>rootPath 由于LookbackFS是义某个文件夹作为mount的对象，因此rootPath就是本地某个文件夹地址；</li><li>loopFileSystem该参数作为osx回调的代理，用来接收所有从底层过来的消息；</li><li>userFileSystem该参数主要作为启动mount的载体，加载mount需要的各项参数。</li></ul><h4 id="Mount挂载"><a href="#Mount挂载" class="headerlink" title="Mount挂载"></a>Mount挂载</h4><figure class="highlight swift"><figcaption><span>Mount</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.rootPath = rootPath</span><br><span class="line"></span><br><span class="line">addNotifications()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options: [<span class="type">String</span>] = [<span class="string">"native_xattr"</span>, <span class="string">"volname=LoopbackFS"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> volumeIconPath = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"LoopbackFS"</span>,</span><br><span class="line">ofType: <span class="string">"icns"</span>) &#123;</span><br><span class="line"></span><br><span class="line">    options.insert(<span class="string">"volicon=<span class="subst">\(volumeIconPath)</span>"</span>, at: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">userFileSystem.mount(atPath: <span class="string">"/Volumes/loop"</span>, withOptions: options)</span><br></pre></td></tr></table></figure><p>该片段代码展示了mount 过程的细节，其中<a href="https://github.com/osxfuse/osxfuse/wiki/Mount-options" target="_blank" rel="noopener">options</a>是OSX FUSE指定的某些特定参数，用以实现不同的mount盘功能。<br>而<code>/Volumes/loop</code>则是在macbook上挂载的mount盘的地址,如下图:</p><p><img src="/TECH/2017/07/24/osxfuse/mountinfo.png" alt="mount disk info"><br>图中可以看出，mount盘在Macintosh中的地址是<code>/Volumes/loop</code>,而显示的名字是<code>LoopbackFS</code>。<br><img src="/TECH/2017/07/24/osxfuse/path.png" alt="mount disk info"><br>接下来是注册mount结果的通知<br><figure class="highlight swift"><figcaption><span>Notification</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNotifications</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemDidMount), object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got didMount notification."</span>)</span><br><span class="line">        <span class="comment">//do something.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemMountFailed), object: <span class="literal">nil</span>, queue: .main) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got mountFailed notification."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>(kGMUserFileSystemDidUnmount), object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">        <span class="type">Log</span>.record(info: <span class="string">"Got didUnmount notification."</span>)</span><br><span class="line">        <span class="type">NSApplication</span>.shared().terminate(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当mount盘发生状态变更时会调用到该函数中，至此，mount盘就已经挂载到了APFS上。</p><h3 id="Event-Stream"><a href="#Event-Stream" class="headerlink" title="Event Stream"></a>Event Stream</h3><hr><h4 id="mount盘事件原理"><a href="#mount盘事件原理" class="headerlink" title="mount盘事件原理"></a>mount盘事件原理</h4><p>前文提到注册mount盘的过程实例化了一个loopFileSystem，以下简称loopInvoke，它主要用来接收从底层过来的所有的事件信息，loopInvoke实现了所有的GMUserFileSystem的代理方法。前文Mount的过程其实质是osxfuse向APFS注册了事件的回调反馈，用户在Mount盘中的任何行为，都将以flag的形式反馈给osx fuse，osx fuse通过解析这些flag并转化成上层可以读懂的事件反馈到loopInvoke实例，如果需要返回值，则将loopInvoke处理后的返回值返回给APFS。</p><div id="flowchart-0" class="flow-chart"></div><h4 id="loopInvoke事件详解"><a href="#loopInvoke事件详解" class="headerlink" title="loopInvoke事件详解"></a>loopInvoke事件详解</h4><h5 id="回调函数列表"><a href="#回调函数列表" class="headerlink" title="回调函数列表:"></a>回调函数列表:</h5><p>先看一下loopInvoke回调事件函数列表如下:<br><figure class="highlight swift"><figcaption><span>函数列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createDirectory</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:])</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//remove</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeDirectory</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeItem</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//other important</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">moveItem</span><span class="params">(atPath source: String!, toPath destination: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">openFile</span><span class="params">(atPath path: String!, mode: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">releaseFile</span><span class="params">(atPath path: String!, userData: Any!)</span></span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(atPath path: String!, userData: Any!, buffer: UnsafeMutablePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(atPath path: String!, userData: Any!, buffer: UnsafePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">exchangeDataOfItem</span><span class="params">(atPath path1: String!, withItemAtPath path2: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">contentsOfDirectory</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Any</span>]</span><br><span class="line"><span class="comment">//attributes</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">finderAttributes</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">resourceAttributes</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfItem</span><span class="params">(atPath path: String!, userData: Any!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfFileSystem</span><span class="params">(forPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyHashable</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setAttributes</span><span class="params">(<span class="number">_</span> attributes: [AnyHashable : Any]!, ofItemAtPath path: String!, userData: Any!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">extendedAttributesOfItem</span><span class="params">(atPath path: Any!)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Any</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(ofExtendedAttribute name: String!, ofItemAtPath path: String!, position: off_t)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setExtendedAttribute</span><span class="params">(<span class="number">_</span> name: String!, ofItemAtPath path: String!, value: Data!, position: off_t, options: Int32)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeExtendedAttribute</span><span class="params">(<span class="number">_</span> name: String!, ofItemAtPath path: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//link </span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">linkItem</span><span class="params">(atPath path: String!, toPath otherPath: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">//symbolic link</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createSymbolicLink</span><span class="params">(atPath path: String!, withDestinationPath otherPath: String!)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destinationOfSymbolicLink</span><span class="params">(atPath path: String!)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">//pre alloc</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">preallocateFile</span><span class="params">(atPath path: String!, userData: Any!, options: Int32, offset: off_t, length: off_t)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure></p><p>哇！！！乱七八糟一大堆函数回调，实际上仔细归类后发现，基本上涵盖了文件操作的所有细节。</p><div class="note danger"><p><strong>这些细节全部由你来掌控！</strong></p><ul><li>当用户创建一个文件A时，APFS会通过OSX FUSE传递到loopInvoke，告诉你现在收到一个信号是创建了一个A文件，问你怎么办？</li><li>当APFS需要读取A文件的属性时发出信号向你询问A文件的属性应该是怎样的？</li><li>当A文件被更名成B文件时，发出信号告诉你有这个事情，至于是否需要更名成B文件或者抛错，由你来决定！</li></ul></div><h5 id="事件详解"><a href="#事件详解" class="headerlink" title="事件详解"></a>事件详解</h5><p>以create函数为例来分析一下事件的过程。<br><figure class="highlight swift"><figcaption><span>create file event</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> mode = attributes[<span class="type">FileAttributeKey</span>.posixPermissions] <span class="keyword">as</span>? mode_t <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(posixErrorCode: <span class="type">EPERM</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalPath = rootPath.appending(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fileDescriptor = <span class="keyword">open</span>((originalPath <span class="keyword">as</span> <span class="type">NSString</span>).utf8String!, flags, mode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fileDescriptor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(posixErrorCode: errno)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userData.pointee = <span class="type">NSNumber</span>(value: fileDescriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参数解析</strong></p><ul><li>mode 是<a href="http://www.man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener">open2</a>函数的参数，该参数必须指定为<code>O_CREAT</code>或者<code>O_TMPFILE</code>flag，如果不是这两个参数，那么该参数将被忽略。<blockquote><p>以下是官方解释<br>The mode argument specifies the file mode bits be applied when a new file is created.<br>This argument must be supplied when O_CREAT or O_TMPFILE is specified in flags;<br>if neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</p></blockquote></li><li>originalPath 是指实际文件系统中文件的路劲</li><li>flags 用于指定文件创建时的打开方式的集合，官方的解释如下:<blockquote><p>以下是官方解释<br>The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.<br>These request opening the file read-only, write-only, or read/write, respectively.<br>In addition, zero or more file creation flags and file status flags can be bitwise-or’d in flags.<br>The file creation flags are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC.</p></blockquote></li><li>fileDescription 是指文件句柄，该文件句柄用于文件操作过程中的唯一标志符。</li><li>userData是一个指针，用来存储文件操作过程中用户定义的数据，该字段在实际项目中作用很大。<div class="note danger"><p><strong>总结:</strong></p><p>通过解析create函数，可以看出，APFS将所有的事件都会发送到loopInvoke，至于怎么处理事件，由开发者自己来决定！<br>也正因为如此，Mount开发需要谨慎对待，处理不善，可能就无法正常运转Mount盘。</p></div></li></ul><p><a href="http://blog.sina.com.cn/s/blog_8b94e9b40100w49w.html" target="_blank" rel="noopener">博客收录入口</a></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Starte=>end: Endevt=>operation: User Operationop1=>operation: APFS op2=>operation: Fuse parse and generateop3=>operation: loopInvoke handle eventcond=>condition: has return value?st->evt->op1->op2->op3(right)->condcond(yes,top)->op1cond(no,bottom)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FUSE </tag>
            
            <tag> Mount Disk </tag>
            
            <tag> LookbackFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo使用笔记</title>
      <link href="/TECH/2017/04/07/Hexo-useage-note/"/>
      <url>/TECH/2017/04/07/Hexo-useage-note/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>博主使用过博客站点有简书、CSDN、博客园、都不同程度的遇到了各种不顺心，MarkDown使用起来也不是特别方便，决定使用GitPages+Hexo来实现编写博客，在完成完成Hexo配置的过程中，踩了不少坑，决定记录下来供大家参考。</p><p>个人博客站点:<a href="https://kobeluo.github.io/TECH/" target="_blank" rel="noopener">KobeLuo的博客</a></p></blockquote><a id="more"></a><h3 id="有关Github仓库"><a href="#有关Github仓库" class="headerlink" title="有关Github仓库"></a>有关<a href="https://github.com/" target="_blank" rel="noopener">Github</a>仓库</h3><hr><h4 id="创建一个Github账号，添加一个Repository"><a href="#创建一个Github账号，添加一个Repository" class="headerlink" title="创建一个Github账号，添加一个Repository"></a>创建一个Github账号，添加一个Repository</h4><div class="note danger"><p><strong>注意： 如果想要使用username.github.io这种方式访问你的博客站点，<br>Repository的名字一定要与用户名username相同</strong>(username/username.github.io)<br>仓库名创建之后一定像这样:KobeLuo/KobeLuo.github.io      </p></div><p>博主曾经在这里踩过坑，导致博客站点报404，一直无法访问</p><h4 id="git分支与关系"><a href="#git分支与关系" class="headerlink" title="git分支与关系"></a><a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="noopener">git分支与关系</a></h4><p>首先理解一个原理:<br><div class="note info"><p>github仓库下至少需要两个分支,这里我们假设为branch1和branch2，<br>如果branch1作为最后静态页面的发布分支，那么branch2就可以作为平时创作的源代码托管分支.<br>branch1不需要你通过git命令push代码，需要通过使用<code>hexo d</code>命令发布到该分支上，前提是本地_config.yml文件已经配置正确，关于本地配置后面会提到<br>branch2是平时写博客过程中，需要使用git命令push源代码的分支,当然你也可以创建更多的源代码托管分支。</p></div></p><p>通常情况下建的博客站点都是在username.github.io这一层，GitPages会默认master作为hexo的发布分支(上面提到的branch1)，此时settings-&gt;Gitpages-&gt;Source下的branch是不可选择的，在这种情况下，开发分支就必须要使用其它的分支(比如develop分支或其他分支)来存储Hexo主题下的源代码。</p><p>如果你的博客站点不是以username.github.io，那么需要按照<a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/" target="_blank" rel="noopener"><strong>git发布配置规范</strong></a>配置站点，此时settings-&gt;GitPages-&gt;Source可以选择，通常情况下会有master、gh-pages和/docs供你选择，选择好静态页面的发布分支后,再考虑源代码托管到哪个分支上面。</p><p><span id="jump"> </span></p><h4 id="关于SSHKey"><a href="#关于SSHKey" class="headerlink" title="关于SSHKey"></a>关于SSHKey</h4><p>首先进入用户目录下的.ssh目录<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>使用ssh keygen生成一个SSHKey,需要提供一个邮箱<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your@email.address"</span></span><br></pre></td></tr></table></figure></p><p>Enter file in which to save the key (/Users/name/.ssh/id_rsa):<strong><code>在此输入id_rsa的名字:id_rsa_name</code></strong><br>例如:id_rsa_person or id_rsa_company,如果只需要管理一个SSHKey,直接回车会默认生成id_rsa为名的SSHKey<br>配置了名字，后面一路回车<br>结束后，.ssh文件夹里边会包括id_rsa_name、id_rsa_name.pub两个文件，复制id_rsa_pub的内容拷贝到github设置的SSHKey选项中即可完成配置。</p><h4 id="多账号管理"><a href="#多账号管理" class="headerlink" title="多账号管理:"></a>多账号管理:</h4><p>如果你有多个Github账号，由于Github账号SSHKey的唯一性，就必须生成多个SSHKey，多个SSHKey只要生成的时候指定的名字不一样即可，假设你生成了两个rsa名为id_rsa_name1和id_rsa_name2,<br>那么你需要在.ssh目录里边创建一个名为<code>config</code>的文件，里边的配置信息如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host kobe_old <span class="comment">//所有使用id_rsa_kobe_old.pub作为公钥的github链接中的github.com需要换成kobe_old</span></span><br><span class="line">HostName github.com</span><br><span class="line">Usergit</span><br><span class="line">IdentityFile~/.ssh/id_rsa_kobe_old</span><br><span class="line"></span><br><span class="line">Host kobe_new <span class="comment">//所有使用id_rsa_kobe_new.pub作为公钥的github链接中的github.com需要换成kobe_new</span></span><br><span class="line">HostName github.com</span><br><span class="line">Usergit</span><br><span class="line">IdentityFile~/.ssh/id_rsa_kobe_new </span><br></pre></td></tr></table></figure><div class="note info"><p>从远程clone一个仓库时，例如<a href="https://github.com:KobeLuo/Kobeluo.github.io/" target="_blank" rel="noopener">https://github.com:KobeLuo/Kobeluo.github.io/</a><br>当有多个SSHKey时，<code>需要将github.io改成kobe_new</code>如果该账号使用kobe_new对应的SSHKey<br>更改后的远程地址是<a href="https://kobe_new:KobeLuo/Kobeluo.github.io/" target="_blank" rel="noopener">https://kobe_new:KobeLuo/Kobeluo.github.io/</a></p></div><p>最后将你生成的rsa加入到keychain中,有时候push代码时会报Permission Error,如果你rsa配置正常，也需要执行一下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -K ~/.ssh/id_rsa_your_name</span><br></pre></td></tr></table></figure></p><h4 id="绑定你的独立域名"><a href="#绑定你的独立域名" class="headerlink" title="绑定你的独立域名"></a>绑定你的独立域名</h4><p>Github提供gitpages服务可以生成独立二级域名，如非必要，你大可不必自己购买独立域名，如果你购买了自己的域名，就按照以下步骤做:</p><ul><li><p>在静态页面托管分支创建一个CNAME文件，里边放你的独立域名，我的域名是kobeluo.com,因此CNAME中存放的就是kobeluo.com,如果你使用的是hexo模板，每次执行hexo g之后CNAME文件都将被清理掉，<strong>解决办法是把CNAME文件存放在本地hexo根目录下的source文件目录中，这样每次hexo d都会生成到发布静态网页分支</strong></p></li><li><p>配置DNS,在你的DNS配置域名解析页面中配置三组记录他们分别是:<br>我这里使用的是<a href="https://www.dnspod.cn" target="_blank" rel="noopener"><strong>DNSPod</strong></a>,关于如何使用DNSPod请自行查阅。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机记录记录类型记录值</span><br><span class="line">@A<span class="number">192.30</span><span class="number">.252</span><span class="number">.153</span></span><br><span class="line">@A<span class="number">192.30</span><span class="number">.252</span><span class="number">.154</span></span><br><span class="line">www<span class="built_in">CNAME</span>your.blog.address(我这里是:KobeLuo.github.io)</span><br></pre></td></tr></table></figure><p>配置完成之后，等10分钟，等待域名生效。</p><h3 id="关于Hexo主题模板"><a href="#关于Hexo主题模板" class="headerlink" title="关于Hexo主题模板"></a>关于<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Hexo主题</a>模板</h3><hr><h4 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h4><p>请自行查阅<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方安装教程</a></p><h4 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h4><p>hexo有自己独立的一套命令</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"article"</span></span><br><span class="line"><span class="comment">//创建一篇新文章</span></span><br><span class="line">hexo new page <span class="string">"foldername"</span></span><br><span class="line"><span class="comment">//创建一个新页面</span></span><br><span class="line">hexo g  (hexo generate)</span><br><span class="line"><span class="comment">//生成静态页面</span></span><br><span class="line">hexo s  (hexo server) ,如果报错就执行代码 </span><br><span class="line"><span class="comment">//链接本地服务器</span></span><br><span class="line">hexo d  (hexo deploy)</span><br><span class="line"><span class="comment">//发布到指定服务器</span></span><br><span class="line">hexo clean <span class="comment">//清理静态页面站点，博主使用过一次，会把git配置和hexo搞乱，慎用。</span></span><br><span class="line"></span><br><span class="line">npm install --save hexo-filter-flowchart </span><br><span class="line"><span class="comment">//画流程图的[插件](https://github.com/bubkoo/hexo-filter-flowchart)</span></span><br></pre></td></tr></table></figure><p>执行hexo s可能会报错，如果报错则执行以下命令：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo站点配置"><a href="#hexo站点配置" class="headerlink" title="hexo站点配置"></a>hexo站点配置</h4><p>hexo根目录下的<code>_config.yml</code>就是站点配置文件，使用编辑软件打开,搜索<code>deploy:</code>,<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: your.blog.site(like:xxx.github.io)</span><br><span class="line">branch: gh-pages or master or docs</span><br></pre></td></tr></table></figure></p><div class="note info"><p>填写_config.yml配置文件里边的值前都需要添加一个空格，<br>例如 <code>type: git</code> 注意中间有一个空格</p></div><p>配置好这一项后，使用<code>Hexo d</code>就可以把代码deploy到远程仓库了<br><div class="note warnning"><p>如果你的Github站点不是以github.io结束的，需要配置<code>root:</code>字段，例如，我的技术博客地址是kobeluo.github.io/TECH/ , 那么root:配置就是 <strong><code>/TECH/</code></strong>,否则github无法连接CSS和JS</p></div></p><h3 id="2018-10-12日更新"><a href="#2018-10-12日更新" class="headerlink" title=" 2018.10.12日更新"></a><center> 2018.10.12日更新</center></h3><hr><p>由于自己懒惰，博客已经停更一年多了，近日再次捡起博客，发现Hexo已经有一些变化，记载于此。<br>首先hexo不再像以前一样安装之后就可以直接使用, <a href="http://coderunthings.com/2017/08/20/howhexoworks/" target="_blank" rel="noopener">hexo是怎么工作的</a>,这篇文章说得非常清楚了。</p><h4 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h4><p>hexo分为三个分支：</p><ul><li>HEXO<ol><li>hexo-cli</li><li>hexo (hexo-core)</li><li>hexo plugins</li></ol></li></ul><p>使用命令<code>npm install -g hexo-cli</code> 后可以使用命令<br><code>hexo generate (hexo g) 和 hexo new</code>但是无法使用<code>hexo s 和hexo d</code>,<br>此时需要使用npm安装启动本地服务和发布的插件,命令是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>安装好插件后,应该就可以使用<code>hexo s</code>了，此时启动本地服务,网页可能弹出Can not GET /XX/XX目录,此时你需要执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>再次执行hexo s,本地网页应该就可以正常显示了.</p><p>假设你已经安装好了<a href="https://treehouse.github.io/installation-guides/mac/node-mac.html" target="_blank" rel="noopener">npm</a>,这里针对已有的博客,需要再次编辑博客的一个完整流程:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:xxxxxxx /A/B/C  将仓库clone到你本地/A/B/C的位置</span><br><span class="line">npm install -g hexo-cli 安装hexo</span><br><span class="line">npm install  </span><br><span class="line">npm install hexo-server --save 安装hexo s</span><br><span class="line">npm install hexo-deployer-git --save 安装 hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>如果你本地有多个github账号，因此而产生的权限问题，请左转<a href="#多账号管理">ssh key</a><br>hexo d实质是将你本地public文件夹的内容push到博客<code>_config.yml</code>所指定的分支上去,如果<code>hexo d</code>报权限错误，<br>请一定检查</p><pre><code class="ruby"><span class="symbol">deploy:</span><span class="symbol">type:</span> git<span class="symbol">repo:</span> git@github.<span class="symbol">com:</span>KobeLuo/TECH.git<span class="symbol">branch:</span> gh-pages</code></pre><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><hr><p>下面是一些记录的hexo站点:</p><p>官方站点</p><ul><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><p>hexo建站教程</p><ul><li><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30836436</a></li><li><a href="http://www.jianshu.com/p/ab21abc31153" target="_blank" rel="noopener">http://www.jianshu.com/p/ab21abc31153</a>    </li><li><a href="http://www.jianshu.com/p/35e197cb1273" target="_blank" rel="noopener">http://www.jianshu.com/p/35e197cb1273</a>     </li><li><a href="https://www.jianshu.com/p/35e197cb1273" target="_blank" rel="noopener">https://www.jianshu.com/p/35e197cb1273</a></li></ul><p>hexo 用法教程</p><ul><li><a href="https://www.jianshu.com/p/9a56f7c13a79" target="_blank" rel="noopener">https://www.jianshu.com/p/9a56f7c13a79</a>     </li></ul><div class="note info"><p><strong>特别鸣谢:</strong><br>建站过程中，<a href="http://liuhongjiang.github.io/hexotech/" target="_blank" rel="noopener"><strong>Andrew Liu</strong></a>提供了非常多的帮助，再次感谢！.</p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GCD系列:信号量(dispatch_semaphore)</title>
      <link href="/TECH/2017/03/28/dispatch-semaphore/"/>
      <url>/TECH/2017/03/28/dispatch-semaphore/</url>
      
        <content type="html"><![CDATA[<p>信号量有点像具备N个task并行能力的channel,当channel的并行能力未达到上限时可以任意往里边加task，当达到channel上限时，需要task完成才可以加入新的task.<br><a id="more"></a></p><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_semaphore_t</span><br><span class="line">dispatch_semaphore_create(<span class="keyword">long</span> value);</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t sema, dispatch_time_t timeout);</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.申明一个信号量:dispatch_semaphore_t dsema;<br>2.创建一个具有n个并行能力的semaphore:dsema = dispatch_semaphore_create(2); 这里创建一个具备2个并行能力的信号量dsema.<br>3.消耗1个并行能力,例子中当重复调用2次此函数，代码将造成阻塞,阻塞的时间是timeout，实际开发中，可以创建一dispatch_time_t实例，也可使用DISPATCH_TIME_FOREVER,将永远等待知道发送一个signal为止.因此,如果不能确定一定会发送signal，慎用DISPATCH_TIME_FOREVER.<br>4.发送1个signal.</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><hr><ol><li>当前线程执行代码等待其它线程代码执行结束   </li><li>控制异步task并发数量</li></ol><ul><li>实例1: 当前Thread同步执行等待其他Thread返回结果：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> normalizedSemaphore() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread begin..."</span>);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSUInteger</span> index = <span class="number">0</span> ; index &lt; <span class="number">3</span> ; index ++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"other thread message:%lu"</span>,index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread continue..."</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中，创建了一个同时允许并发为1的semaphore,当执行到current thread continue…这条log时,执行被卡住了，等待异步代码块调用dispatch_semaphore_signal(semaphore)继续往下执行.<br>输出结果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392620</span> Semaphore[<span class="number">61812</span>:<span class="number">11351508</span>] current thread begin...</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392751</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392772</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392784</span> Semaphore[<span class="number">61812</span>:<span class="number">11351539</span>] other thread message:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">11.392848</span> Semaphore[<span class="number">61812</span>:<span class="number">11351508</span>] current thread <span class="keyword">continue</span>...</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实例2：控制异步并发数量</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)managerAsynTaskDemo &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *tasks = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span> ; index &lt; <span class="number">10</span>; index ++) &#123;</span><br><span class="line"></span><br><span class="line">[tasks addObject:@(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">[tasks enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> logTaskIndex:[obj unsignedIntegerValue]];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t _dsema;</span><br><span class="line"><span class="keyword">void</span> (^logTaskIndexHandle)(<span class="built_in">NSUInteger</span>) = ^(<span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"task index:%lu"</span>,index);</span><br><span class="line">&#125;;</span><br><span class="line">-(<span class="keyword">void</span>)logTaskIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dsema) _dsema = dispatch_semaphore_create(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">logTaskIndexHandle(index);</span><br><span class="line">dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_semaphore_signal(_dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们产生了10个异步的task,创建了一个并发量为5的信号量dsema,并且在很短的时间内都异步调用logTaskIndex方法,</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579778</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579822</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579838</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579850</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">01.579862</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">02.580413</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">03.585241</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">04.589975</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">05.592348</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">06.596368</span> Semaphore[<span class="number">61846</span>:<span class="number">11355856</span>] task index:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>通过日志看到,前5个任务完成时间间隔非常短，从index=5的task开始每隔1秒钟执行一个task。是因为，打印日志的时候，并没有调用dispatch_semaphore_signal(semaphore);函数，所以只能等待超时时间1秒.<br>如果这里的超时时间设置成了DISPATCH_TIME_FOREVER，请思考一下，最终的打印结果是什么呢？</p><hr><p><strong>推荐一个封装的semaphore函数:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_semaphore_async_handle(dispatch_semaphore_t dsema,dispatch_time_t timeout, <span class="keyword">void</span> (^block)(dispatch_semaphore_t dsema)) &#123;</span><br><span class="line"></span><br><span class="line">dsema = dsema ?: dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">timeout = timeout ?: DISPATCH_TIME_FOREVER;</span><br><span class="line">dispatch_semaphore_wait(dsema, timeout);</span><br><span class="line">block(dsema);</span><br><span class="line">dispatch_semaphore_wait(dsema, timeout);</span><br><span class="line">dispatch_semaphore_signal(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方法如下:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_async_handle(<span class="literal">nil</span>, <span class="number">0</span>, ^(dispatch_semaphore_t dsema)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        some code...</span></span><br><span class="line">dispatch_semaphore_signal(dsema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="note info"><ul><li>推荐一篇不错的GCD文章  <a href="http://www.cocoachina.com/ios/20160225/15422.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160225/15422.html</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
            <tag> dispatch_semaphore </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GCD系列:代码块(dispatch_block)</title>
      <link href="/TECH/2017/03/27/dispatch-block/"/>
      <url>/TECH/2017/03/27/dispatch-block/</url>
      
        <content type="html"><![CDATA[<h3 id="dispatch-block"><a href="#dispatch-block" class="headerlink" title="dispatch_block"></a>dispatch_block</h3><p>dispatch_block系列函数可以对一段代码进行准确控制，最显著的功能就是可以取消执行的代码块，在实际项目开发中非常有用。<br><a id="more"></a></p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_perform(dispatch_block_flags_t flags,DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_cancel(dispatch_block_t block);</span><br><span class="line"><span class="keyword">long</span> dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);</span><br><span class="line"><span class="keyword">void</span> dispatch_block_notify(dispatch_block_t block, <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">dispatch_block_t notification_block);</span><br><span class="line"><span class="keyword">long</span> dispatch_block_testcancel(dispatch_block_t block);</span><br></pre></td></tr></table></figure><h3 id="函数理解"><a href="#函数理解" class="headerlink" title="函数理解"></a>函数理解</h3><hr><p>1.使用dispatch_create创建一个基于GCD的代码块,参数flag，指定代码块的执行环境，block是代码执行体。</p><p><strong>关于flag的定义</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ENUM_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)</span><br><span class="line">DISPATCH_ENUM(dispatch_block_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">DISPATCH_BLOCK_BARRIER = <span class="number">0x01</span>,</span><br><span class="line">DISPATCH_BLOCK_DETACHED = <span class="number">0x02</span>,</span><br><span class="line">DISPATCH_BLOCK_ASSIGN_CURRENT = <span class="number">0x04</span>,</span><br><span class="line">DISPATCH_BLOCK_NO_QOS_CLASS = <span class="number">0x08</span>,</span><br><span class="line">DISPATCH_BLOCK_INHERIT_QOS_CLASS = <span class="number">0x10</span>,</span><br><span class="line">DISPATCH_BLOCK_ENFORCE_QOS_CLASS = <span class="number">0x20</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><ul><li>DISPATCH_BLOCK_BARRIER 保证代码块用于原子性，代码块的代码未执行结束前，下一次调用将进入一个FIFO的等待队列，等待本次代码块执行结束，使用较为安全,若不考虑线程安全可使用DISPATCH_BLOCK_DETACHED，其它flag自行查阅文档。</li></ul><p>2.dispatch_block_perform 没有实际使用过，可能是在当前线程中将闭包的执行体放在指定的flag环境中去执行（待认证）.</p><p>3.dispatch_block_cancel 取消执行某个block，只有当block还未执行前执行cancel有效，block正在执行无法取消.<br>4.dispatch_block_wait 等待block执行，直到timeout后继续往下执行代码,如果timeout=DISPATCH_TIME_FOREVER且block永远不被执行，代码将永远等待。<br>5.dispatch_block_notify(block1,queue,notification_block);注册一个block1的监听，当block1已经完成的时候，会在queue里立即执行notification_block.</p><h3 id="简要Demo："><a href="#简要Demo：" class="headerlink" title="简要Demo："></a>简要Demo：</h3><hr><p><strong>Demo1.简单用法</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_index &lt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">executingBlockOrCancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362374</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362444</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362471</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362491</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">32.362511</span> dispatch_block_oc[<span class="number">60994</span>:<span class="number">11193423</span>] index -&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Demo2.当block在延时函数中使用</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> delayExecutingTask() &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, <span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>), dispatch_get_main_queue(), _dblock);</span><br><span class="line"><span class="comment">//sometimes ,you need cancel the block,use dispatch_block_cancel </span></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Demo3.dispatch_block_waite</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">executingBlockOrCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"wait BEGIN "</span>);</span><br><span class="line">dispatch_block_wait(_dblock, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"wait END "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">27.484894</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] wait BEGIN </span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">29.485858</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] wait END </span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">27</span>:<span class="number">34.487206</span> dispatch_block_oc[<span class="number">61126</span>:<span class="number">11221388</span>] index -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>demo中，在函数createBlockIfNeeded函数中，输出waite BEGIN之后，dispatch_block_waite函数将等待两秒，再输出waite END,之后才执行函数executingBlockOrCancel();</p><p><strong>Demo4.dispatch_block_notify</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t _dblock;</span><br><span class="line"><span class="keyword">void</span> testDispatchBlock() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BEGIN"</span>);</span><br><span class="line">createBlockIfNeeded();</span><br><span class="line">_dblock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> _index;</span><br><span class="line"><span class="keyword">void</span> createBlockIfNeeded() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_dblock) &#123;</span><br><span class="line"></span><br><span class="line">_dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index -&gt; %lu"</span>,_index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_notify(_dblock, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BLOCK EXECUT COMPLETED"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> executingBlockOrCancel() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ++ _index % <span class="number">2</span> ) &#123;</span><br><span class="line"></span><br><span class="line">_dblock();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(_dblock);</span><br><span class="line">_dblock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">30.105075</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] BEGIN</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">35.106363</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] index -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-26</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">35.122696</span> dispatch_block_oc[<span class="number">61245</span>:<span class="number">11242889</span>] BLOCK EXECUT COMPLETED</span><br></pre></td></tr></table></figure><div class="note info"><p>目前，使用了一些Dispatch_block的基本用法，更复杂的在多线程中的用法会陆续记载。 </p></div>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
            <tag> Dispatch block </tag>
            
            <tag> dispatch代码块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GCD系列:队列(dispatch_queue)</title>
      <link href="/TECH/2017/03/20/dispatch_queue/"/>
      <url>/TECH/2017/03/20/dispatch_queue/</url>
      
        <content type="html"><![CDATA[<p><blockquote class="blockquote-center">GCD是基于C封装的函数,具备非常高的效率,<br>在ARC环境下,无须主动管理内存,<br>无须dispatch_retain和dispatch_release,<br>可以将重点关注在业务逻辑上。<br>GCD是基于队列的封装，<strong>下面浅要解析GCD的队列</strong>。<br></blockquote><br><a id="more"></a></p><h3 id="GCD获取线程的方式"><a href="#GCD获取线程的方式" class="headerlink" title="GCD获取线程的方式"></a>GCD获取线程的方式</h3><hr><p>下面是Apple官方提供的获取线程相关函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//获取一个异步线程队列，queue用于指定block执行体所在的队列</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable contex,dispatch_function_t work); </span><br><span class="line"><span class="comment">//跟dispatch_sync类似，只不过接收的是一个dispatch_function_t的函数。</span></span><br><span class="line">- <span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block); </span><br><span class="line"><span class="comment">//获取一个异步线程，接收一个闭包block.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//获取一个异步线程,接收一个函数指针.</span></span><br></pre></td></tr></table></figure><h3 id="GCD获取队列的方式"><a href="#GCD获取队列的方式" class="headerlink" title="GCD获取队列的方式"></a>GCD获取队列的方式</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(); </span><br><span class="line"><span class="comment">//获取主队列</span></span><br><span class="line">- <span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">long</span> identifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags); </span><br><span class="line"><span class="comment">//获取全局队列,由系统分配,分配完成后不可更改,flags是预留字段，传递任何非0值将返回一个NULL值引发异常，identifier指定全局队列的级别，队列的级别如下:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure><ul><li>推荐使用基于QOS_CLASS的属性级别.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QOS_CLASS_USER_INTERACTIVE  </span><br><span class="line"><span class="comment">//最高优先级,用于UI更新等与用户交互的操作.</span></span><br><span class="line">QOS_CLASS_USER_INITIATED        </span><br><span class="line"><span class="comment">//初始化优先级，用于初始化等，等同于DISPATCH_QUEUE_PRIORITY_HIGH</span></span><br><span class="line">QOS_CLASS_DEFAULT                   </span><br><span class="line"><span class="comment">//默认优先级，等同于DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">QOS_CLASS_UTILITY                     </span><br><span class="line"><span class="comment">//低优先级，等同于DISPATCH_QUEUE_PRIORITY_LOW</span></span><br><span class="line">QOS_CLASS_BACKGROUND         </span><br><span class="line"><span class="comment">//后台级,用户用户无法感知的一些数据处理，等同于DISPATCH_QUEUE_PRIORITY_BACKGROUND</span></span><br></pre></td></tr></table></figure><ul><li>自己创建的队列</li></ul><p>GCD中使用<code>dispatch_queue_t dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);</code>来创建一个队列，其中label表示该队列的唯一标识字符串，使用<code>const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);</code>来获取该字符串,参数attr指定队列的执行顺序，有以下参数:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_SERIAL        </span><br><span class="line"><span class="comment">//指定串行（FIFO）队列,等同于传入参数NULL</span></span><br><span class="line">DISPATCH_QUEUE_CONCURRENT    </span><br><span class="line"><span class="comment">//指定并发队列,</span></span><br><span class="line">dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t _Nullable attr,dispatch_qos_class_t qos_class, <span class="keyword">int</span> relative_priority);</span><br><span class="line"><span class="comment">//产生一个基于QOS_CLASS的队列.</span></span><br></pre></td></tr></table></figure><h4 id="dispatch-apply应用"><a href="#dispatch-apply应用" class="headerlink" title="dispatch_apply应用"></a>dispatch_apply应用</h4><hr><p>dispatch_apply必须要结合dispatch_async 或者dispatch_async_f函数一起使用,如果脱离了dispatch_async函数,程序很容易crash，需要特别关注.<br>在指定的queue中去直接执行dispatch_apply(count,queue,block);会直接引发crash!</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue,DISPATCH_NOESCAPE <span class="keyword">void</span> (^block)(size_t));</span><br></pre></td></tr></table></figure><p>应用一个block,循环执行block代码块的次数是iterations次，每次执行的index通过size_t参数传递到block代码块内部<br><em>queue</em>:指定apply函数接收的闭包block执行对应的队列方式,如果是串行队列,跟for循环功能一致，无法达到优化性能的目的。<br>如果是并行队列,则重复执行block的顺序不定,以达到优化性能的目的，下面是2个简单的例子:</p><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatchApply() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义</span></span><br><span class="line"><span class="comment">//Dispatch_apply函数主要的功能是提高性能.</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index....%lu"</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ddddd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:  <strong>可以看出，是并行执行的，达到了apply优化性能的目的.</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856182</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856182</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856205</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130337</span>] index...<span class="number">.1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856240</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856251</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856208</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130335</span>] index...<span class="number">.3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856272</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] index...<span class="number">.6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856278</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130336</span>] index...<span class="number">.8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856280</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130337</span>] index...<span class="number">.7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856293</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130335</span>] index...<span class="number">.9</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">03.856327</span> dispatch_queue[<span class="number">3154</span>:<span class="number">130315</span>] ddddd</span><br></pre></td></tr></table></figure></p><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatchApplySerial() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义</span></span><br><span class="line"><span class="comment">//Dispatch_apply函数主要的功能是提高性能.</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"index....%lu"</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ddddd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472788</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472830</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472842</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472851</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472860</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472868</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472877</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.6</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472885</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.7</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472893</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.8</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472902</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128184</span>] index...<span class="number">.9</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">40.472931</span> dispatch_queue[<span class="number">3096</span>:<span class="number">128223</span>] ddddddddd</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_apply_f(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,<span class="keyword">void</span> (*work)(<span class="keyword">void</span> *_Nullable, size_t));</span><br></pre></td></tr></table></figure><p>跟dispatch_apply功能一致,方法接收一个函数指针.</p><h3 id="void-dispatch-set-target-queue-dispatch-object-t-object-dispatch-queue-t-Nullable-queue"><a href="#void-dispatch-set-target-queue-dispatch-object-t-object-dispatch-queue-t-Nullable-queue" class="headerlink" title="void dispatch_set_target_queue(dispatch_object_t object,dispatch_queue_t _Nullable queue);"></a>void dispatch_set_target_queue(dispatch_object_t object,dispatch_queue_t _Nullable queue);</h3><hr><p>dispatch_set_target_queue可以将object指向的dispatch_object_t对象的队列方式按照参数2的queue的队列方式去执行，它的一大功能就是可以把并发的函数变为串行执行,下面是例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setTargetQueue() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue = dispatch_queue_create(<span class="string">"this.is.serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _concurrcyQueue = dispatch_queue_create(<span class="string">"this.is.concurrency.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">//dispatch_set_target_queue(_concurrcyQueue,_serialQueue);</span></span><br><span class="line"><span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index ++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(_concurrcyQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"11111111111"</span>); &#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(_concurrcyQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"22222222222"</span>); &#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"3333333333"</span>); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果如下：</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853347</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853346</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853367</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853375</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853437</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853475</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853482</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853499</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853507</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853519</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853529</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148069</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853538</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148057</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853546</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853557</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148077</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">42.853585</span> dispatch_queue[<span class="number">3443</span>:<span class="number">148056</span>] <span class="number">3333333333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出，执行结果很混乱，属于并发执行,现在打开set_target_queue注释,得到以下结果:</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510355</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510405</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510423</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510438</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510452</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510465</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510477</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510491</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510501</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510512</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510524</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510536</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510548</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">11111111111</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510560</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">22222222222</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">06.510575</span> dispatch_queue[<span class="number">3470</span>:<span class="number">149395</span>] <span class="number">3333333333</span></span><br><span class="line">这就是典型的dispatch_set_target并发变FIFO串行执行功能.</span><br></pre></td></tr></table></figure></p><h3 id="延时函数-dispatch-after"><a href="#延时函数-dispatch-after" class="headerlink" title="延时函数 dispatch_after"></a>延时函数 dispatch_after</h3><hr><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_after(dispatch_time_t when,<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><ol><li>参数1 when指定block执行的时间，</li><li>参数2 queue指定block执行的队列形式，</li><li>参数3 block指定延时函数接收的闭包.</li></ol><ul><li>void dispatch_after_f(dispatch_time_t when,dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);<br>1.跟dispatch_after功能一样.<br>2.参数3 work指定延时函数接收一个函数指针.</li></ul><h3 id="原子性操作-Dispatch-barrier"><a href="#原子性操作-Dispatch-barrier" class="headerlink" title="原子性操作 Dispatch_barrier"></a>原子性操作 Dispatch_barrier</h3><hr><p>dispatch_barrier在多线程编程中用来保证某个值域的原子性。在多线程操作中，同时对于同一个值的读取不会有问题，但如果同时对一个值进行修改就会产生冲突，此时dispatch_barrier可以很好的解决这个问题，dispatch_barrier就像一个盒子，当盒子内的任务没有出来前，盒子外的任务全部维护到一个队列中。<br><strong>相关函数如下:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">void</span> dispatch_barrier_sync(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//将闭包放入同步环境的queue队列中执行.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//将函数放入同步环境中的queue执行</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">//将闭包放入异步环境的queue队列中执行.</span></span><br><span class="line">- <span class="keyword">void</span> dispatch_barrier_async_f(<span class="built_in">dispatch_queue_t</span> queue,<span class="keyword">void</span> *_Nullable context,dispatch_function_t work);</span><br><span class="line"><span class="comment">//将函数放入异步环境中的queue执行</span></span><br></pre></td></tr></table></figure></p><p><strong>事例代码如下：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *_vars;</span><br><span class="line"><span class="keyword">void</span> setVars(<span class="built_in">NSMutableDictionary</span> *vars) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue = dispatch_queue_create(<span class="string">"this.is.serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_barrier_async(_serialQueue, ^&#123;</span><br><span class="line"></span><br><span class="line">_vars = vars;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为一个队列添加属性和获取属性"><a href="#为一个队列添加属性和获取属性" class="headerlink" title="为一个队列添加属性和获取属性"></a>为一个队列添加属性和获取属性</h3><p>GCD允许给一个队列通过特定的key值关联属性contenxt,有点类似于使用runtime的objc_associated,在类别中给一个类添加属性，用于实际业务需要.<br>当key对应的context发生变化时，会触发C函数destructor.</p><ul><li>void dispatch_queue_set_specific(dispatch_queue_t queue, const void <em>key,void </em>_Nullable context, dispatch_function_t _Nullable destructor);<br>//通过key,为一个queue设置context</li><li>void <em>_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void </em>key);<br>//通过key,从一个queue读取context</li><li>void <em>_Nullable dispatch_get_specific(const void </em>key);<br>//测试当前队列是否是key对应的queue队列（有待认证。。）<br>示例代码如下:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> destructorInvoke(<span class="keyword">const</span> <span class="keyword">void</span> *string) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"destructor -----&gt;%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithUTF8String:(<span class="keyword">char</span> *)string]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue;</span><br><span class="line"><span class="keyword">void</span> dispatchSpecific() &#123;</span><br><span class="line"></span><br><span class="line">setSpecific(<span class="string">@"1"</span>);</span><br><span class="line">setSpecific(<span class="string">@"2"</span>);</span><br><span class="line">setSpecific(<span class="string">@"3"</span>);</span><br><span class="line">setSpecific(<span class="string">@"4"</span>);</span><br><span class="line">setSpecific(<span class="string">@"5"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> setSpecific(<span class="built_in">NSString</span> *context) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_serialQueue) &#123;</span><br><span class="line"></span><br><span class="line">_serialQueue = dispatch_queue_create(<span class="string">"serial.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"set one context"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"set string:%@"</span>,context);</span><br><span class="line">dispatch_queue_set_specific(_serialQueue, key, context.UTF8String, &amp;destructorInvoke);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"context is : %@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:dispatch_queue_get_specific(_serialQueue,key)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026095</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026151</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026166</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026194</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026206</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026212</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026225</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026228</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026241</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026298</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026307</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026315</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] set string:<span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026335</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177340</span>] context is : <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-27</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">25.026338</span> dispatch_queue[<span class="number">3855</span>:<span class="number">177396</span>] destructor -----&gt;<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info"><p>PS：<br>dispatch_queue的知识大致如此，水平有限，如有错误之处，请及时指出 </p></div>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
            <tag> Dispatch queue </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git使用</title>
      <link href="/TECH/2016/07/15/git-useage/"/>
      <url>/TECH/2016/07/15/git-useage/</url>
      
        <content type="html"><![CDATA[<p>该文记录git常用命令和使用方法，记录的博主平时工作所需的一些基础命令，并不能保证完整性和正确性，一般情况下的git使用基本上是满足的，当然如果您有一些特殊的需求，还是需要多查阅<a href="https://git-scm.com/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">git权威指南</a></p><h2 id="git-help-查看帮助文档"><a href="#git-help-查看帮助文档" class="headerlink" title="git help 查看帮助文档"></a>git help 查看帮助文档</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help <span class="keyword">init</span></span><br><span class="line"><span class="comment">//查看git init 的帮助文档命令，其余的类推</span></span><br></pre></td></tr></table></figure><h2 id="git-init-初始化Git仓库"><a href="#git-init-初始化Git仓库" class="headerlink" title="git init 初始化Git仓库"></a>git init 初始化Git仓库</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><code>Create an empty Git repository or reinitialize an existing one</code><br>命令执行后，在当前目录生成一个.git的隐藏目录，内含git仓库需要的资源。<br><a href="https://git-scm.com/docs/git-init" target="_blank" rel="noopener">更多用法</a></p><a id="more"></a>    <h2 id="git-clone-克隆仓库"><a href="#git-clone-克隆仓库" class="headerlink" title="git clone 克隆仓库"></a>git clone 克隆仓库</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">http:</span>/<span class="regexp">/code.site.you.clone  localpath</span></span><br></pre></td></tr></table></figure><p><code>http://code.site.you.clone</code> 更换成你克隆的地址<br><code>localpath</code> 指定你本地克隆的地址，也可省去，默认是克隆到当前路径下<br><a href="https://git-scm.com/docs/git-clone" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-remote-远程仓库"><a href="#git-remote-远程仓库" class="headerlink" title="git remote 远程仓库"></a>git remote 远程仓库</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git remote</span><br><span class="line"><span class="comment">//显示本地已设置的远程仓库的key</span></span><br><span class="line"></span><br><span class="line">git remote -v </span><br><span class="line"><span class="comment">//查看本地仓库指向的远程仓库地址, `-v` == `--verbose`</span></span><br><span class="line"></span><br><span class="line">git remote <span class="keyword">set</span>-url origin https:<span class="comment">//remote.site.com   </span></span><br><span class="line"><span class="comment">//设置远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote add origin https:<span class="comment">//remote.site1.com</span></span><br><span class="line">git remote add bookmark1 https:<span class="comment">//remote.site2.com</span></span><br><span class="line"><span class="comment">//添加远程仓库地址，注意origin bookmark1在本地是唯一的，多个远程地址bookmark不能重复</span></span><br><span class="line"></span><br><span class="line">git remote <span class="keyword">get</span>-url origin</span><br><span class="line">git remote <span class="keyword">get</span>-url bookmark1</span><br><span class="line"><span class="comment">//获取指定bookmark对应的远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote rename bookmark1 bookmark2</span><br><span class="line"><span class="comment">//更改bookmark名</span></span><br><span class="line"></span><br><span class="line">git remote remove bookmark2</span><br><span class="line"><span class="comment">//通过bookmark删除本地远程仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-remote" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-config-配置"><a href="#git-config-配置" class="headerlink" title="git config 配置"></a>git config 配置</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git config --global</span><br><span class="line"><span class="comment">//使用全局配置文件</span></span><br><span class="line"></span><br><span class="line">git config --system</span><br><span class="line"><span class="comment">//使用系统配置文件</span></span><br><span class="line"></span><br><span class="line">git config --local</span><br><span class="line"><span class="comment">//使用本地仓库的配置文件</span></span><br><span class="line"></span><br><span class="line">git config -f filepath</span><br><span class="line"><span class="comment">//使用指定路径下的配置文件</span></span><br><span class="line"></span><br><span class="line">git config -l </span><br><span class="line"><span class="comment">//列出配置文件信息列表</span></span><br><span class="line"></span><br><span class="line">git config --global/--systme/--local user.name <span class="string">"yourname"</span></span><br><span class="line"><span class="comment">//配置全局/系统/本地仓库的commit时的用户名</span></span><br><span class="line"></span><br><span class="line">git config --global/--systme/--local user.email <span class="string">"youremail"</span></span><br><span class="line"><span class="comment">//配置全局/系统/本地仓库的commit时的邮箱</span></span><br></pre></td></tr></table></figure><p>以上内容熟悉后，本地仓库克隆及commit及push基本已经可以了，<br>关于多账号的sshkey问题，请<a href="http://www.kobev5.com/TECH/2017/04/07/Hexo-useage-note/#jump" target="_blank" rel="noopener">左转</a></p><h2 id="git-branch-分支操作"><a href="#git-branch-分支操作" class="headerlink" title="git branch 分支操作"></a>git branch 分支操作</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br><span class="line">git branch --list</span><br><span class="line"><span class="comment">//显示本地已有的分支</span></span><br><span class="line"></span><br><span class="line">git branch newBranch</span><br><span class="line"><span class="comment">//创建本地newBranch分支，不切换当前分支</span></span><br><span class="line"></span><br><span class="line">git branch -a </span><br><span class="line"><span class="comment">//显示本地和远程已有的分支列表</span></span><br><span class="line"></span><br><span class="line">git branch -d theBranch</span><br><span class="line"><span class="comment">//删除theBranch,有两种情况无法删除.</span></span><br><span class="line"><span class="comment">//1.当前分支就是theBranch,你需要切换到其它分支删除theBranch分支；</span></span><br><span class="line"><span class="comment">//2.theBranch分支的代码没有完全合并，首先你需要把代码合并到其它需要合并的分支。</span></span><br><span class="line"></span><br><span class="line">git branch -<span class="type">D</span> theBranch</span><br><span class="line"><span class="comment">//强行删除theBranch,如果当前分支在theBranch,则删除失败。</span></span><br><span class="line"></span><br><span class="line">git push origin :theBranch</span><br><span class="line"><span class="comment">//删除远程theBranch分支</span></span><br><span class="line"></span><br><span class="line">git branch -m theBranch newBranch</span><br><span class="line"><span class="comment">//将theBranch分支 更名为 newBranch分支，git reflog的所有结果也将同时变更</span></span><br><span class="line"></span><br><span class="line">git branch -<span class="type">M</span> theBranch newBranch</span><br><span class="line"><span class="comment">//官方定义，`move/rename a branch, even if target exists`，个人感觉非常不安全的操作方式.</span></span><br><span class="line"></span><br><span class="line">git branch -v</span><br><span class="line"><span class="comment">//打印当前分支最后一次commit的文件列表</span></span><br><span class="line"></span><br><span class="line">git branch --merged</span><br><span class="line"><span class="comment">//仅打印已经合并过的分支列表</span></span><br><span class="line"></span><br><span class="line">git branch --no-merged</span><br><span class="line"><span class="comment">//仅打印未合并的分支列表</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-branch" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-status-代码状态"><a href="#git-status-代码状态" class="headerlink" title="git status 代码状态"></a>git status 代码状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br><span class="line"><span class="comment">//获取working copy的代码状态</span></span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line"><span class="comment">//更简单的展示working copy代码变更</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-status" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-stash-代码暂存"><a href="#git-stash-代码暂存" class="headerlink" title="git stash 代码暂存"></a>git stash 代码暂存</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash </span><br><span class="line"><span class="comment">//将当前分支的代码暂存</span></span><br><span class="line"></span><br><span class="line">git stash pop </span><br><span class="line"><span class="comment">//将最后一次暂存的代码恢复</span></span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment">//列出所有stash列表</span></span><br><span class="line"></span><br><span class="line">git stash drop</span><br><span class="line"><span class="comment">//丢弃最后一次代码暂存内容</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-stash" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-add-添加到本地仓库"><a href="#git-add-添加到本地仓库" class="headerlink" title="git add 添加到本地仓库"></a>git add 添加到本地仓库</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="comment">//将当前变更添加到本地仓库</span></span><br><span class="line"></span><br><span class="line">git add . -v</span><br><span class="line"><span class="comment">//将当前变更添加到本地仓库，并显示细节 `-v` == `--verbose`</span></span><br><span class="line"></span><br><span class="line">git add . -e</span><br><span class="line"><span class="comment">//使用vim打开已变更内容文件，可编辑，:wq保存后添加到本地仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-add" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-rm-删除文件"><a href="#git-rm-删除文件" class="headerlink" title="git rm 删除文件"></a>git rm 删除文件</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git rm filepath</span><br><span class="line"><span class="comment">//删除指定的文件，该文件必须被git标记为tracked的文件</span></span><br><span class="line"></span><br><span class="line">git rm --cached filepath</span><br><span class="line"><span class="comment">//从staged中删除filepath，filepath文件将变更为untracked状态，不会真正将文件删除掉</span></span><br><span class="line"></span><br><span class="line">git rm -f filepath</span><br><span class="line"><span class="comment">//强制将filepath文件删除掉，同时该文件的所有记录也将从git的快照中删除。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-rm" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-commit-提交代码"><a href="#git-commit-提交代码" class="headerlink" title="git commit 提交代码"></a>git commit 提交代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span> </span><br><span class="line"><span class="comment">//直接通过命令行输入提交信息，并将代码提交到本地仓库</span></span><br><span class="line"></span><br><span class="line">git commit</span><br><span class="line"><span class="comment">//使用vim打开本次提交内容，在vim中输入详细的提交信息,一般`git merge`后解决冲突使用这种方式更恰当</span></span><br><span class="line"></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="comment">//使用vim打开上次提交message,`:wq`保存后作为本次提交信息提交到本地仓库</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-commit" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-checkout-分支创建切换"><a href="#git-checkout-分支创建切换" class="headerlink" title="git checkout 分支创建切换"></a>git checkout 分支创建切换</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout anotherBranch</span><br><span class="line"><span class="comment">//从当前分支切换到anotherBranch分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b newBranch</span><br><span class="line"><span class="comment">//创建一个新的分支newBranch并切换到newBranch分支</span></span><br><span class="line"></span><br><span class="line">git checout -<span class="type">B</span> oneBranch</span><br><span class="line"><span class="comment">//创建或重置oneBranch分支并切换到oneBranch分支。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line"><span class="comment">//默认拉取当前所在分支的全程分支代码，并合并到本地分支</span></span><br><span class="line"></span><br><span class="line">git pull origin branch</span><br><span class="line"><span class="comment">//拉取远程变更历史，并合并变更</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-pull" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch </span><br><span class="line"><span class="comment">//拉取仓库默认远端的所有历史</span></span><br><span class="line"></span><br><span class="line">git fetch bookmark</span><br><span class="line"><span class="comment">//拉取仓库指定的bookmark指向的远端所有历史</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase branch</span><br><span class="line"><span class="comment">//将branch分支的代码rebase到当前分支</span></span><br></pre></td></tr></table></figure><p>rebase 和 merge 之间的使用，一直是比较有争议的，博主两个都使用，都遇到一些不好处理的地方，这里不做评价，请自行查阅官方文档。<br><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge branch</span><br><span class="line"><span class="comment">//合并本地branch分支代码到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge bookmark branch</span><br><span class="line"><span class="comment">//合并bookmark所在的远程branch分支代码到当前分支</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git push </span><br><span class="line"><span class="comment">//将已提交至本地仓库代码push到远程分支，默认push到本地分支所对应的远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch</span><br><span class="line"><span class="comment">//将已提交至本地仓库代码push到远程指定的thebranch分支上，如果没有则创建.</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -v</span><br><span class="line"><span class="comment">//功能同上，同时展示更多细节</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -q</span><br><span class="line"><span class="comment">//功能同上，尽可能的省略更多细节 跟`-v`相反</span></span><br><span class="line"></span><br><span class="line">git push origin thebranch -f </span><br><span class="line">git push -f</span><br><span class="line"><span class="comment">//强制push到远程thebranch分支或当前分支所对应的远程分支</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-push" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-mv-文件移动"><a href="#git-mv-文件移动" class="headerlink" title="git mv 文件移动"></a>git mv 文件移动</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br><span class="line"><span class="comment">//将file_from文件更名为file_to</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-mv" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log </span><br><span class="line"><span class="comment">//查看当前分支提交记录,按`q`退出</span></span><br><span class="line"></span><br><span class="line">git log --oneline --decorate</span><br><span class="line"><span class="comment">//查看提交记录，可在头部查看当前HEAD指针指向哪个分支</span></span><br><span class="line"></span><br><span class="line">git log --oneline --decorate --graph --all</span><br><span class="line"><span class="comment">//查看提交记录，并且可以看到当前HEAD指针指向，同时可以看到分支结构图。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line"><span class="comment">//查看tag列表</span></span><br><span class="line"></span><br><span class="line">git tag -l </span><br><span class="line"><span class="comment">//查看tag列表,等同于 git tag --list</span></span><br><span class="line"></span><br><span class="line">git tag -l <span class="string">"v1.2*"</span></span><br><span class="line"><span class="comment">//列出所有tag中包括v1.2前缀的tag列表</span></span><br><span class="line"></span><br><span class="line">git tag -a v1.<span class="number">2</span> -m <span class="string">"your tag descrption”"</span></span><br><span class="line"><span class="comment">//以当前分支创建v1.2tag，tag的信息为“your tag descrption”</span></span><br><span class="line"></span><br><span class="line">git show v1.<span class="number">2</span></span><br><span class="line"><span class="comment">//显示tag v1.2的详细信息</span></span><br><span class="line"></span><br><span class="line">git tag v1.<span class="number">3</span> -lw</span><br><span class="line"><span class="comment">//轻量级的tag,仅仅是打一个tag名，不支持跟-a -s或-m可选参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//将v1.4的tag push到远端仓库</span></span><br><span class="line"></span><br><span class="line">git push origin --tags</span><br><span class="line"><span class="comment">//将一对tagspush到服务端</span></span><br><span class="line"></span><br><span class="line">git tag -d v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//删除v1.4所指的tag</span></span><br><span class="line"></span><br><span class="line">git checkout v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//将当前working copydetach到HEAD状态，显示v1.4tag所指的内容</span></span><br><span class="line"></span><br><span class="line">git checkout -b v14branch v1.<span class="number">4</span></span><br><span class="line"><span class="comment">//以v1.4tag为基准创建一个新的分支v14branch，并切换当前working copy到v14branch</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-tag" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog </span><br><span class="line"><span class="comment">//查看所有分支的提交记录和操作过程，按`q`退出</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-reflog" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff filepath</span><br><span class="line"><span class="comment">//查看filepath下的文件的变更  </span></span><br><span class="line"></span><br><span class="line">git diff branchName filepath</span><br><span class="line"><span class="comment">//当前分支的filepath文件与branchName分支的filepath文件对比 </span></span><br><span class="line"></span><br><span class="line">git diff <span class="type">HEAD</span> filepath</span><br><span class="line"><span class="comment">//查看filepath文件与HEAD所指向的节点的filepath文件对比</span></span><br><span class="line"></span><br><span class="line">git diff commitId filepath</span><br><span class="line"><span class="comment">//当前分支的filepath文件与指定commitId的提交时的filepath文件对比</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-diff" target="_blank" rel="noopener">更多用法</a></p><h2 id="git-reset-代码回滚"><a href="#git-reset-代码回滚" class="headerlink" title="git reset 代码回滚"></a>git reset 代码回滚</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset <span class="type">HEAD</span></span><br><span class="line"><span class="comment">//将当前分支节点指向HEAD节点，其实没任何变化</span></span><br><span class="line"></span><br><span class="line">git reset <span class="type">HEAD</span>~<span class="number">1</span></span><br><span class="line"><span class="comment">//将当前分支指向HEAD节点的上一个节点,并将上一次提交的内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset commitID</span><br><span class="line"><span class="comment">//将当前分支指向commitID指向的节点,并将commit节点之后所提交的所有内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset --soft commitID</span><br><span class="line"><span class="comment">//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容回滚.</span></span><br><span class="line"></span><br><span class="line">git reset --hard commitID</span><br><span class="line"><span class="comment">//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容全部删除.</span></span><br><span class="line"><span class="comment">//如果commitID之后的内容没有被push到远端服务器，那么`git reset --hard`将是非常危险的操作。</span></span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/docs/git-reset" target="_blank" rel="noopener">更多用法</a></p><p>git reset 是具有一定危险性的操作方式，博主希望大家在执行命令前，一定先测试一下命令是否正确，是否能达到你想要的要求，千万不可带着试一试的态度去执行<code>git reset --hard</code>命令，很可能会导致你的代码丢失.</p><h2 id="git-alias"><a href="#git-alias" class="headerlink" title="git alias"></a>git alias</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git co branch </span><br><span class="line"><span class="comment">//等同于  git checkout branch</span></span><br><span class="line"></span><br><span class="line">git config --global alias. br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.unstage 'reset <span class="type">HEAD</span> --'</span><br><span class="line">git unstage filepath</span><br><span class="line"><span class="comment">//等同于 git reset HEAD -- filepath</span></span><br><span class="line"></span><br><span class="line">git config --global alias.last 'log -<span class="number">1</span> <span class="type">HEAD'</span></span><br><span class="line">git last</span><br><span class="line"><span class="comment">//查看最后一次commit日志</span></span><br><span class="line"></span><br><span class="line">git config --global alias.visual '!gitk'</span><br><span class="line"><span class="comment">//maybe you want to run an external command, rather than a Git subcommand. In that case, </span></span><br><span class="line"><span class="comment">//you start the command with a ! character. This is useful if you write your own tools that work with a Git repository.</span></span><br></pre></td></tr></table></figure><h2 id="git-version-查看版本信息"><a href="#git-version-查看版本信息" class="headerlink" title="git version 查看版本信息"></a>git version 查看版本信息</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="comment">//查看当前系统下的git版本信息</span></span><br></pre></td></tr></table></figure><h2 id="git-fsck-–lost-found"><a href="#git-fsck-–lost-found" class="headerlink" title="git fsck –lost-found"></a>git fsck –lost-found</h2><p>找回已经删除的文件，但是存在着add记录，博主未测试<a href="https://www.cnblogs.com/hope-markup/p/6683522.html" target="_blank" rel="noopener">链接</a></p><h2 id="git-ls-files-列出工程的所有忽略文件"><a href="#git-ls-files-列出工程的所有忽略文件" class="headerlink" title="git ls-files 列出工程的所有忽略文件"></a>git ls-files 列出工程的所有忽略文件</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --other --ignored --exclude-standard</span><br></pre></td></tr></table></figure><h2 id="友情推荐"><a href="#友情推荐" class="headerlink" title="友情推荐"></a>友情推荐</h2><ul><li><a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">git学习网站</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac使用笔记</title>
      <link href="/TECH/2016/04/06/Mac%20useage/"/>
      <url>/TECH/2016/04/06/Mac%20useage/</url>
      
        <content type="html"><![CDATA[<h4 id="显示隐藏文件："><a href="#显示隐藏文件：" class="headerlink" title="显示隐藏文件："></a>显示隐藏文件：</h4><div class="note info"><p>显示: <code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br>隐藏: <code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></p><p><strong>restart your mac</strong></p></div><a id="more"></a><h4 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h4><ul><li><a href="https://opensource.apple.com" target="_blank" rel="noopener">MAC OS OpenSource</a></li><li><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" target="_blank" rel="noopener">Mach IPC Interface</a><blockquote class="blockquote-center"><p>xxxx xxxx xxxx </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

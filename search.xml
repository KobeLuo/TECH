<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Splite Obective-C Grammar and Usage]]></title>
    <url>%2Ftech%2F2020%2F07%2F27%2FObjectiveCGrammar%2F</url>
    <content type="text"><![CDATA[前言Apple 开源库Apple 开源代码资源]]></content>
      <categories>
        <category>iOS Develop</category>
      </categories>
      <tags>
        <tag>builtin_expect</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-config]]></title>
    <url>%2Ftech%2F2019%2F09%2F21%2Fgit-config%2F</url>
    <content type="text"><![CDATA[Git账号密码变更后,本地pull或push代码将失败，运行一下命令，再次操作git会提示重新输入密码.1git config --global credential.helper osxkeychain]]></content>
  </entry>
  <entry>
    <title><![CDATA[Monitor Filesystem on Mac OS X]]></title>
    <url>%2Ftech%2F2019%2F01%2F15%2FmonitorFSOnOSX%2F</url>
    <content type="text"><![CDATA[前言最近各大网络磁盘厂商都推出了使用才下载的文件同步功能，类似Dropbox的SmartSync, oneDrive的Store aways等，他们都是实现了远端文件在本地的可视化，但仅仅对部分需要修改或查看的文件提供下载的功能，这样就大大降低了同步过程消耗的时间和流量，仅仅只是下载需要下载的几个文件，这是个非常先进的设计思路，该功能真正体现了云盘的优势和价值。 博主的工作也刚好是云盘相关的业务，因此对于其背后的原理进行了一些探索，得到了一些有用的信息，其中就包括对于文件系统监控的部分知识。 APFS文件系统监控Mac OS X上关于文件系统监控的方法有很多种，博主只是知道其中的一小部分，列举如下: FSEventStreamFSEventStream是苹果官方提供的一套标准的监控文件事件的API,它通过给定的路径和一些参数来控制监控的数据细节，并传入一个callback来接收所有从APFS底层传回的所有事件列表；其关键函数如下：注册函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)start &#123; @autoreleasepool &#123; if (!_watchPath) &#123; return; &#125; self.isExecuting = YES; self.isFinished = NO; CFStringRef watchDir = (__bridge CFStringRef)_watchPath; CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **)&amp;watchDir, 1, NULL); FSEventStreamContext *fseventContext = (FSEventStreamContext *)malloc(sizeof(FSEventStreamContext)); fseventContext-&gt;version = 0; fseventContext-&gt;info = (__bridge void *)(self); fseventContext-&gt;retain = NULL; fseventContext-&gt;release = NULL; fseventContext-&gt;copyDescription = NULL; FSEventStreamCreateFlags flags = kFSEventStreamCreateFlagNone | kFSEventStreamCreateFlagWatchRoot | kFSEventStreamEventFlagItemXattrMod | kFSEventStreamCreateFlagFileEvents; FSEventStreamRef stream = FSEventStreamCreate(NULL, &amp;watchCallback, fseventContext, pathsToWatch, kFSEventStreamEventIdSinceNow, 1.0, flags); _loop = CFRunLoopGetCurrent(); FSEventStreamScheduleWithRunLoop(stream, _loop, kCFRunLoopDefaultMode); FSEventStreamStart(stream); CFRunLoopRun(); FSEventStreamStop(stream); FSEventStreamInvalidate(stream); FSEventStreamRelease(stream); free(fseventContext); CFRelease(pathsToWatch); stream = NULL; fseventContext = NULL; &#125;&#125; 里边有很多的参数都可以按照你的需要去设定，具体怎么设定请参考官方资料。 回调函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void watchCallback(ConstFSEventStreamRef streamRef, void *clientCallBackInfo, size_t numEvents, void *eventPaths, const FSEventStreamEventFlags eventFlags[], const FSEventStreamEventId eventIds[]) &#123; char **paths = eventPaths; for (int i=0; i &lt; numEvents; i ++) &#123; int flag = eventFlags[i]; printf("Change %llu in %s, flags %u\n", eventIds[i], paths[i], flag); if (flag == kFSEventStreamEventFlagNone) &#123; NSLog(@"kFSEventStreamEventFlagNone"); &#125; else if (flag &amp; kFSEventStreamEventFlagMustScanSubDirs) &#123; NSLog(@"kFSEventStreamEventFlagMustScanSubDirs"); &#125; else if (flag &amp; kFSEventStreamEventFlagUserDropped) &#123; NSLog(@"kFSEventStreamEventFlagUserDropped"); &#125; else if (flag &amp; kFSEventStreamEventFlagKernelDropped) &#123; NSLog(@"kFSEventStreamEventFlagKernelDropped"); &#125; else if (flag &amp; kFSEventStreamEventFlagEventIdsWrapped) &#123; NSLog(@"kFSEventStreamEventFlagEventIdsWrapped"); &#125; else if (flag &amp; kFSEventStreamEventFlagHistoryDone) &#123; NSLog(@"kFSEventStreamEventFlagHistoryDone"); &#125; else if (flag &amp; kFSEventStreamEventFlagRootChanged) &#123; NSLog(@"kFSEventStreamEventFlagRootChanged"); &#125; else if (flag &amp; kFSEventStreamEventFlagMount) &#123; NSLog(@"kFSEventStreamEventFlagMount"); &#125; else if (flag &amp; kFSEventStreamEventFlagUnmount) &#123; NSLog(@"kFSEventStreamEventFlagUnmount"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemCreated) &#123; NSLog(@"kFSEventStreamEventFlagItemCreated"); &#125; else if (flag&amp; kFSEventStreamEventFlagItemRemoved) &#123; NSLog(@"kFSEventStreamEventFlagItemRemoved"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemInodeMetaMod) &#123; NSLog(@"kFSEventStreamEventFlagItemInodeMetaMod"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemRenamed) &#123; NSLog(@"kFSEventStreamEventFlagItemRenamed"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemModified) &#123; NSLog(@"kFSEventStreamEventFlagItemModified"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemFinderInfoMod) &#123; NSLog(@"kFSEventStreamEventFlagItemFinderInfoMod"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemChangeOwner) &#123; NSLog(@"kFSEventStreamEventFlagItemChangeOwner"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemXattrMod) &#123; NSLog(@"kFSEventStreamEventFlagItemXattrMod"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemIsFile) &#123; NSLog(@"kFSEventStreamEventFlagItemIsFile"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemIsDir) &#123; NSLog(@"kFSEventStreamEventFlagItemIsDir"); &#125; else if (flag &amp; kFSEventStreamEventFlagItemIsSymlink) &#123; NSLog(@"kFSEventStreamEventFlagItemIsSymlink"); &#125; else &#123; NSLog(@"i don't know!"); &#125; &#125;&#125; 通过回调函数，当文件系统指定的目录及其递归子目录发生变更时，会将对应的事件回调到该函数中，拿到事件后，再继续做后续操作即可。FSEventStream可以跟踪到事件的发送过程，它得定义是当事件发生后，系统回调给注册者，如果要求是事件发生前先得到信息，根据博主的理解，FSEventStream可能无法满足需求。 NSFileCoordinator &amp; NSFilePresenterNSFileCoordinator和NSFilePresenter,可以结合起来使用，以达到监控某个路径文件的事件，它是iCloud开发必须掌握的知识，实现的核心方法如下: 1.创建一个class并遵循协议，2.初始化时，将self添加至NSFileCoordinator中，3.实现NSFilePresenter协议要求的方法，会自动让你填写监控的url和回调函数.4.打印log监控回调事件. 利用NSFilePresenter方式可以监控到文件系统调用open和release时的回调，值得注意的是该系列函数是在文件执行操作之前回调的，这对于实现类似Dropbox的smartSync功能尤为重要，当文件双击时，首先调用该函数，然后启动下载，下载完成后，再调用默认打开进程去打开文件。 PS:文章中提到的FSEventStream和NSFileCoordinate相关的代码均来自:Demo地址， 如果需要可以点击下载代码。 fswatchfswatch是github上的一个开源项目，作者将多种文件监控的方法汇聚到该开源项目中，该项目可以监控来自多个操作系统下的文件事件监控，有兴趣的可以仔细查阅。 fswatch有很多使用方式，其HTML文档地址在这儿,下面是一个经典的使用实例： 1fswatch -xr /path/to/observe 该实例可以监控到指定目录下的文件的变化情况。 Dtrace这是一个神级工具，该工具位于OSX系统/usr/bin/dtrace位置，Instrument绝大部分统计工具其背后统计数据均来自dtrace，由于dtrace直接操作系统内核，所以需要的权限非常高，如果需要使用dtrace来实现一些牛逼的功能，需要更改一些电脑的权限，由于其强大的功能，博主并未深究，实在不敢误人子弟，具体如何使用，还请自行查阅。 疑问目前博主在实现类似Dropbox的smartSync功能使用 sparse file + NSFilePresenter相结合的方式，可以实现功能，但由于NSFilePresenter只能监控某一个文件，如果想要获得指定目录及其递归子目录监控，就需要建立大量的FilePresenter，这在性能上是一个瓶颈，也是一种不太好的方式，目前还未找到更好的解决方案！！！如果有大神有更好的方案，还请赐教一二，博主邮箱地址: kobev5@126.com，也欢迎您给我发邮件探讨关于Mac和iOS上的技术问题。 相关连接 FSEventStream Documentation FSEventStream Blog1 FSEventStream Blog2 NSCoordinator NSFilePresenter fswatch DTrace]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>Monitor FS</tag>
        <tag>监控文件系统</tag>
        <tag>FSEvent</tag>
        <tag>MACF</tag>
        <tag>fswatch</tag>
        <tag>Dtrace</tag>
        <tag>NSFileCoordinate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细数Mac OS/iOS 系统下的锁(lock)]]></title>
    <url>%2Ftech%2F2018%2F11%2F13%2Fos-lock%2F</url>
    <content type="text"><![CDATA[前言最近一段时间，博主都在做代码性能上的一些优化工作，其中就包括了对Mac OS/iOS锁这一部分的优化，趁此机会，也比较系统的测试了各种用户态的锁分别在单个线程和多个线程中的表现。之所以叫用户态的锁，是因为Mach内核部分其实还有一部分内核态的锁，它并不为用户态所开放，我们一般也使用不到。 对同一个锁对象的加解锁必须保持在同一线程执行，如果尝试在不同线程去加解锁将会引发一个运行时的错误。 用户态可用的锁用户态的锁大概有以下: NSLock NSRecusiveLock pthread_mutex_t pthread_mutex_t (recusive) NSCondition NSConditionLock dispatch_semaphore_t os_unfair_lock OS_SPLINK_LOCK @synchronized 内核态的锁而内核态的锁大概有以下几类: lck_mtx_t (互斥体)互斥体是内核内存中的普通变量，是一个机器字大小的整数，但是它要求硬件必须对这些互斥体进行原子(atomic)操作 lck_rw_t （读写锁）一个更高级的互斥体，多个读者可以同时持有锁，而同时只能有一个写者持有该锁。一旦写者持有该锁，其它线程全部都将被阻塞 hw_lock_t （自旋锁）内核态的自旋锁跟用户态的自旋锁(OS_SPLIN_LOCK)并不是一个概念，内核态的自旋锁实际上是为了解决互斥体在频繁的线程切换过程中带来的开销而设计的，当锁被阻塞时，它不会主动交出线程的处理器，而处于一种重复尝试访问锁的忙等状态(busy-wait)，如果当前访问的锁的持有者在它访问几个周期后就放弃持有了，那么它的效率就比较高，省去了很多上下文切换带来的开销，同时，他也可能造成死锁，整个系统可能会因此而停滞。 semaphore (信号量)其实它是一个用户态的锁，Mach中的信号量跟POSIX中的信号量不是一个概念，API也不一样，但是XNU上POSIX信号量的底层是通过Mach信号量来实现的。 关于内核态的同步机制，博主也写了一篇学习笔记,有兴趣可以了解一下。 锁的测试结果针对用户态可用的锁，博主做了一个较为详细的测试，由于使用的是Swift来测试锁的性能，所以在Objective-C中使用的@synchronized并没有在本次测试范围，实际上@synchronized可能是最消耗性能的一种锁。，测试源码在这 简单看以下测试的源代码片段123456789101112131415private func testSemaphore() &#123; for index in 1...repeatTimes &#123; let start = CACurrentMediaTime() sema.wait() //如果要去掉上下文，则注释该print print("index: \(index) ") sema.signal() let end = CACurrentMediaTime() self.recordTimeFor(type: OSLockType.l_Semaphore, time: end - start) &#125;&#125; 以上代码时测试信号量(semaphore)时的核心代码，该段代码有两种测试方式，一种是保留上下文，另外一种则是去掉上下文。 测试结果以下是测试结果的汇总： 测试环境: Mac OS X 10.14.1 Beta (18B57c)， Xcode: Version 9.4.1 (9F2000) 为了全部数据格式统一和去掉上下文的数据更准确，本次测试所有时间单位统一为(us/10),即0.1微妙为单位。 对于单线程的条形图，数据表示每一次加锁和解锁的平均消耗 对于多线程的条形图，数据表示5个线程完成一次加锁和解锁的平均消耗 测试发现OSUnfairLock、semaphore、mutex在各种环境下的表现最稳定，性能差距不大，应该作为锁的首选考虑。 本次测试博主尝试了Repeat不同的次数下，各类锁的耗时情况，发现各类锁的耗时大小顺序并不是固定的，并且差异挺大，仅仅只有单线程且去掉上下文的情况下，测试结果相对稳定，博主猜测大概是因为测试时电脑瞬时性能、CPU使用情况和内核调度的情况有关系，具体原因不敢妄下结论。 测试结果总结测试结果只能从某个方面反映出锁的效率，也许它并不是最准确的结果，它是在特定环境下的真实测试结果。 去掉上下文的测试结果，仅仅只能说明锁本身的实现复杂度和内部的执行效率,它并不能说明锁在实际使用过程中，结合上下文的执行效率，只能作为理论依据。 单线程关于多线程的测试，其核心片段代码如下:12345678class func startThreadCompare(_ testTimes: Int) -&gt; Bool &#123; //initial class let compare = OSLockCompare.init(testTimes: testTimes) //test locks compare.testLocks() return true&#125; 单线程，去掉上下文 从元数据清单表格上可以看出，随着Repeat次数的逐步增大，信号量(Semaphore)的执行效率逐渐变得更优优势，其次是SpinLock，mutex，unfairLock，效率最低的是NSConditionLock至于为什么量级越大，不同的锁在纯粹的加减锁过程中的效率表现会出现差异，有待进一步研究，同时也希望各路大神指点一二。 单线程，保留上下文 在保留上下文的情况下，使用相同的方式去测试单线程下各类锁的性能消耗，得到了一个与去掉上下文完全不同的结果，在仅仅只执行print函数的上下文情况下，发现OSUnfairLock的效率是最高的，其次是mutex、semaphore，最差的是OSSpinLock。 单线程测试发现： 在低频次的加减锁情况下，unfairLock的表现是最好的。 在高频次的加减锁情况下，semaphore的表现是最好的。 同时发现其它的一些大牛写的博文跟这里的结果并不一致，这可能跟测试方式、当前OS系统运行情况等多方面有关系，博主所呈现的是真实的测试数据。 多线程关于多线程的测试，其核心片段代码如下:123456789101112131415161718192021class func startMultiThreadCompare(_ testTimes: Int, threadCount: Int, ci: @escaping invokeBlock) &#123; let compare = OSLockCompare.init(testTimes: testTimes, threadCount) let labelbase = "com.compare.oslock" compare.invoke = ci var subQueues = [DispatchQueue]() for index in 1...threadCount &#123; let label = labelbase + ".\(index)" let seriaQueue = DispatchQueue.init(label: label) seriaQueue.async &#123; compare.testLocks() &#125; subQueues.append(seriaQueue) &#125; compare.queues = subQueues&#125; 测试数据中的多线程的Average Per time是指多个线程同时完成一次加减锁所需要的时间。本例是5个线程 多线程，去掉上下文 通过测试数据可以发现， OSUnfairLock在5个线程同时测试锁的性能时，表现最优越，其平均消耗远低于其它锁，信号量Semaphore次之，mutex紧随其后。 而类似于NSLock,NSConditionLock等更上层的锁在多线程环境下的综合表现则很一般。单线程的锁更多的是作为一种理论而存在，而多线程的测试数据则重要得多，它可能更接近于我们日常开发的需要。 对比单线程，去掉上下文的数据，多线程的耗时多了很多，除了多个线程同时加减锁所耗费的时间外，更多的消耗则用在了线程之间的来回切换。 多线程，保留上下文 在这组综合测试中，OSUnfairLock依然稳居榜首，而mutex和semaphore则排在稍微靠后的位置上，博主猜测可能是因为频繁的线程切换导致的性能损失。 各类锁介绍Mac OS/iOS系统下，用户态的锁使用方式都相对简单，大部分都进行了封装，像NSLock,NSConditionLock,NSRecusiveLock等等，他们只暴露必要的接口，而降实现细节全部隐藏起来由内部函数去处理，这些锁在ARC系统下不需要管理内存；也有一部分较为底层的锁，像pthread_mutex，OSUnfairLock等，但他们的使用都非常的方便简单。 OSSpinLock 不再安全的自旋锁POSIX下的自旋锁的设计原理跟Mach内核的自旋锁原理一致。 苹果的工程师已经证实了OSSpinLock在多种优先级并存的环境中同时访问自旋锁由于优先级反转问题致使持有自旋锁的低优先级线程无法获取CPU资源，导致高优先级线程产生忙等的问题。具体请看ibireme大神这篇文章, 结论是：如果无法确定当前多线程环境的所有线程是同一个优先级，请勿使用OSSpinLock. Apple在OSX 10.12/iOS 10上使用OSUnfairLock替代了OSSpinLock,后面将会提及OSUnfaieLock相关消息及使用方法。 其使用方法如下:123456789101112var splinLock = OS_SPINLOCK_INIT//mark: test locksprivate func testOSSpinlock() &#123; OSSpinLockLock(&amp;splinLock) //code block in here... OSSpinLockUnlock(&amp;splinLock)&#125; OSUnfairLockOSUnfairLock是在Mac OSX 10.12上，Mac给出了替换OSSpinLock的方案，它也是一个底层的锁对象，与OSSpinLock不同的是，他不再是采用忙等的方式，而是睡眠，知道该锁被unlock时被内核唤醒。官方文档还提到 A lock should be considered opaque and implementation-defined. Locks contain thread ownership information that the system may use to attempt to resolve priority inversions.//一个锁应该被是不透明的且有实现的定义，锁对象包括的拥有者信息可以用来解决优先级反转问题。 其使用方式如下:12345678910var unfair = os_unfair_lock()private func testOSUnfairLock() &#123; os_unfair_lock_lock(&amp;unfair) //your code block in here. os_unfair_lock_unlock(&amp;unfair)&#125; pthread_mutex_tpthread_mutex_t是 linux系统下的互斥体，属于底层锁，但它跟Mach内核太的互斥体不是一回事，实际上POSIX下的互斥体的底层实现应该是使用了Mach内核的互斥体(lck_mtx_t),，POSIX下的互斥体文档中有很多函数实现，以下仅简单说明重要的函数使用。12345678910111213141516171819//初始化互斥体public func pthread_attr_init(_: UnsafeMutablePointer&lt;pthread_attr_t&gt;) -&gt; Int32//初始化一个pthread的属性public func pthread_attr_init(_: UnsafeMutablePointer&lt;pthread_attr_t&gt;) -&gt; Int32//销毁一个曾经初始化的属性public func pthread_attr_destroy(_: UnsafeMutablePointer&lt;pthread_attr_t&gt;) -&gt; Int32///设置pthread属性的类型,分别是/// PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_ERRORCHECK/// PTHREAD_MUTEX_DEFAULT, PTHREAD_MUTEX_RECURSIVEpublic func pthread_mutexattr_settype(_: UnsafeMutablePointer&lt;pthread_mutexattr_t&gt;, _: Int32) -&gt; Int32//初始化mutexpublic func pthread_mutex_init(_: UnsafeMutablePointer&lt;pthread_mutex_t&gt;, _: UnsafePointer&lt;pthread_mutexattr_t&gt;?) -&gt; Int32//给指定的mutex加锁public func pthread_mutex_lock(_: UnsafeMutablePointer&lt;pthread_mutex_t&gt;) -&gt; Int32//尝试给指定的mutex加锁，是pthread_mutex_lock的非阻塞版本，返回0则加锁成功，返回其它值以表示当前锁的状态。public func pthread_mutex_trylock(_: UnsafeMutablePointer&lt;pthread_mutex_t&gt;) -&gt; Int32//给指定的mutex解锁，必须入pthread_mutex_lock或成功执行的pthread_mutex_trylock成对出现public func pthread_mutex_unlock(_: UnsafeMutablePointer&lt;pthread_mutex_t&gt;) -&gt; Int32 互斥锁的简单使用12345678910111213var mutex = pthread_mutex_t()//initial mutexpthread_mutex_init(&amp;mutex, nil)private func testPthreadMutex() &#123; pthread_mutex_lock(&amp;mutex) //your code block in here... pthread_mutex_unlock(&amp;mutex)&#125; 递归互斥锁的简单使用1234567891011121314151617var rmutex = pthread_mutex_t()//initial recusive mutexvar attr: pthread_mutexattr_t = pthread_mutexattr_t()pthread_mutexattr_init(&amp;attr)pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE)pthread_mutex_init(&amp;rmutex, &amp;attr)pthread_mutexattr_destroy(&amp;attr)private func testPthreadMutexRecusive() &#123; pthread_mutex_lock(&amp;rmutex) //your code block in here... pthread_mutex_unlock(&amp;rmutex)&#125; Dispatch_semaphore_t信号量跟其它的锁概念有所不同，OS上的锁其本质上都是通过Mach内核中的互斥锁lck_mtx_t根据不同的不同的场景需求而设计的锁，它们大多采用阻塞的方式，少部分使用忙等的方式；而信号量不一致，它是使用信号的方式来控制多线程对于资源的控制，并且信号量可同时释放信号量以保证多个线程同时访问资源，博主曾经写过这篇博客对信号量的用法做了分析。 简单使用方式大致如下:1234567891011let sema: DispatchSemaphore = DispatchSemaphore.init(value: 1)private func testSemaphore() &#123; sema.wait() // your code block in here... sema.signal()&#125; NSLock / NSRecusiveLockNSLock是OS封装的一个上层锁对象，它可以用来间接的读取全局数据或者保护一个临界区域的代码安全，NSLock支持原子操作。 NSLock使用 POSIX线程来实现Lock的行为，当发送一个unlock()消息到NSLock对象，你必须确保之前在同样的线程已经发送了一个lock()消息,对于同一个NSLock锁的实例，如果lock()和unlock()不在同一线程，将引发一个未知的错误（can result in undefined behavior.）。 NSLock无法支持对同一个NSLock的实例连续进行两次及以上的lock()操作，否则会引发死锁，如果需要递归的调用lock()操作，应该是用NSRecusiveLock。 Unlocking a lock that is not locked is considered a programmer error and should be fixed in your code如果你尝试解锁一个未被加锁的NSLock对象，这被认为是程序员的错误，同时输出一个类似的错误在console上。 其简单使用如下:123456789101112131415161718192021let lock = NSLock.init()private func testNSLock() &#123; lock.lock() // your code block in here... lock.unlock()&#125; let rlock = NSRecursiveLock.init()private func testNSRecusiveLock() &#123; rlock.lock() //your code block in here ... rlock.unlock()&#125; NSCondition 官方文档:A condition object acts as both a lock and a checkpoint in a given thread. The lock protects your code while it tests the condition and performs the task triggered by the condition. The checkpoint behavior requires that the condition be true before the thread proceeds with its task. While the condition is not true, the thread blocks. It remains blocked until another thread signals the condition object. 一个Condition对象被用于指定线程的checkpoint或一个锁。 作为锁，可以在当测试某种条件和执行有条件触发的任务时来保护你的代码。作为checkpoint，其要求在线程执行完之前，condition为true,否则该线程将被一直锁住,直到另一个线程发送一个condition对象的信号。 NSCondition官方使用六大步： lock condition对象(condition.lock()) 添加一个bool量的判断，用来指示是否需要继续执行下面受保护的内容 如果bool量为false,则调用wait()或wait(until:)函数，用以锁住当前线程，从这个循环返回后继续回到步骤2，继续测试bool量归纳起来就是 while (boolvalue == false) { condition.wait() } 如果bool量为true了，则继续向下执行受保护的内容。 可选项，更新条件或发送一个condition信号,如果需要的话。(conditon.signal() or condition.broadcast()) 当所有工作完成时，调用 conditon.unlock() 简单的锁使用方式如下:123456789101112131415161718let condition = NSCondition.init()private func testNSCondition() &#123; condition.lock() while( booleanvalue == false) &#123; condition.wait() &#125; //your code in here... condition.unlock() //set the booleanvalue to true in a given time.&#125; 作为上层锁，其内部实现复杂度是要高于底层锁的，因此从性能上开率，除特殊需求外，不建议使用此类锁。 最后再上一段官方的使用心得： Whenever you use a condition object, the first step is to lock the condition. Locking the condition ensures that your predicate and task code are protected from interference by other threads using the same condition. Once you have completed your task, you can set other predicates or signal other conditions based on the needs of your code. You should always set predicates and signal conditions while holding the condition object’s lock. NSConditionLock使用NSConditionLock对象需要确保线程可以在确定的条件下拿到锁，一旦拿到锁并执行了关键区域的代码(被保护的代码)，该线程可以丢弃该锁或者设置新的相关条件，条件是不固定的，根据你的项目而自定。 其简单使用如下:12345678910let clock = NSConditionLock.init()private func testNSConditionLock() &#123; clock.lock() ///your code block in here... clock.unlock() /// clock.try() 尝试加锁，如果成功获取锁，则返回一个正值，否则返回负值， try()成功，才可以unlock(),否则引发一个未知错误。&#125; @synchronized这是Objective-C上面封装的一个上层锁，允许递归使用，其内部处理逻辑相对复杂，因此性能在所有的锁中相对较差，其简单使用方式： 1234@synchronized(lockedObj) &#123; //code block in here...&#125; 更多关于@synchronized的消息请参考以下链接https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/ 相关链接: OSSpinLockhttps://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/ Synchronizedhttps://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3https://reddick-wang.github.io/2017/05/12/iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81/http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>OS Lock</tag>
        <tag>锁</tag>
        <tag>locks</tag>
        <tag>osunfairlock</tag>
        <tag>mutex</tag>
        <tag>semaphore</tag>
        <tag>nslock</tag>
        <tag>NSConditionLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unicode Forms]]></title>
    <url>%2Ftech%2F2018%2F11%2F05%2FStringEncode%2F</url>
    <content type="text"><![CDATA[UnicodeUnicode是计算机领域的一项业界标准，主要为了解决世界上大部分的文字系统的统一编码问题而存在，因此它记录了差不多世界上全部主流的语言的编码集合。Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0[2]，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。 Unicode的设计原则一下内容列举了Unciode设计的十大原则： Universality：提供单一、综合的字符集，编码一切现代与大部分历史文献的字符。 Efficiency：易于处理与分析。 Characters, not glyphs：字符，而不是字形。 Semantics：字符要有良好定义的语义 Plain text：仅限于文本字符 Logical order：默认内存表示是其逻辑序 Unification：把不同语言的同一书写系统（scripts）中相同字符统一起来。 Dynamic composition：附加符号可以动态组合。 Stability：已分配的字符与语义不再改变。 Convertibility：Unicode与其他著名字符集可以精确转换。 Unicode的编码与实现大体上来说，Unicode 编码系统可分为编码方式和实现方式两个层次. 编码方式统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。 上述16位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。 基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。 关于统一码和ISO 10646及UCS的详细关系，见通用字符集。 实现方式Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） Unicode实现方式的主流编码格式有： UTF-8: 是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为邮箱、网页及其他存储或发送文字的应用中，优先采用的编码。 UTF-16: Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区块是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区块的码位来对辅助平面的字符的码位进行编码。 其它的一些编码方式(UTF-7、UTF-32、Punycode、CESU-8、SCSU、GB18030…etc) Unicode FormUnicode主要有四种标准化格式，分别是 标准模式： Form C (Normalization Form C) Form D (Normalization Form D) 兼容模式： Form KC (Normalization Form KC) Form KD (Normalization Form KD) 关于标准化格式的内容,请自行查阅相关资料。 这里着重强调的是，Window使用的是UTF-16作为标注的编码方式，而并未使用Unicode的标准化格式，这就意味着你可以使用两个肉眼看上去一模一样的名字（实际上他们的代码点不一样），而Mac OS系统使用的是UTF-8作为标注编码方式，使用Form C作为标准文本格式，这意味着当你使用两个看上去一样的名字时，OS系统会自动将名字区分开。 由于使用上的操作系统的差异，就导致了有时候从服务端返回的名称看上去跟本地一致，其实不一致的问题。 对于采用了其它标准格式或未使用标准格式的服务端，对于服务端返回的名称，则需要把源字符串转化为标准的FormD格式（Mac OS系统底层默认格式），这样才能正常的比较字符串而当你上传本地文件到服务端时，指定名字也需要反向的使用服务端相应的名字格式。 Mac OS/iOS系统下Foundation库中String的属性代码： 123456789101112//Form D@property (readonly, copy) NSString *decomposedStringWithCanonicalMapping; //Form C@property (readonly, copy) NSString *precomposedStringWithCanonicalMapping;//Form KD@property (readonly, copy) NSString *decomposedStringWithCompatibilityMapping;//Form KC@property (readonly, copy) NSString *precomposedStringWithCompatibilityMapping;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>编码格式</tag>
        <tag>FormC</tag>
        <tag>FormD</tag>
        <tag>unicode Encode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git深入理解]]></title>
    <url>%2Ftech%2F2018%2F10%2F16%2Fgit-deep%2F</url>
    <content type="text"><![CDATA[在git使用这篇文章中，博主列出了常用的git命令和一些使用方法，可以应付日常的开发工作，熟悉git的朋友应该知道，git是一个非常强大的工具，能使用git的常规命令只能说你掌握了git的基本操作，如果还需要更深入的理解git，理解每一条命令背后执行的操作和含义，则需要更为深刻的理解git的运行机制和设计原理，博主对于git的理解也很浅显，该文在谈及git内涵外，也希望有更多的大神能够相互交流，以此增进对git的理解，毕竟进步源于分享嘛 ^.^。 官方文档先列出官方文档: git官网 git常用命令 git权威指南 git仓库介绍关于git仓库基础构造的官方文档如下图 个人理解git仓库代码树的三大状态:Modified： 代表被检出的代码已经被更改，但是还没有添加到暂存区，当然也没有提交到本地仓库；Staged： 代表被检出的代码已经加入了暂存区，它将是你下一次执行commit时提交的变更内容；Committed： 代表你的代码已经安全永久的提交到了本地仓库。 git仓库的三大仓库区git repository 本地仓库，git最重要的部分，存储了一个工程所有的git信息和数据对象。Working Directory 工作目录或工作区，是指当你执行git checkout branch时，存储branch所指的节点的数据和git信息，以提供你增删改查。Staging Area 暂存区 介于检出代码于modified和committed之间的一种状态区域，当你执行git add -a时，将已经modified的代码添加到暂存区，以供下一次commit时将暂存区的变更提交到本地仓库。 从实际项目出发理解1.执行git clone时，将远程代码clone到本地，此时建立了git本地仓库，同时默认工作区是master分支，此时暂存区为空；2.执行git checkout branch时，将branch分支的代码作为工作区，此时工作区从master分支变更为branch分支的代码内容和git信息；3.现在开始增删改查项目的内容；4.当你保存更改时，git将变更的内容标记为modified；5.此时你可能需要提交代码了；执行 git add .将 已更改的代码提交到暂存区，被更改的代码的状态从Modified变更为Staged；6.此时执行命令git commit提交代码，将暂存区的变更快照提交到本地仓库，变更代码状态从Staged变更为Committed，自此你的变更内容将永久安全的存储到本地仓库。 文件的记录过程每个文件在working copy中的状态有两种: tracked(被跟踪) or untracked(未被跟踪)123Remember that each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged.In short, tracked files are files that Git knows about. 被跟踪的文件的文件状态存储在最后一次快照中。 忽略暂存区提交常用的提交流程是：12git add .git commit 命令git add .会将已变更的代码添加到暂存区，然后通过git commit命令将暂存区的快照提交到本地仓库。 这儿还有一种方式提交代码：1git commit -a 它的意思是绕过暂存区，直接将本地被追踪的变更代码提交到本地仓库。相同点： 被追踪的代码都可以直接提交到本地working copy。 不同点： 未被追踪的文件使用后者无法正常提交到本地working copy； 后者的代码将不被添加到暂存区； 前者是较为安全的提交方式，一旦你执行了git reset --hard且未push到远端，那么代码将永久丢失。 git commit 实现假如说当前是一个全新的仓库，并执行以下命令：123git init git add README test.rb LICENSEgit commit -m :The Initial commit of my project: 当你运行git commit创建commit时，git checksums所有的子目录和git仓库中存储这些文件的tree object，同时git创建一个拥有元数据和一个指向root project tree的指针的commit object, 一个commit object其实质上就是一个snapshot. 现在，git仓库包含了五个object,分别是三个文件(README test.rb LICENSE),一个包含跟目录下所有内容和指定name&lt;--&gt;file匹配的列表的tree和一个包含所有提交元数据和指向root true的指针，比较抽象，其实就是三个文件和一个snapshot和一个指向root commit的指针，如下图所示： 此时如果你又提交了几次，那么关于snapshot和指针的关系图，如下所示： 通过上图可以理解到git commit背后运行的规律： 1.git commit并不是存储的变化的文件，而是存储的一些列snapshot和一个带链表结构的指向父指针的指针。2.整个分支结构路由是靠链表结构的指针来运作的，所以当你git branch newbranch时，其实就是创建了一个新的指针，该指针指向当前的指针加上一个branch name,整个过程非常高效快速。3.当通过git checkout commitId去切换到以前的某个分支时，其实是通过指针去挨个找寻父指针，并从父指针指向的snapshot中去将变更挨个恢复，因此你可以感觉到chekout越早的分支速度越慢，git需要遍历更多的指针去恢复变更数据。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>git理解</tag>
        <tag>git</tag>
        <tag>git进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 桥接OC代码重构]]></title>
    <url>%2Ftech%2F2018%2F07%2F05%2Fcodesnapshot%2F</url>
    <content type="text"><![CDATA[博主目前从事NAVER旗下公司的一个虚拟云盘工作开发，开发语言选择了Swift，但是Objective-C中有一些非常方便的API函数在Swift中并没有提供，早起博主直接使用了官方提供的bridge方案来桥接OC部分代码，这样可以方便的使用OC的API，但是这也带来一个性能问题，每次桥接的过程会有一定的耗时； 如果你的项目只是一个普通的信息展示，调用的频次不高，对于性能的优化要求可能就相对较低，但如果你的项目是高频次调用这些API，并且对性能的要求极尽所能，可能你就会对每一行代码的执行效率和耗时做严格的审查，为了提供性能，可能需要将OC函数自己实现，分享部分代码，以供参考。 String ExtensionlastPathComponents123456789101112131415161718public var lastPathComponent: String &#123; let str = self.decomposedStringWithCanonicalMapping if str.count &lt;= 1 &#123; return "" &#125; var name = "" for (_, value) in str.enumerated().reversed() &#123; if value == "/" &#123; if name != "" &#123; break &#125; &#125;else &#123; name = String(value) + name &#125; &#125; return name&#125; 关于String的格式 FormC 和 FormD，请右转 pathComponents123456789101112131415161718192021222324252627282930313233343536373839404142434445public var pathComponents: [String] &#123; var results = [String]() var resultCnt = 0 let str = self let strcnt = str.count var component: String? = nil if str == "/" &#123; results.append("/"); return results &#125; var pre: Character? = nil var pathRepeat = false for (index,value) in str.enumerated() &#123; if value == "/" &#123; if pre == "/" &#123; pathRepeat = true &#125;else &#123; if let com = component &#123; results.append(com); resultCnt += 1 &#125; component = nil &#125; &#125;else &#123; if pathRepeat || (resultCnt == 0 &amp;&amp; pre == "/") &#123; pathRepeat = false; results.append("/"); resultCnt += 1 &#125; if component == nil &#123; component = "" &#125; component?.append(value) &#125; if index == strcnt - 1 &#123; if let com = component &#123; results.append(com) &#125; else &#123; results.append("/") &#125; resultCnt += 1 &#125; pre = value &#125; return results&#125; pathRegularly该函数是一个基础函数，服务于其它函数，服务于其它函数的内部函数。1234567891011121314151617181920private func pathRegularly(of str: String) -&gt; String &#123; var result = "" var prechar: Character = "1" let strcnt = str.count for (index,char) in str.enumerated() &#123; if char != "/" || prechar != "/" &#123; if index == strcnt - 1 &amp;&amp; char == "/" &#123; continue &#125; result.append(char) &#125; prechar = char &#125; if let lastchar = result.last, lastchar == "/" &#123; result.removeLast() &#125; return result&#125; appendingPathComponent1234567891011121314public func appendingPathComponent(path: String?, regularly: Bool = false) -&gt; String &#123; guard let path = path else &#123; return self &#125; var str = self; var name = path if regularly == false &#123; str = pathRegularly(of: self); name = pathRegularly(of: path) &#125; if let firstchar = name.first, firstchar == "/" &#123; return str + name &#125; return str + "/" + name&#125; 点我下载String+path.swift]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>代码共享</tag>
        <tag>片段代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FinderSync插件的使用及调试]]></title>
    <url>%2Ftech%2F2018%2F01%2F15%2FFinderSync%2F</url>
    <content type="text"><![CDATA[FinderSync 简要描述FinderSync是苹果官方提供的一个用来扩展Finder进程的一个插件，它通过监控Finder进程的一个URL组来实现对指定路径下的文件及文件夹的指定事件进行回调，一般它用于文件同步产品或者Finder相关的开发产品，它主要的功能有以下几点: 在Finder上创建一个自定义的右键菜单按钮以及点击后的事件回调 在Finder上创建toolbar快捷按钮及事件回调 自定义sidebarIcon(侧边栏图标) 控制的目录及其递归子目录下的文件和文件夹的图标变化 关于如何是用FinderSync插件博主就不介绍了，很简单，苹果官方文档. 这篇文章的主要目的是介绍如何手动调试FinderSync。 FinderSync调试在早期时间，FinderSync可以通过挂在到Finder进程上直接启动调试，不知道从什么时候开始，直接调试FinderSync时，它会一直处于Waiting to Attch这样一直状态，该进程一直停留在这个状态上，调试FinderSync变成了一件非常恶心的事情，它是独立于主进程(main application)之外的另一个进程，因此你无法直接在主进程中进行断点调试，如果你直接使用NSLog来查看日志也是行不通的，博主这里提供两种调试方式: 记录日志到磁盘通过writeToFile方法将log日志记录到本地指定文件下，通过文件的内容变更来调试FinderSync,这种方式可以通过查看本地日志来完成FinderSync的调试，但效率非常低。 创建额外的FinderSync通过调试发现，如果你的产品项目有多个Target,并且有多个FinderSync插件的时候，通过启动其它的插件可以把你想调试的插件一并启动起来，设置断点后可以直接进行调试，博主并不知道这是为什么，但它的确是可行并有效地，具体处理方法如下: 假设有一个工程叫SmartSync,SmartSync中的主进程叫remoteSync,它用于做远程文件系统同步相关工作。 你可能需要FinderSync插件来完成一些特殊的功能，此时你可以直接从target中选中FinderSync插件，并命名为FinderSync_main，并将它作为remoteSync的插件。 为了调试方便，现在你再创建一个target叫做remoteSync_help,然后再从target中选取一个Findersync插件，命名为FinderSync_helper,将它作为remoteSync_help的插件。 正常启动你的主进程remoteSync，FinderSync_main会跟随主进程自动启动起来，此时你可以在系统进程监视窗口ActivityMonitor中直接把FinderSync_mainKill掉，或者干脆什么也不做。 选中targetFinderSync_helper并运行他，Xcode会让你选择一个app来加载，选择Finder,然后FinderSync_helper会加载起来，并主动将FinderSync_main也附带加载起来。 此时在FinderSync_main的代码中打断点，就可以直接调试了。]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>FinderSync</tag>
        <tag>Finder插件</tag>
        <tag>右键菜单</tag>
        <tag>文件图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS/Mac OS下的 Crash 崩溃分析]]></title>
    <url>%2Ftech%2F2017%2F11%2F16%2FcrashAnalysis%2F</url>
    <content type="text"><![CDATA[就普通的开发而言，普通需求的实现，对于大多数有经验的开发者只是时间问题，其实并没有太大的难度，需求的实现过程则相对轻松； 比较恶心的是发布产品后，遇到的各式奇葩的crash，如果你早有准备，在发布的时候打包了符号文件，那么恭喜你，你还可以通过符号文件来查找崩溃代码，否则，可能就是让bug出现者不停的复现crash，费事费力，可能最终还找不到问题。 符号文件可以通过一定规则将内存地址转换为可读的函数名和一些代码的行号，当你通过Xcode窗口产生的crash时，通常在console中看到的结果是已经被符号化的结果。 一般的崩溃日志都会产生一个线程回溯列表，让你去回溯到指定的crash函数，但是内存警告不会产生线程回溯，官方的解释是低内存发生时不需要线程回溯信息，当发生内存警告时，你必须要重视内存的使用模式并在内存警告发生时的回调函数处理相关的内存泄露。 本文大多数内容来源于Apple的官方文档，地址在这 这篇博文意在如何收集crash，如何分析crash. crash日志的收集常规发布和崩溃信息收集流程先看苹果官方的一张流程图如下： 1.编译器将源码转化成机器码，并生成调试符号文件，用于将机器码回溯成源代码的行号和函数名，关于dsYM的设置可以在BuildSettings搜索DEBUG_INFORMATION_FORMAT设置，这些调试符号存储在二进制文件中或者.dsYM文件中，debug包的应用存储编译后的二进制文件中，而release包的的符号文件则伴随在.dsYM文件中，以便节省包的大小。 调试符号文件和产品二进制包被捆包在一个基于每次编译的一个UUID, 每次编译都会产生一个新的UUID,即使没有任何内容更改。 2.一旦你使用Archive了一个发布包，Xcode会生成一个带有.dsYM的二进制包到Xcode的oranizer下的Archived组。 3.当你上传准备好的二进制包到iTunesConnect时，有一个可选项是让你选择二进制包是否包含.dSYM文件Include app symbols for your application…,为了后续分析问题方便，建议勾选。 4.产品发布后，关于你的产品的任何崩溃都将在用户的手机中创建并存储崩溃信息。 5.用户可以从设备中通过调试发布的产品中直接取到crash报告。如果你的包是“AdHoc”或”Enterprise”企业版发布，那么这种方式将是苹果提供的唯一一种读取崩溃报告的方式。 6.通过Xcode将你取到的.crash文件通过.dSYM文件反解析成崩溃的响应行号和函数名。 7.如果发送崩溃的用户愿意分享崩溃报告的数据，该crash文件将上传至App Store，你可以直接从App Store下载响应的崩溃文件。 8.Apple Store符号化崩溃报告，并将类似的崩溃报告组合在一起，形成一个相似的崩溃报告，这被称为崩溃点。 9.crash崩溃报告也可以在“Organizer的Crash组”中看到。 .dsYM文件的获取方式 通过“Organizer的Archived”找到你发布的相应包，然后右键“ShowInFinder”去找 通过iTunes Connect查找。具体方法是登录iTunesConnect,点击某个APP详情页，从所有的编译版本中找到需要的版本，然后点击下载相应的dSYM文件。 识别崩溃报告是否被符号化一个崩溃报告的符号化状态有三种:“未符号化”、”部分符号化”和”完全符号化”，下面是官方给的符号化示意图: 符号化的方式使用Xcode来符号化崩溃报告对于可直接获取设备的崩溃可以采用以下方式 1.Connect an iOS device to your Mac2.Choose “Devices” from the “Window” menu3.Under the “DEVICES” section in the left column, choose a device4.Click the “View Device Logs” button under the “Device Information” section on the right hand panel5.Drag your crash report onto the left column of the presented panel6.Xcode will automatically symbolicate the crash report and display the results 使用atos来符号化崩溃报告atos命令可以将地址转化成可读的行号和函数名，它可以符号化线程回溯中的一个独立的地址，换言之，他可以做部分符号化，其命令如下:1atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt; 其中 Binary Architecture指的是崩溃设备的架构，在.crash文件顶部的Code Type,mac上一般是x86-64的架构。 简单的使用方法总结如下:1234567891.找到crash文件相应版本号下的dSYM文件2.下载相应.crash文件，并打开。3.找到.crash文件顶部信息中的CodeType并记录,它包含ARM-64, ARM, x86-64, or x86.4.在.crash文件中搜索Binary Images:,并记下你的包对应的 loadAddressloadAddress也可以通过计算得到，等于（symbolicateAddress转10进制 - 偏移量）再转16进制，loadAddress的后三位通常都是000，如果不是，则可能计算有误。5.终端cd到 dSYM文件package contents下的DWARF目录6.执行: atos -arch x86_64 -o appNameInDWARF -l loadAddress symbolicateAdress 分析崩溃报告这部分内容讨论当你获取到.crash文件时，如何分析崩溃信息。 Header信息每一个.crash文件的第一部分内容都是一个格式相同的header信息。12345678910111213141516Incident Identifier: B6FD1E8E-B39F-430B-ADDE-FC3A45ED368CCrashReporter Key: f04e68ec62d3c66057628c9ba9839e30d55937dcHardware Model: iPad6,8Process: TheElements [303]Path: /private/var/containers/Bundle/Application/888C1FA2-3666-4AE2-9E8E-62E2F787DEC1/TheElements.app/TheElementsIdentifier: com.example.apple-samplecode.TheElementsVersion: 1.12Code Type: ARM-64 (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.example.apple-samplecode.TheElements [402] Date/Time: 2016-08-22 10:43:07.5806 -0700Launch Time: 2016-08-22 10:43:01.0293 -0700OS Version: iPhone OS 10.0 (14A5345a)Report Version: 104 相关字段解释如下： Incident Identifier: 每一份.crash文件的唯一标志，不同的崩溃文件的唯一标志不重复 CrashReporter Key: 匿名的设备标志，只要来自该设备的崩溃信息的crashReporterKey都是一样的 Process: 崩溃进程的可执行名称，匹配项目info.plist文件中的CFBundleExecutable key Version: 崩溃进程的版本号，匹配项目info.plist文件中的CFBundleVersion和CFBundleVersionString key Code Type: 崩溃进程所在机器的架构模式，目前的架构模式有ARM-64, ARM, x86-64, x86 OS Version: OS系统版本号 Role: 在进程crash时分配给进程的task role 通过以上Header信息的分析，可以获取到崩溃报告的环境内容，通过符号化可以将符号文件符号到的代码行，这样基本上可以获取到崩溃的大致情况。 Mach 异常信息解析Mach信息解读这里所说的Mach 异常信息解析跟Objective-C/C++的异常信息不同，它表示在内核态的崩溃信息，当然并不是所有的崩溃都来自内核态，但当进程崩溃时，内核态会有一个信息表示在.crash文件中，以供参考 比如以下崩溃信息来自一段未被捕获的OC代码崩溃时的内核态信息1234Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0 而以下是来自一个NULL指针的取消引用引发的崩溃是内核态信息123456Exception Type: EXC_BAD_ACCESS (SIGSEGV)Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000Termination Signal: Segmentation fault: 11Termination Reason: Namespace SIGNAL, Code 0xbTerminating Process: exc handler [0]Triggered by Thread: 0 相关字段解释如下: Exception Code: 当进程崩溃时，崩溃信息被编码成一个或多个64位的十六进制号码，一般情况下这个字段不会展示因为都以更友好的方式展示到了其它字段 Exception Subtype: 对Exception Code的可视化解释 Exception Message: 对Exception Code的附加解释和说明 Exception Note: 对崩溃信息的另一种附加说明，如果该字段包括SIMULATED则说明进程并不是真正的产生了崩溃，而是因为系统要求而被Kill掉，典型的例子:看门狗 Terminal Reason: 进程的内部和外部关键组件在进程发送错误时将进程结束时的原因 Triggered by Thread: 进程崩溃的线程号 常规异常类型解读内存访问错误 (EXC_BAD_ACCESS、 SIGSEGV、SIGBUS)进程尝试访问一个无效的内存地址，或者尝试访问没有权限的访问的内存地址都将引发内存访问错误。当内存访问错误发生时，.crash文件的Exception Subtype1会包含一个kern_return_t的描述错误和读取时的错误内存地址。 以下是调试内存访问错误的提示: 如果objc_msgSend或objc_release接近线程回溯的顶部，那么该进程可能尝试访问一个已经被销毁的内存地址。使用Instrument的Zombies对于定位crash可能是更好的方式 如果gpus_ReturnNotPermittedKillClient接近线程回溯的顶部，那么该进程可能是在后台尝试是用OpenGL或Metal来处理渲染工作，该问题的讨论地址在这 在项目的Secheme中开启Address Sanitizer，当发送内存崩溃时，Xcode会自动提醒 异常退出 (EXC_CRASH、 SIGABRT)进程异常退出最常见的原因就是一个未被捕获的Objective-C/C++的错误和调用了abort()函数App的扩展程序也可能产生类似的崩溃信息，如果太多次的被初始化。如果一个扩展程序在launch过程中Hang了，Exception Subtype将报LAUNCH_HANG，因为扩展程序并没有main（）函数，扩展程序或其独立库的时间花销都在静态构造器和+load()函数中 跟踪陷阱 (EXC_BREAKPOINT、 SIGTRAP)这种异常为附加调试者一个在进程执行体中的某个指定点中断进程的机会，你可以在代码中的某个位置添加函数__builtin_trap()来触发该异常，如果没有调试者被附加，那么进程将结束并生成一个崩溃报告 Apple底层的一些库（如libdispatch）也会使用这种方式在发生致命错误时来捕获进程，附加信息将会在console中体现，也可以在这查询 Swift也经常用到trap机制来引发异常，比如在运行时状态下: 一个不可选的value被置为nil时 类型强转失败时 非法指令 (EXC_BAD_INSTRUCTION、 SIGILL)当进程尝试执行一个非法的或未经定义的指令时，进程可能会尝试通过一个错误的函数指针跳转到一个错误的地址，从而会引发该错误。在Inter处理器上面，ud2操作码会引发一个EXC_BAD_INSTRUCTION异常，但通常也是使用这个trap来达到调试的目的。而Inter处理器上的Swift代码在运行时遇到意外情况将引发该错误 退出Quit （SIGQUIT）进程结束于另一个有权管理其生命周期的进程，因此SIGOUT并不意味这该进程发生了崩溃，但是它也可能以一种可以检测的方式发生异常。 在iOS系统中，如果键盘扩展加载时间过长，主机应用程序将退出键盘扩展。崩溃报告中显示的线程回溯不太可能指向具体的响应代码。而最有可能的情况是，扩展的启动路径上的其他一些代码花了很长时间才完成，但是在时间限制之前已经完成了，并且在退出扩展时将执行代码显示在线程回溯上。您应该对扩展进行概要分析，以便更好地理解启动期间的大部分工作发生在哪里，并将该工作转移到后台线程，或者将其延迟到稍后(在加载扩展之后)。 被杀死 Killed (SIGKILL)说明该进程被系统杀死，并且在崩溃信息的Header的Exception Reason字段中会包含一个命名空间，后面跟随一个代码 The following codes are specific to watchOS:The termination code 0xc51bad01 indicates that a watch app was terminated because it used too much CPU time while performing a background task. To address this issue, optimize the code performing the background task to be more CPU efficient, or decrease the amount of work that the app performs while running in the background.The termination code 0xc51bad02 indicates that a watch app was terminated because it failed to complete a background task within the allocated time. To address this issue, decrease the amount of work that the app performs while running in the background.The termination code 0xc51bad03 indicates that a watch app failed to complete a background task within the allocated time, and the system was sufficiently busy overall that the app may not have received much CPU time with which to perform the background task. Although an app may be able to avoid the issue by reducing the amount of work it performs in the background task, 0xc51bad03 does not indicate that the app did anything wrong. More likely, the app wasn’t able to complete its work because of overall system load. 违反受保护资源 （EXC_GUARD）当访问系统被保留或受保护的资源时，会引发一个EXC_GUARD错误，这些被保留的资源只允许在系统级的私有API才能访问。在较新版本的iOS系统中，当违反了被保留的资源时，会在Exception Subtype和Exception Message字段中以更友好的方式提示给开发者，但是在Mac OS和早起的iOS系统中，该错误信息只会在Exception Code中体现，具体分解如下: as a bitfield which breaks down as follows:[63:61] - Guard Type: The type of the guarded resource. A value of 0x2 indicates the resource is a file descriptor.[60:32] - Flavor: The conditions under which the violation was triggered.If the first (1 &lt;&lt; 0) bit is set, the process attempted to invoke close() on a guarded file descriptor.If the second (1 &lt;&lt; 1) bit is set, the process attempted to invoke dup(), dup2(), or fcntl() with the F_DUPFD or F_DUPFD_CLOEXEC commands on a guarded file descriptor.If the third (1 &lt;&lt; 2) bit is set, the process attempted to send a guarded file descriptor via a socket.If the fifth (1 &lt;&lt; 4) bit is set, the process attempted to write to a guarded file descriptor.[31:0] - File Descriptor: The guarded file descriptor that the process attempted to modify. 超出资源限制 Resource Limit （EXC_RESOURCE）该进程超出了资源消耗限制。这是来自操作系统的一个通知，进程使用了太多的资源。在Exception Subtype字段中列出了准确的信息。如果Exception Note字段包含NON FATAL,CONDITION，那么即使生成了崩溃报告，进程也不会被终止。 如果Exception Subtype为MEMORY代表该进程已经超越了系统准予的内存限制，这可能是终止超量内存使用的前兆。 如果Exception Subtype为WAKEUPS代表该进程中的线程在每秒中被过于频繁的唤醒，这将会强制CPU频繁唤醒，进而影响到电池的使用寿命。 通常情况下，发生这种情况的原因是线程与线程之间的通信(比如使用performSelector:onThread:或dispatch_async)，它们的通信频率远远超出了它们应该有的通信频率，当发生类似情况时，有很多个后台线程都有相同的线程回溯，都指向了调用源。 其他异常类型有一些崩溃报告中，会出现一个未命名的Exception Type,这类型异常会以一个十六进制的值表示，对于类似情况，直接可以从Exception Code中读取该值 0xbaaaaaad 该code不是崩溃信息，它表示该log为整个系统的堆栈快照 0xbad22222 表示该进程是一个VoIP进程，因为过于频繁的resume而发生异常崩溃 0x8badf00d 表示iOS进程因为看门狗超时而崩溃，可能是应用在launch、terminate或响应系统事件时消耗了太多时间而发生的超时，最常见的错误就是在主线程去同步做网络任务而导致的崩溃。 0xc00010ff indicates the app was killed by the operating system in response to a thermal event. This may be due to an issue with the particular device that this crash occurred on, or the environment it was operated in. For tips on making your app run more efficiently, see WWDC session 0xdead10cc 表示死锁，锁被占用着，一直没有放弃锁导致其他线程无法拥有锁，总结起来就是死锁。 0x2bad45ec 表示进程因违反私密信息而被终止 相关连接： 理解和分析应用崩溃报告 dSYM For Fabric]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>崩溃日志</tag>
        <tag>崩溃解析</tag>
        <tag>crash analysis</tag>
        <tag>.dSYM .crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac上建立基于osx fuse的虚拟磁盘]]></title>
    <url>%2Ftech%2F2017%2F07%2F24%2Fosxfuse%2F</url>
    <content type="text"><![CDATA[苹果文件系统AFPS允许用户挂载自己的磁盘(Mount disk)，类似PCloud；也允许用户通过底层API来监控某个文件夹的变化来做同步，类似DropBox，最终目的都是为了实现本地文件与服务端同步来方便人们的工作和生活，博主对于两种方式来同步文件都有一定涉猎，国内外目前针对Mount盘的文献和资料相对较少，博主在工作过程中遇到过很多的坑，共享出来，希望能帮助到有缘人。 OSX FUSE osxfuse介绍关于osx fuse，官方的介绍已经非常详尽了，它主要针对Mac OS文件系统相关的一些操作提供底层的SDK帮助,其主要功能如下: AccessibilityFS LoopbackFS SpotlightFS SSHfsother functions LoopbackFS 将Finder中某个文件夹作为一个独立的文件系统挂载起来; SpotlightFS OS特有的文件系统，连接spotlight使用的，当使用spotlight搜索时，会存储搜索结果; SSHfs 基于SSH的文件系统，用于挂载远程的文件系统。本篇文章将主要介绍使用OSX FUSE来搭建自己的mount盘. osxfuse安装下载osx fuse.dmg，安装后system preferences底部会多一个FUSE item，下载osxfuse.framwork，使用xcode编译后导入到自己自己工程中。 osxfuse结构介绍这里以LookbackFS的swift版本为例介绍fuse的基本概念及用法.需要初始化的参数12345678private var rootPath: String!private lazy var loopFileSystem: LoopbackFS = &#123; return LoopbackFS(rootPath: self.rootPath)&#125;()private lazy var userFileSystem: GMUserFileSystem = &#123; return GMUserFileSystem(delegate: self.loopFileSystem, isThreadSafe: false)&#125;() rootPath 由于LookbackFS是义某个文件夹作为mount的对象，因此rootPath就是本地某个文件夹地址； loopFileSystem该参数作为osx回调的代理，用来接收所有从底层过来的消息； userFileSystem该参数主要作为启动mount的载体，加载mount需要的各项参数。 Mount挂载Mount123456789101112self.rootPath = rootPathaddNotifications()var options: [String] = ["native_xattr", "volname=LoopbackFS"]if let volumeIconPath = Bundle.main.path(forResource: "LoopbackFS",ofType: "icns") &#123; options.insert("volicon=\(volumeIconPath)", at: 0)&#125;userFileSystem.mount(atPath: "/Volumes/loop", withOptions: options) 该片段代码展示了mount 过程的细节，其中options是OSX FUSE指定的某些特定参数，用以实现不同的mount盘功能。而/Volumes/loop则是在macbook上挂载的mount盘的地址,如下图: 图中可以看出，mount盘在Macintosh中的地址是/Volumes/loop,而显示的名字是LoopbackFS。接下来是注册mount结果的通知Notification1234567891011121314151617func addNotifications() &#123; NotificationCenter.default.addObserver(forName: NSNotification.Name(kGMUserFileSystemDidMount), object: nil, queue: nil) &#123; notification in Log.record(info: "Got didMount notification.") //do something. &#125; NotificationCenter.default.addObserver(forName: NSNotification.Name(kGMUserFileSystemMountFailed), object: nil, queue: .main) &#123; notification in Log.record(info: "Got mountFailed notification.") &#125; NotificationCenter.default.addObserver(forName: NSNotification.Name(kGMUserFileSystemDidUnmount), object: nil, queue: nil) &#123; notification in Log.record(info: "Got didUnmount notification.") NSApplication.shared().terminate(nil) &#125;&#125;当mount盘发生状态变更时会调用到该函数中，至此，mount盘就已经挂载到了APFS上。 Event Stream mount盘事件原理前文提到注册mount盘的过程实例化了一个loopFileSystem，以下简称loopInvoke，它主要用来接收从底层过来的所有的事件信息，loopInvoke实现了所有的GMUserFileSystem的代理方法。前文Mount的过程其实质是osxfuse向APFS注册了事件的回调反馈，用户在Mount盘中的任何行为，都将以flag的形式反馈给osx fuse，osx fuse通过解析这些flag并转化成上层可以读懂的事件反馈到loopInvoke实例，如果需要返回值，则将loopInvoke处理后的返回值返回给APFS。 loopInvoke事件详解回调函数列表:先看一下loopInvoke回调事件函数列表如下:函数列表12345678910111213141516171819202122232425262728293031//createoverride func createDirectory(atPath path: String!, attributes: [AnyHashable : Any]! = [:]) throwsoverride func createFile(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!) throws//removeoverride func removeDirectory(atPath path: String!) throwsoverride func removeItem(atPath path: String!) throws//other importantoverride func moveItem(atPath source: String!, toPath destination: String!) throwsoverride func openFile(atPath path: String!, mode: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!) throwsoverride func releaseFile(atPath path: String!, userData: Any!)override func readFile(atPath path: String!, userData: Any!, buffer: UnsafeMutablePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer) -&gt; Int32override func writeFile(atPath path: String!, userData: Any!, buffer: UnsafePointer&lt;Int8&gt;!, size: Int, offset: off_t, error: NSErrorPointer) -&gt; Int32public override func exchangeDataOfItem(atPath path1: String!, withItemAtPath path2: String!) throwsoverride func contentsOfDirectory(atPath path: String!) throws -&gt; [Any]//attributesoverride func finderAttributes(atPath path: String!) throws -&gt; [AnyHashable : Any]override func resourceAttributes(atPath path: String!) throws -&gt; [AnyHashable : Any]override func attributesOfItem(atPath path: String!, userData: Any!) throws -&gt; [AnyHashable : Any]override func attributesOfFileSystem(forPath path: String!) throws -&gt; [AnyHashable : Any]override func setAttributes(_ attributes: [AnyHashable : Any]!, ofItemAtPath path: String!, userData: Any!) throwspublic override func extendedAttributesOfItem(atPath path: Any!) throws -&gt; [Any]public override func value(ofExtendedAttribute name: String!, ofItemAtPath path: String!, position: off_t) throws -&gt; Datapublic override func setExtendedAttribute(_ name: String!, ofItemAtPath path: String!, value: Data!, position: off_t, options: Int32) throwspublic override func removeExtendedAttribute(_ name: String!, ofItemAtPath path: String!) throws//link override func linkItem(atPath path: String!, toPath otherPath: String!) throws//symbolic linkoverride func createSymbolicLink(atPath path: String!, withDestinationPath otherPath: String!) throwsoverride func destinationOfSymbolicLink(atPath path: String!) throws -&gt; String//pre allocoverride func preallocateFile(atPath path: String!, userData: Any!, options: Int32, offset: off_t, length: off_t) throws 哇！！！乱七八糟一大堆函数回调，实际上仔细归类后发现，基本上涵盖了文件操作的所有细节。 这些细节全部由你来掌控！当用户创建一个文件A时，APFS会通过OSX FUSE传递到loopInvoke，告诉你现在收到一个信号是创建了一个A文件，问你怎么办？当APFS需要读取A文件的属性时发出信号向你询问A文件的属性应该是怎样的？当A文件被更名成B文件时，发出信号告诉你有这个事情，至于是否需要更名成B文件或者抛错，由你来决定！ 事件详解以create函数为例来分析一下事件的过程。create file event12345678910111213141516override func createFile(atPath path: String!, attributes: [AnyHashable : Any]! = [:], flags: Int32, userData: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;!) throws &#123; guard let mode = attributes[FileAttributeKey.posixPermissions] as? mode_t else &#123; throw NSError(posixErrorCode: EPERM) &#125; let originalPath = rootPath.appending(path) let fileDescriptor = open((originalPath as NSString).utf8String!, flags, mode) if fileDescriptor &lt; 0 &#123; throw NSError(posixErrorCode: errno) &#125; userData.pointee = NSNumber(value: fileDescriptor)&#125; 参数解析 mode 是open2函数的参数，该参数必须指定为O_CREAT或者O_TMPFILEflag，如果不是这两个参数，那么该参数将被忽略。 以下是官方解释The mode argument specifies the file mode bits be applied when a new file is created.This argument must be supplied when O_CREAT or O_TMPFILE is specified in flags;if neither O_CREAT nor O_TMPFILE is specified, then mode is ignored. originalPath 是指实际文件系统中文件的路劲 flags 用于指定文件创建时的打开方式的集合，官方的解释如下: 以下是官方解释The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.These request opening the file read-only, write-only, or read/write, respectively.In addition, zero or more file creation flags and file status flags can be bitwise-or’d in flags.The file creation flags are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC. fileDescription 是指文件句柄，该文件句柄用于文件操作过程中的唯一标志符。 userData是一个指针，用来存储文件操作过程中用户定义的数据，该字段在实际项目中作用很大。 总结:通过解析create函数，可以看出，APFS将所有的事件都会发送到loopInvoke，至于怎么处理事件，由开发者自己来决定！也正因为如此，Mount开发需要谨慎对待，处理不善，可能就无法正常运转Mount盘。 博客收录入口 st=>start: Start e=>end: End evt=>operation: User Operation op1=>operation: APFS op2=>operation: Fuse parse and generate op3=>operation: loopInvoke handle event cond=>condition: has return value? st->evt->op1->op2->op3(right)->cond cond(yes,top)->op1 cond(no,bottom)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>FUSE</tag>
        <tag>Mount Disk</tag>
        <tag>LookbackFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang study record]]></title>
    <url>%2Ftech%2F2017%2F05%2F22%2FGolangStudy%2F</url>
    <content type="text"><![CDATA[Go相关网站 Go教程中文网 Go安装教程 Go基本命令1234567891011//command line tool 跳转到 hello文件夹下$ cd /path/to/hello//编译该目录下的.go文件，生成可执行文件$ go build //执行可执行文件 $ ./hello //清除可执行文件$ go clean -i Go基础语法变量命名12345678910111213141516var a intvar b stringvar c []float32var d func() boolvar e struct &#123; x int&#125;以上申明方式等同于var ( a int b string ...) 变量初始化 float和int默认值为0; 字符串默认空串; 布尔型默认为bool; 切片、函数、指针变量默认为nil; 初始化的同时赋值 var a int = 10,省略int 编译器将尝试使用右值来推导变量类型 对于float，如果没有指定类型，则尽量提高精度 a := 10,表示声明并赋值，这种方式只适用于未定义的变量，若变量被定义过则会编译失败 a, b := funcA() 表示funcA函数返回两个变量，多变量必须保证左边至少有一个变量是未被定义过的 go支持多重赋值，a := 1 b := 2 a,b = b,a go中匿名变量使用_表示，匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。 go中，byte是uint8，可用来表示传统ASCII的单个字节,rune是int32的别名，用来处理中文日文等复合型字符串。 浮点数float32大概可以提供6个十进制数的精度，float64大概可以提供15个十进制数的精度；通常应该使用float64，因为float32类型误差很容易扩散，它能表示的值并不大，一下代码将出现问题:12var f float32 = 16777216 // 1&lt;&lt;24fmt.Println(f == f+1) // "true" 小数点前面或后面的数字都可以被省略(例如: .717和 1.)，很大（小）的数则最好使用科学计数法，如：12const Avogadro = 6.02214129e23 // 阿伏伽德罗常数const Planck = 6.62606957e-34 // 普朗克常数]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2Ftech%2F2017%2F04%2F07%2FHexo-useage-note%2F</url>
    <content type="text"><![CDATA[博主使用过博客站点有简书、CSDN、博客园、都不同程度的遇到了各种不顺心，MarkDown使用起来也不是特别方便，决定使用GitPages+Hexo来实现编写博客，在完成完成Hexo配置的过程中，踩了不少坑，决定记录下来供大家参考。 个人博客站点:KobeLuo的博客 有关Github仓库 创建一个Github账号，添加一个Repository 注意： 如果想要使用username.github.io这种方式访问你的博客站点，Repository的名字一定要与用户名username相同(username/username.github.io)仓库名创建之后一定像这样:KobeLuo/KobeLuo.github.io 博主曾经在这里踩过坑，导致博客站点报404，一直无法访问 git分支与关系首先理解一个原理: github仓库下至少需要两个分支,这里我们假设为branch1和branch2，如果branch1作为最后静态页面的发布分支，那么branch2就可以作为平时创作的源代码托管分支.branch1不需要你通过git命令push代码，需要通过使用hexo d命令发布到该分支上，前提是本地_config.yml文件已经配置正确，关于本地配置后面会提到branch2是平时写博客过程中，需要使用git命令push源代码的分支,当然你也可以创建更多的源代码托管分支。 通常情况下建的博客站点都是在username.github.io这一层，GitPages会默认master作为hexo的发布分支(上面提到的branch1)，此时settings-&gt;Gitpages-&gt;Source下的branch是不可选择的，在这种情况下，开发分支就必须要使用其它的分支(比如develop分支或其他分支)来存储Hexo主题下的源代码。 如果你的博客站点不是以username.github.io，那么需要按照git发布配置规范配置站点，此时settings-&gt;GitPages-&gt;Source可以选择，通常情况下会有master、gh-pages和/docs供你选择，选择好静态页面的发布分支后,再考虑源代码托管到哪个分支上面。 关于SSHKey首先进入用户目录下的.ssh目录1cd ~/.ssh使用ssh keygen生成一个SSHKey,需要提供一个邮箱1ssh-keygen -t rsa -C "your@email.address" Enter file in which to save the key (/Users/name/.ssh/id_rsa):在此输入id_rsa的名字:id_rsa_name例如:id_rsa_person or id_rsa_company,如果只需要管理一个SSHKey,直接回车会默认生成id_rsa为名的SSHKey配置了名字，后面一路回车结束后，.ssh文件夹里边会包括id_rsa_name、id_rsa_name.pub两个文件，复制id_rsa_pub的内容拷贝到github设置的SSHKey选项中即可完成配置。 多账号管理:如果你有多个Github账号，由于Github账号SSHKey的唯一性，就必须生成多个SSHKey，多个SSHKey只要生成的时候指定的名字不一样即可，假设你生成了两个rsa名为id_rsa_name1和id_rsa_name2,那么你需要在.ssh目录里边创建一个名为config的文件，里边的配置信息如下: 123456789Host kobe_old //所有使用id_rsa_kobe_old.pub作为公钥的github链接中的github.com需要换成kobe_oldHostName github.com User gitIdentityFile ~/.ssh/id_rsa_kobe_oldHost kobe_new //所有使用id_rsa_kobe_new.pub作为公钥的github链接中的github.com需要换成kobe_newHostName github.com User gitIdentityFile ~/.ssh/id_rsa_kobe_new 从远程clone一个仓库时，例如https://github.com:KobeLuo/Kobeluo.github.io/当有多个SSHKey时，需要将github.io改成kobe_new如果该账号使用kobe_new对应的SSHKey更改后的远程地址是https://kobe_new:KobeLuo/Kobeluo.github.io/ 最后使用ssh-add命令将你生成的rsa加入到keychain中,有时候push代码时会报Permission Error,如果你rsa配置正常，也需要执行一下命令:1$ ssh-add -K ~/.ssh/id_rsa_your_name 绑定你的独立域名Github提供gitpages服务可以生成独立二级域名，如非必要，你大可不必自己购买独立域名，如果你购买了自己的域名，就按照以下步骤做: 在静态页面托管分支创建一个CNAME文件，里边放你的独立域名，我的域名是kobeluo.com,因此CNAME中存放的就是kobeluo.com,如果你使用的是hexo模板，每次执行hexo g之后CNAME文件都将被清理掉，解决办法是把CNAME文件存放在本地hexo根目录下的source文件目录中，这样每次hexo d都会生成到发布静态网页分支 配置DNS,在你的DNS配置域名解析页面中配置三组记录他们分别是:我这里使用的是DNSPod,关于如何使用DNSPod请自行查阅。 1234主机记录 记录类型 记录值@ A 192.30.252.153@ A 192.30.252.154www CNAME your.blog.address(我这里是:KobeLuo.github.io) 配置完成之后，等10分钟，等待域名生效。 关于Hexo主题模板 hexo安装请自行查阅hexo官方安装教程 hexo命令hexo有自己独立的一套命令 1234567891011121314hexo new "article"//创建一篇新文章hexo new page "foldername"//创建一个新页面hexo g (hexo generate)//生成静态页面hexo s (hexo server) ,如果报错就执行代码 //链接本地服务器hexo d (hexo deploy)//发布到指定服务器hexo clean //清理静态页面站点，博主使用过一次，会把git配置和hexo搞乱，慎用。npm install --save hexo-filter-flowchart //画流程图的[插件](https://github.com/bubkoo/hexo-filter-flowchart) 执行hexo s可能会报错，如果报错则执行以下命令：1npm install hexo-server --save hexo站点配置hexo根目录下的_config.yml就是站点配置文件，使用编辑软件打开,搜索deploy:,1234deploy: type: git repo: your.blog.site(like:xxx.github.io) branch: gh-pages or master or docs 填写_config.yml配置文件里边的值前都需要添加一个空格，例如 type: git 注意中间有一个空格 配置好这一项后，使用Hexo d就可以把代码deploy到远程仓库了 如果你的Github站点不是以github.io结束的，需要配置root:字段，例如，我的技术博客地址是kobeluo.github.io/tech/ , 那么root:配置就是 /tech/,否则github无法连接CSS和JS 2018.10.12日更新 由于自己懒惰，博客已经停更一年多了，近日再次捡起博客，发现Hexo已经有一些变化，记载于此。首先hexo不再像以前一样安装之后就可以直接使用, hexo是怎么工作的,这篇文章说得非常清楚了。 关于hexohexo分为三个分支： HEXO hexo-cli hexo (hexo-core) hexo plugins 使用命令npm install -g hexo-cli 后可以使用命令hexo generate (hexo g) 和 hexo new但是无法使用hexo s 和hexo d,此时需要使用npm安装启动本地服务和发布的插件,命令是12npm install hexo-server --savenpm install hexo-deployer-git --save安装好插件后,应该就可以使用hexo s了，此时启动本地服务,网页可能弹出Can not GET /XX/XX目录,此时你需要执行1npm install再次执行hexo s,本地网页应该就可以正常显示了. 假设你已经安装好了npm,这里针对已有的博客,需要再次编辑博客的一个完整流程:123456git clone git@github.com:xxxxxxx /A/B/C 将仓库clone到你本地/A/B/C的位置npm install -g hexo-cli 安装hexonpm install npm install hexo-server --save 安装hexo snpm install hexo-deployer-git --save 安装 hexo d如果你本地有多个github账号，因此而产生的权限问题，请左转ssh keyhexo d实质是将你本地public文件夹的内容push到博客_config.yml所指定的分支上去,如果hexo d报权限错误，请一定检查 1234deploy:type: gitrepo: git@github.com:KobeLuo/tech.gitbranch: gh-pages 2019.03.21 日更新 博客管理当博客数量越来越多时，直接从sublime中查找相应文章会变得比较困难，特别在文章名称和title又不一致时会更严重，hexo-admin似乎可以从一定程度上解决这个问题，安装命令：12cd /path/to/your/blog/rootnpm install --save hexo-admin 等待安装完成，执行hexo s，调试地址：http://localhost:4000或http://localhost:4000/some/ 相应的admin地址是：http://localhost:4000/admin/或http://localhost:4000/some/admin/ 在地址后面跟一个admin目录，复制从浏览器打开即可 友情链接 下面是一些记录的hexo站点: 官方站点 https://hexo.io/docs/ hexo建站教程 https://zhuanlan.zhihu.com/p/30836436 http://www.jianshu.com/p/ab21abc31153 http://www.jianshu.com/p/35e197cb1273 https://www.jianshu.com/p/35e197cb1273 hexo 用法教程 https://www.jianshu.com/p/9a56f7c13a79 特别鸣谢:建站过程中，Andrew Liu提供了非常多的帮助，再次感谢！.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD系列:信号量(dispatch_semaphore)]]></title>
    <url>%2Ftech%2F2017%2F03%2F28%2Fdispatch-semaphore%2F</url>
    <content type="text"><![CDATA[信号量有点像具备N个task并行能力的channel,当channel的并行能力未达到上限时可以任意往里边加task，当达到channel上限时，需要task完成才可以加入新的task. 基础函数 123456dispatch_semaphore_tdispatch_semaphore_create(long value);dispatch_semaphore_wait(dispatch_semaphore_t sema, dispatch_time_t timeout);dispatch_semaphore_signal(dispatch_semaphore_t dsema); 1.申明一个信号量:dispatch_semaphore_t dsema;2.创建一个具有n个并行能力的semaphore:dsema = dispatch_semaphore_create(2); 这里创建一个具备2个并行能力的信号量dsema.3.消耗1个并行能力,例子中当重复调用2次此函数，代码将造成阻塞,阻塞的时间是timeout，实际开发中，可以创建一dispatch_time_t实例，也可使用DISPATCH_TIME_FOREVER,将永远等待知道发送一个signal为止.因此,如果不能确定一定会发送signal，慎用DISPATCH_TIME_FOREVER.4.发送1个signal. 主要用途 当前线程执行代码等待其它线程代码执行结束 控制异步task并发数量 实例1: 当前Thread同步执行等待其他Thread返回结果： 12345678910111213141516171819202122232425262728void normalizedSemaphore() &#123; NSLog(@"current thread begin..."); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for(NSUInteger index = 0 ; index &lt; 3 ; index ++) &#123; NSLog(@"other thread message:%lu",index); if (index == 2) &#123; dispatch_semaphore_signal(semaphore); &#125; &#125;&#125;);dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@"current thread continue..."); dispatch_semaphore_signal(semaphore);&#125; 代码中，创建了一个同时允许并发为1的semaphore,当执行到current thread continue…这条log时,执行被卡住了，等待异步代码块调用dispatch_semaphore_signal(semaphore)继续往下执行.输出结果: 12345672017-02-27 00:26:11.392620 Semaphore[61812:11351508] current thread begin...2017-02-27 00:26:11.392751 Semaphore[61812:11351539] other thread message:02017-02-27 00:26:11.392772 Semaphore[61812:11351539] other thread message:12017-02-27 00:26:11.392784 Semaphore[61812:11351539] other thread message:22017-02-27 00:26:11.392848 Semaphore[61812:11351508] current thread continue... 实例2：控制异步并发数量 1234567891011121314151617181920212223242526272829303132-(void)managerAsynTaskDemo &#123; NSMutableArray *tasks = [NSMutableArray new]; for (NSUInteger index = 0 ; index &lt; 10; index ++) &#123; [tasks addObject:@(index)]; &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [tasks enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [self logTaskIndex:[obj unsignedIntegerValue]]; &#125;]; &#125;);&#125;dispatch_semaphore_t _dsema;void (^logTaskIndexHandle)(NSUInteger) = ^(NSUInteger index) &#123; NSLog(@"task index:%lu",index);&#125;;-(void)logTaskIndex:(NSUInteger)index &#123; if (!_dsema) _dsema = dispatch_semaphore_create(5); dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC)); logTaskIndexHandle(index); dispatch_semaphore_wait(_dsema, dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC)); dispatch_semaphore_signal(_dsema);&#125; 这个例子中，我们产生了10个异步的task,创建了一个并发量为5的信号量dsema,并且在很短的时间内都异步调用logTaskIndex方法, 123456789102017-02-27 00:28:01.579778 Semaphore[61846:11355856] task index:02017-02-27 00:28:01.579822 Semaphore[61846:11355856] task index:12017-02-27 00:28:01.579838 Semaphore[61846:11355856] task index:22017-02-27 00:28:01.579850 Semaphore[61846:11355856] task index:32017-02-27 00:28:01.579862 Semaphore[61846:11355856] task index:42017-02-27 00:28:02.580413 Semaphore[61846:11355856] task index:52017-02-27 00:28:03.585241 Semaphore[61846:11355856] task index:62017-02-27 00:28:04.589975 Semaphore[61846:11355856] task index:72017-02-27 00:28:05.592348 Semaphore[61846:11355856] task index:82017-02-27 00:28:06.596368 Semaphore[61846:11355856] task index:9 通过日志看到,前5个任务完成时间间隔非常短，从index=5的task开始每隔1秒钟执行一个task。是因为，打印日志的时候，并没有调用dispatch_semaphore_signal(semaphore);函数，所以只能等待超时时间1秒.如果这里的超时时间设置成了DISPATCH_TIME_FOREVER，请思考一下，最终的打印结果是什么呢？ 推荐一个封装的semaphore函数: 123456789void dispatch_semaphore_async_handle(dispatch_semaphore_t dsema,dispatch_time_t timeout, void (^block)(dispatch_semaphore_t dsema)) &#123; dsema = dsema ?: dispatch_semaphore_create(0); timeout = timeout ?: DISPATCH_TIME_FOREVER; dispatch_semaphore_wait(dsema, timeout); block(dsema); dispatch_semaphore_wait(dsema, timeout); dispatch_semaphore_signal(dsema);&#125; 使用方法如下: 12345dispatch_semaphore_async_handle(nil, 0, ^(dispatch_semaphore_t dsema)&#123; // some code... dispatch_semaphore_signal(dsema);&#125;); 推荐一篇不错的GCD文章 http://www.cocoachina.com/ios/20160225/15422.html]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>dispatch_semaphore</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD系列:代码块(dispatch_block)]]></title>
    <url>%2Ftech%2F2017%2F03%2F27%2Fdispatch-block%2F</url>
    <content type="text"><![CDATA[dispatch_blockdispatch_block系列函数可以对一段代码进行准确控制，最显著的功能就是可以取消执行的代码块，在实际项目开发中非常有用。 基本函数 1234567dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);void dispatch_block_perform(dispatch_block_flags_t flags,DISPATCH_NOESCAPE dispatch_block_t block);void dispatch_block_cancel(dispatch_block_t block); long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout); void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue,dispatch_block_t notification_block);long dispatch_block_testcancel(dispatch_block_t block); 函数理解 1.使用dispatch_create创建一个基于GCD的代码块,参数flag，指定代码块的执行环境，block是代码执行体。 关于flag的定义123456789DISPATCH_ENUM_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)DISPATCH_ENUM(dispatch_block_flags, unsigned longDISPATCH_BLOCK_BARRIER = 0x01,DISPATCH_BLOCK_DETACHED = 0x02,DISPATCH_BLOCK_ASSIGN_CURRENT = 0x04,DISPATCH_BLOCK_NO_QOS_CLASS = 0x08,DISPATCH_BLOCK_INHERIT_QOS_CLASS = 0x10,DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 0x20,); DISPATCH_BLOCK_BARRIER 保证代码块用于原子性，代码块的代码未执行结束前，下一次调用将进入一个FIFO的等待队列，等待本次代码块执行结束，使用较为安全,若不考虑线程安全可使用DISPATCH_BLOCK_DETACHED，其它flag自行查阅文档。 2.dispatch_block_perform 没有实际使用过，可能是在当前线程中将闭包的执行体放在指定的flag环境中去执行（待认证）. 3.dispatch_block_cancel 取消执行某个block，只有当block还未执行前执行cancel有效，block正在执行无法取消.4.dispatch_block_wait 等待block执行，直到timeout后继续往下执行代码,如果timeout=DISPATCH_TIME_FOREVER且block永远不被执行，代码将永远等待。5.dispatch_block_notify(block1,queue,notification_block);注册一个block1的监听，当block1已经完成的时候，会在queue里立即执行notification_block. 简要Demo： Demo1.简单用法 123456789101112131415161718192021222324252627282930313233dispatch_block_t _dblock;void testDispatchBlock() &#123; while (_index &lt; 10) &#123; createBlockIfNeeded(); executingBlockOrCancel(); &#125;&#125;NSInteger _index;void createBlockIfNeeded() &#123; if (!_dblock) &#123; _dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123; NSLog(@"index -&gt; %lu",_index); &#125;);&#125;&#125;void executingBlockOrCancel() &#123; if ( ++ _index % 2 ) &#123; _dblock(); &#125;else &#123; dispatch_block_cancel(_dblock); _dblock = nil; &#125;&#125; 输出结果: 123452017-02-26 23:15:32.362374 dispatch_block_oc[60994:11193423] index -&gt; 12017-02-26 23:15:32.362444 dispatch_block_oc[60994:11193423] index -&gt; 32017-02-26 23:15:32.362471 dispatch_block_oc[60994:11193423] index -&gt; 52017-02-26 23:15:32.362491 dispatch_block_oc[60994:11193423] index -&gt; 72017-02-26 23:15:32.362511 dispatch_block_oc[60994:11193423] index -&gt; 9 Demo2.当block在延时函数中使用 12345678void delayExecutingTask() &#123; createBlockIfNeeded(); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_main_queue(), _dblock); //sometimes ,you need cancel the block,use dispatch_block_cancel dispatch_block_cancel(_dblock);&#125; Demo3.dispatch_block_waite 1234567891011121314151617181920212223242526272829303132333435dispatch_block_t _dblock;void testDispatchBlock() &#123; createBlockIfNeeded(); executingBlockOrCancel();&#125;NSInteger _index;void createBlockIfNeeded() &#123; if (!_dblock) &#123; _dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"index -&gt; %lu",_index); &#125;); NSLog(@"wait BEGIN "); dispatch_block_wait(_dblock, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC)); NSLog(@"wait END "); &#125;&#125;void executingBlockOrCancel() &#123; if ( ++ _index % 2 ) &#123; _dblock(); &#125;else &#123; dispatch_block_cancel(_dblock); _dblock = nil; &#125;&#125; 输出结果:1232017-02-26 23:27:27.484894 dispatch_block_oc[61126:11221388] wait BEGIN 2017-02-26 23:27:29.485858 dispatch_block_oc[61126:11221388] wait END 2017-02-26 23:27:34.487206 dispatch_block_oc[61126:11221388] index -&gt; 1 demo中，在函数createBlockIfNeeded函数中，输出waite BEGIN之后，dispatch_block_waite函数将等待两秒，再输出waite END,之后才执行函数executingBlockOrCancel(); Demo4.dispatch_block_notify 12345678910111213141516171819202122232425262728293031323334353637dispatch_block_t _dblock;void testDispatchBlock() &#123; NSLog(@"BEGIN"); createBlockIfNeeded(); _dblock();&#125;NSInteger _index;void createBlockIfNeeded() &#123; if (!_dblock) &#123; _dblock = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"index -&gt; %lu",_index); &#125;); dispatch_block_notify(_dblock, dispatch_get_main_queue(), ^&#123; NSLog(@"BLOCK EXECUT COMPLETED"); &#125;); &#125;&#125;void executingBlockOrCancel() &#123; if ( ++ _index % 2 ) &#123; _dblock(); &#125;else &#123; dispatch_block_cancel(_dblock); _dblock = nil; &#125;&#125; 输出结果: 1232017-02-26 23:36:30.105075 dispatch_block_oc[61245:11242889] BEGIN2017-02-26 23:36:35.106363 dispatch_block_oc[61245:11242889] index -&gt; 02017-02-26 23:36:35.122696 dispatch_block_oc[61245:11242889] BLOCK EXECUT COMPLETED 目前，使用了一些Dispatch_block的基本用法，更复杂的在多线程中的用法会陆续记载。]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Dispatch block</tag>
        <tag>dispatch代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD系列:队列(dispatch_queue)]]></title>
    <url>%2Ftech%2F2017%2F03%2F20%2Fdispatch_queue%2F</url>
    <content type="text"><![CDATA[GCD是基于C封装的函数,具备非常高的效率,在ARC环境下,无须主动管理内存,无须dispatch_retain和dispatch_release,可以将重点关注在业务逻辑上。GCD是基于队列的封装，下面浅要解析GCD的队列。 GCD获取线程的方式 下面是Apple官方提供的获取线程相关函数 12345678- void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);//获取一个异步线程队列，queue用于指定block执行体所在的队列- void dispatch_sync_f(dispatch_queue_t queue,void *_Nullable contex,dispatch_function_t work); //跟dispatch_sync类似，只不过接收的是一个dispatch_function_t的函数。- void dispatch_async(dispatch_queue_t queue, dispatch_block_t block); //获取一个异步线程，接收一个闭包block.- void dispatch_async_f(dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);//获取一个异步线程,接收一个函数指针. GCD获取队列的方式 123456789- dispatch_queue_t dispatch_get_main_queue(); //获取主队列- dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags); //获取全局队列,由系统分配,分配完成后不可更改,flags是预留字段，传递任何非0值将返回一个NULL值引发异常，identifier指定全局队列的级别，队列的级别如下:#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 推荐使用基于QOS_CLASS的属性级别. 12345678910QOS_CLASS_USER_INTERACTIVE //最高优先级,用于UI更新等与用户交互的操作.QOS_CLASS_USER_INITIATED //初始化优先级，用于初始化等，等同于DISPATCH_QUEUE_PRIORITY_HIGHQOS_CLASS_DEFAULT //默认优先级，等同于DISPATCH_QUEUE_PRIORITY_DEFAULTQOS_CLASS_UTILITY //低优先级，等同于DISPATCH_QUEUE_PRIORITY_LOWQOS_CLASS_BACKGROUND //后台级,用户用户无法感知的一些数据处理，等同于DISPATCH_QUEUE_PRIORITY_BACKGROUND 自己创建的队列 GCD中使用dispatch_queue_t dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);来创建一个队列，其中label表示该队列的唯一标识字符串，使用const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);来获取该字符串,参数attr指定队列的执行顺序，有以下参数: 123456DISPATCH_QUEUE_SERIAL //指定串行（FIFO）队列,等同于传入参数NULLDISPATCH_QUEUE_CONCURRENT //指定并发队列,dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t _Nullable attr,dispatch_qos_class_t qos_class, int relative_priority);//产生一个基于QOS_CLASS的队列. dispatch_apply应用 dispatch_apply必须要结合dispatch_async 或者dispatch_async_f函数一起使用,如果脱离了dispatch_async函数,程序很容易crash，需要特别关注.在指定的queue中去直接执行dispatch_apply(count,queue,block);会直接引发crash! 1- void dispatch_apply(size_t iterations, dispatch_queue_t queue,DISPATCH_NOESCAPE void (^block)(size_t)); 应用一个block,循环执行block代码块的次数是iterations次，每次执行的index通过size_t参数传递到block代码块内部queue:指定apply函数接收的闭包block执行对应的队列方式,如果是串行队列,跟for循环功能一致，无法达到优化性能的目的。如果是并行队列,则重复执行block的顺序不定,以达到优化性能的目的，下面是2个简单的例子: case 1:12345678910111213141516void dispatchApply() &#123;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_async(dispatch_get_main_queue(), ^&#123; //执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义 //Dispatch_apply函数主要的功能是提高性能. dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@"index....%lu",index); &#125;); //dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行. NSLog(@"ddddd"); &#125;);&#125; 输出结果: 可以看出，是并行执行的，达到了apply优化性能的目的.12345678910112017-02-27 14:56:03.856182 dispatch_queue[3154:130315] index....02017-02-27 14:56:03.856182 dispatch_queue[3154:130336] index....22017-02-27 14:56:03.856205 dispatch_queue[3154:130337] index....12017-02-27 14:56:03.856240 dispatch_queue[3154:130315] index....42017-02-27 14:56:03.856251 dispatch_queue[3154:130336] index....52017-02-27 14:56:03.856208 dispatch_queue[3154:130335] index....32017-02-27 14:56:03.856272 dispatch_queue[3154:130315] index....62017-02-27 14:56:03.856278 dispatch_queue[3154:130336] index....82017-02-27 14:56:03.856280 dispatch_queue[3154:130337] index....72017-02-27 14:56:03.856293 dispatch_queue[3154:130335] index....92017-02-27 14:56:03.856327 dispatch_queue[3154:130315] ddddd case 2:1234567891011121314151617181920212223242526272829void dispatchApplySerial() &#123; dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //执行的顺序取决于queue是串行还是并行，如果使用串行就跟for循环一样,没有意义 //Dispatch_apply函数主要的功能是提高性能. dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@"index....%lu",index); &#125;); //dispatch_apply是串行执行，知道10次invoke complete的时候，才继续往下执行. NSLog(@"ddddd"); &#125;);&#125;输出结果:2017-02-27 14:53:40.472788 dispatch_queue[3096:128184] index....02017-02-27 14:53:40.472830 dispatch_queue[3096:128184] index....12017-02-27 14:53:40.472842 dispatch_queue[3096:128184] index....22017-02-27 14:53:40.472851 dispatch_queue[3096:128184] index....32017-02-27 14:53:40.472860 dispatch_queue[3096:128184] index....42017-02-27 14:53:40.472868 dispatch_queue[3096:128184] index....52017-02-27 14:53:40.472877 dispatch_queue[3096:128184] index....62017-02-27 14:53:40.472885 dispatch_queue[3096:128184] index....72017-02-27 14:53:40.472893 dispatch_queue[3096:128184] index....82017-02-27 14:53:40.472902 dispatch_queue[3096:128184] index....92017-02-27 14:53:40.472931 dispatch_queue[3096:128223] ddddddddd 1- void dispatch_apply_f(size_t iterations, dispatch_queue_t queue,void *_Nullable context,void (*work)(void *_Nullable, size_t)); 跟dispatch_apply功能一致,方法接收一个函数指针. void dispatch_set_target_queue(dispatch_object_t object,dispatch_queue_t _Nullable queue); dispatch_set_target_queue可以将object指向的dispatch_object_t对象的队列方式按照参数2的queue的队列方式去执行，它的一大功能就是可以把并发的函数变为串行执行,下面是例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void setTargetQueue() &#123; dispatch_queue_t _serialQueue = dispatch_queue_create("this.is.serial.queue", DISPATCH_QUEUE_SERIAL); dispatch_queue_t _concurrcyQueue = dispatch_queue_create("this.is.concurrency.queue", DISPATCH_QUEUE_CONCURRENT); // dispatch_set_target_queue(_concurrcyQueue,_serialQueue); NSInteger index = 0; while (index ++ &lt; 5) &#123; dispatch_async(_concurrcyQueue, ^&#123; NSLog(@"11111111111"); &#125;); dispatch_async(_concurrcyQueue, ^&#123; NSLog(@"22222222222"); &#125;); dispatch_async(_serialQueue, ^&#123; NSLog(@"3333333333"); &#125;); &#125;&#125;//执行的结果如下：2017-02-27 15:22:42.853347 dispatch_queue[3443:148056] 33333333332017-02-27 15:22:42.853346 dispatch_queue[3443:148077] 111111111112017-02-27 15:22:42.853367 dispatch_queue[3443:148069] 111111111112017-02-27 15:22:42.853375 dispatch_queue[3443:148057] 222222222222017-02-27 15:22:42.853437 dispatch_queue[3443:148056] 33333333332017-02-27 15:22:42.853475 dispatch_queue[3443:148077] 222222222222017-02-27 15:22:42.853482 dispatch_queue[3443:148069] 111111111112017-02-27 15:22:42.853499 dispatch_queue[3443:148057] 222222222222017-02-27 15:22:42.853507 dispatch_queue[3443:148056] 33333333332017-02-27 15:22:42.853519 dispatch_queue[3443:148077] 111111111112017-02-27 15:22:42.853529 dispatch_queue[3443:148069] 222222222222017-02-27 15:22:42.853538 dispatch_queue[3443:148057] 111111111112017-02-27 15:22:42.853546 dispatch_queue[3443:148056] 33333333332017-02-27 15:22:42.853557 dispatch_queue[3443:148077] 222222222222017-02-27 15:22:42.853585 dispatch_queue[3443:148056] 3333333333//可以看出，执行结果很混乱，属于并发执行,现在打开set_target_queue注释,得到以下结果:2017-02-27 15:25:06.510355 dispatch_queue[3470:149395] 111111111112017-02-27 15:25:06.510405 dispatch_queue[3470:149395] 222222222222017-02-27 15:25:06.510423 dispatch_queue[3470:149395] 33333333332017-02-27 15:25:06.510438 dispatch_queue[3470:149395] 111111111112017-02-27 15:25:06.510452 dispatch_queue[3470:149395] 222222222222017-02-27 15:25:06.510465 dispatch_queue[3470:149395] 33333333332017-02-27 15:25:06.510477 dispatch_queue[3470:149395] 111111111112017-02-27 15:25:06.510491 dispatch_queue[3470:149395] 222222222222017-02-27 15:25:06.510501 dispatch_queue[3470:149395] 33333333332017-02-27 15:25:06.510512 dispatch_queue[3470:149395] 111111111112017-02-27 15:25:06.510524 dispatch_queue[3470:149395] 222222222222017-02-27 15:25:06.510536 dispatch_queue[3470:149395] 33333333332017-02-27 15:25:06.510548 dispatch_queue[3470:149395] 111111111112017-02-27 15:25:06.510560 dispatch_queue[3470:149395] 222222222222017-02-27 15:25:06.510575 dispatch_queue[3470:149395] 3333333333这就是典型的dispatch_set_target并发变FIFO串行执行功能. 延时函数 dispatch_after 1- void dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block); 参数1 when指定block执行的时间， 参数2 queue指定block执行的队列形式， 参数3 block指定延时函数接收的闭包. void dispatch_after_f(dispatch_time_t when,dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);1.跟dispatch_after功能一样.2.参数3 work指定延时函数接收一个函数指针. 原子性操作 Dispatch_barrier dispatch_barrier在多线程编程中用来保证某个值域的原子性。在多线程操作中，同时对于同一个值的读取不会有问题，但如果同时对一个值进行修改就会产生冲突，此时dispatch_barrier可以很好的解决这个问题，dispatch_barrier就像一个盒子，当盒子内的任务没有出来前，盒子外的任务全部维护到一个队列中。相关函数如下:12345678- void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);//将闭包放入同步环境的queue队列中执行.- void dispatch_barrier_sync_f(dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);//将函数放入同步环境中的queue执行- void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);//将闭包放入异步环境的queue队列中执行.- void dispatch_barrier_async_f(dispatch_queue_t queue,void *_Nullable context,dispatch_function_t work);//将函数放入异步环境中的queue执行 事例代码如下： 12345678910NSMutableDictionary *_vars;void setVars(NSMutableDictionary *vars) &#123; dispatch_queue_t _serialQueue = dispatch_queue_create("this.is.serial.queue", DISPATCH_QUEUE_SERIAL); dispatch_barrier_async(_serialQueue, ^&#123; _vars = vars; &#125;);&#125; 为一个队列添加属性和获取属性GCD允许给一个队列通过特定的key值关联属性contenxt,有点类似于使用runtime的objc_associated,在类别中给一个类添加属性，用于实际业务需要.当key对应的context发生变化时，会触发C函数destructor. void dispatch_queue_set_specific(dispatch_queue_t queue, const void key,void _Nullable context, dispatch_function_t _Nullable destructor);//通过key,为一个queue设置context void _Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void key);//通过key,从一个queue读取context void _Nullable dispatch_get_specific(const void key);//测试当前队列是否是key对应的queue队列（有待认证。。）示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142void destructorInvoke(const void *string) &#123; NSLog(@"destructor -----&gt;%@",[[NSString alloc] initWithUTF8String:(char *)string]);&#125;dispatch_queue_t _serialQueue;void dispatchSpecific() &#123; setSpecific(@"1"); setSpecific(@"2"); setSpecific(@"3"); setSpecific(@"4"); setSpecific(@"5");&#125;void setSpecific(NSString *context) &#123; if (!_serialQueue) &#123; _serialQueue = dispatch_queue_create("serial.queue", DISPATCH_QUEUE_SERIAL); &#125; const char *key = "set one context"; NSLog(@"set string:%@",context); dispatch_queue_set_specific(_serialQueue, key, context.UTF8String, &amp;destructorInvoke); NSLog(@"context is : %@",[NSString stringWithUTF8String:dispatch_queue_get_specific(_serialQueue,key)]);&#125;输出结果:2017-02-27 16:14:25.026095 dispatch_queue[3855:177340] set string:12017-02-27 16:14:25.026151 dispatch_queue[3855:177340] context is : 12017-02-27 16:14:25.026166 dispatch_queue[3855:177340] set string:22017-02-27 16:14:25.026194 dispatch_queue[3855:177340] context is : 22017-02-27 16:14:25.026206 dispatch_queue[3855:177340] set string:32017-02-27 16:14:25.026212 dispatch_queue[3855:177396] destructor -----&gt;12017-02-27 16:14:25.026225 dispatch_queue[3855:177340] context is : 32017-02-27 16:14:25.026228 dispatch_queue[3855:177396] destructor -----&gt;22017-02-27 16:14:25.026241 dispatch_queue[3855:177340] set string:42017-02-27 16:14:25.026298 dispatch_queue[3855:177340] context is : 42017-02-27 16:14:25.026307 dispatch_queue[3855:177396] destructor -----&gt;32017-02-27 16:14:25.026315 dispatch_queue[3855:177340] set string:52017-02-27 16:14:25.026335 dispatch_queue[3855:177340] context is : 52017-02-27 16:14:25.026338 dispatch_queue[3855:177396] destructor -----&gt;4 PS：dispatch_queue的知识大致如此，水平有限，如有错误之处，请及时指出]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Dispatch queue</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发的一些站点记录]]></title>
    <url>%2Ftech%2F2016%2F11%2F16%2FdeveloperSites%2F</url>
    <content type="text"><![CDATA[About Debug：理解和分析崩溃报告Objective-C 中提高log的方法 WWDC2018 About filesystemMac OS X Hidden Files &amp; Directories Inter Process CommunicationIPC For MacXPC原文XPC译文 Access control listsACLs- File MonitorFSEventStreamDemofswatch Deamon processLaunch DaemonsDaemons are managed by launchd on behalf of the OS in the system context, which means they are unaware of the users logged on to the system. A daemon cannot initiate contact with a user process directly; it can only respond to requests made by user processes. Because they have no knowledge of users, daemons also have no access to the window server, and thus no ability to post a visual interface or launch a GUI application. Daemons are strictly background processes that respond to low-level requests. Most daemons run in the system context of the system—that is, they run at the lowest level of the system and make their services available to all user sessions. Daemons at this level continue running even when no users are logged into the system, so the daemon program should have no direct knowledge of users. Instead, the daemon must wait for a user program to contact it and make a request. As part of that request, the user program usually tells the daemon how to return any results. For information about how to create a launch daemon, see Creating Launch Daemons and Agents.系统级，与用户无关并可适用于所有用户的进程可以使用守护进程，但守护进程无法直接发起与用户级进程的通信，只能被动等待用户级进程主动联系守护进程。 System Startup ProgrammingDeamon And AgentDesigning deamon and servicescrate Deamon or agentLaunchd.plist manual pageThe flow of create launch agent 启用和进制服务：1234启用服务launchctl load /path/to/plist禁用服务launchctl unload /path/to/plist run as root applicationAuthorization service]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mach 原语-学习笔记]]></title>
    <url>%2Ftech%2F2016%2F10%2F31%2FstudyNote-Mach%2F</url>
    <content type="text"><![CDATA[Mach 概述 Mach设计原则Mac OS X采用Mach作为锡系统的内核，其源头可以追溯到乔老爷创立的NeXT。Mach采用了极简主义概念:具有一个简单最小的核心，支持面向对象的模型，使得独立的具有良好定义的组件可以通过消息的方式互相通信。Mach只提供了一个极简的模型，操作系统本身可以在这个模型基础上实现，OS X的XNU是UNIX（FreeBSD 4.4）在Mach上的一个具体实现，Windows也采用了一些Mach的原则，不过其实现方式与Mac OS则完全不同。 Mach内核成为了一个底层的基础，它只关心驱动操作系统的最少需求，其余的功能则需要由上层来实现，尽管Mach对用户态也是可见的，使用Mach都是实现了深层次的核心功能，在这个基础上可以实现更大的内核，而Mach则是内核中的内核，XNU的官方API是BSD的POSIX API,Apple保持了Mach绝对的极简，基于Mach外层则有丰富的Cocoa API来支撑，因此Mach是Mac OS X操作系统中最关键最基础的部分 在Mach的所有都是通过自己的对象实现的。进程、线程、虚拟内存其实都是对象，所有的对象都有自己的属性，所谓的对象其实就是C语言的结构体加上函数指针实现的。 Mach的独特之处在于选择了通过消息传递的方式实现对象与对象之间的通信。而其他架构中一个对象要访问另一个对象则需要一个接口来实现。而Mach对象不能直接调用另一个对象，而是通过消息传递的方式，源发送一条消息，这条消息被加入到目标对象的队列中等待处理，类似，消息处理中可能会产生一个应答，该应答则通过另一条消息被发送回源对象，消息发送的方式是以FIFIO的方式保证了传输的可靠性，而内容则由发送者和接收者协商。 Mach 设计目标其最重要的目标是将所有的功能都移出内核，将功能放在用户态中去实现，保持内核极简，其主要功能如下: 控制点和执行单元(线程)管理 线程和线程组的资源分配 虚拟内存的分配和管理 底层物理资源的分配(即CPU、内存和其他任何物理设备) Mach只提供了实行策略的方法，而不提供策略本身，Mach也不会识别任何安全特性、优先级和选项(Options)，所有这些都需要上层去定义和实现。 Mach设计中有一个强大的优点:多处理(multi process)。内核中大部分的功能都是由独立的组件实现，组件之间的传递具有良好定义的消息，之间没有公共作用域，因此，没有必要所有的组件都在同一个处理器上执行，甚至不要求在同一台计算机上执行。理论上：Mach可以轻松扩展成计算机集群使用的操作系统。 Mach消息 消息是Mach中最基本的概念，通过短点(endpoint)或端口(port)之间传递，消息是Mach IPC的核心模块。 简单消息一条消息就像一个网络数据包，通过固定的包头进行封装，定义为BLOB(binary large object,二进制大对象)，在Mach中，消息定义在&lt;mach/message.h&gt;中12345typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125;mach_msg_base_t; 而消息头是强制要求的，其中定义了相关的元数据，内容如下：123456789typedef struct &#123; mach_msg_bits_t msgh_bits; //消息头的标识位 mach_msg_size_t msgh_size; //大小，以字节为单位 mach_port_t msgh_remote_port; //目标(发出的消息)或源(接收的消息) mach_port_t msgh_local_port; //源(发出的消息)或目标(接收的消息) mach_port_name_t msgh_voucher_port; // mach_msg_id_t msgh_id; //唯一ID&#125; mach_msg_header_t; 一条消息就是一个BLOB,通过端口发送到另一个端口并带有可选的标识；消息还可以选择带有一个消息尾(trailer),其定义如下:12345678typedef unsigned int mach_msg_trailer_type_t;typedef unsigned int mach_msg_trailer_size_t;typedef struct &#123; mach_msg_trailer_type_t msgh_trailer_type; mach_msg_trailer_size_t msgh_trailer_size;&#125; mach_msg_trailer_t; 每一种trailer类型都定义了一种特殊的trailer格式，这些格式都是为未来可以实现扩展的，下面是一些已经定义好的类型： trailer 用途 mach_msg_trailer_t 空trailer mach_msg_security_trailer_t 发送者安全令牌 mach_msg_seqno_trailer_t 顺序编号 mach_msg_audit_trailer_t，mach_msg_context_trailer_t 审计令牌(用于BSM) mach_msg_mac_trailer_t MAC策略标签 应答消息和内核消息使用到了trailer. 复杂消息除了简单的消息外，有一些带有额外的字段和结构的消息被称为”复杂消息”，它们是通过消息头标志中的MACH_MSGH_BITS_COMPLEX位来表示的，而且数据结构也不同：消息头后面跟着一个描述符计数字段，再接一个串行化的描述符 trailer 用途 MACH_MSG_PORT_DESCRIPTOR 传递一个端口权限 MACH_MSG_OOL_DESCRIPTOR 传递 out-of-line 数据 MACH_MSG_OOL_PORTS_DESCRIPTOR 传递 out-of-line 端口 MACH_MSG_OOL_VOLATILE_DESCRIPTOR 传递有可能发生变化(volatile)的out-of-line数据 以上是一些已规定的复杂消息描述符，其中out-of-line是Mach消息的一个重要特性，允许添加各种数据的分散指针，类似于电子邮件添加附件的功能，其64位的数据结构如下:12345678910111213141516typedef struct&#123; void* address; //指向数据的指针#if !defined(__LP64__) mach_msg_size_t size; //数据大小#endif boolean_t deallocate: 8; //发送之后是否解除分配 mach_msg_copy_options_t copy: 8; //复制指令 unsigned int pad1: 8; //预留参数 mach_msg_descriptor_type_t type: 8; //MACH_MSG_OOL_DESCRIPTOR#if defined(__LP64__) mach_msg_size_t size;#endif&#125; mach_msg_ool_descriptor_t; OOL描述了要附加的数据的地址和大小，一级如何处理数据的指令，例如是否可以解除分配，以及复制选项(如物理内存和虚拟内存的复制)。OOL描述符常用语传递大块的数据，能避免昂贵的复制操作。 发送消息Mach消息的发送和接收都是通过同一个API函数mach_msg()来完成的，该函数在用户态和内核态都有实现，其原型如下:1234567891011121314151617/* * Routine: mach_msg * Purpose: * Send and/or receive a message. If the message operation * is interrupted, and the user did not request an indication * of that fact, then restart the appropriate parts of the * operation silently (trap version does not restart). */__WATCHOS_PROHIBITED __TVOS_PROHIBITEDextern mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 123456789101112131415161718192021222324252627/* * Routine: mach_msg_overwrite * Purpose: * Send and/or receive a message. If the message operation * is interrupted, and the user did not request an indication * of that fact, then restart the appropriate parts of the * operation silently (trap version does not restart). * * Distinct send and receive buffers may be specified. If * no separate receive buffer is specified, the msg parameter * will be used for both send and receive operations. * * In addition to a distinct receive buffer, that buffer may * already contain scatter control information to direct the * receiving of the message. */__WATCHOS_PROHIBITED __TVOS_PROHIBITEDextern mach_msg_return_t mach_msg_overwrite( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit); 该函数接受一个消息缓冲区参数，对于发送操作是一个输入指针，对于接收操作是一个输出指针。该函数还有一个姊妹函数mach_msg_overwrite，允许调用者指定另外两个参数:一个是mach_msg_header_t*指向接收缓冲区，一个是mach_msg_size_t用于表示缓冲区大小。无论哪个函数，都可以通过按位操作选项来指定，具体的操作如下表： 选项标志位 用途 MACH_RCV_MSG 接收一条消息放在msg缓冲区 MACH_RCV_LARGE 如果接收缓冲区太小，则将过大的消息放在队列中，并且出错返回MACH_RCV_TOO_LARGE。在这种情况下，只返回消息头(指定消息的大小)，因此调用者可以分配更多的内存 MACH_RCV_TIMEOUT 单位是毫秒，如果接收超时，则出错返回MACH_RCV_TIMED_OUT。timeout值可以指定为0 MACH_RCV_NOTIFY 带通知的接收操作 MACH_RCV_INTERRUPT 允许操作被打断(返回MACH_RCV_INTERRUPT) MACH_RCV_OVERWRITW 在mach_msg_overwrite中，指定额外的参数：接收缓冲区参数，输入还是输出 MACH_SEND_MSG 发送msg缓冲区中的消息 MACH_SEND_INTERRUPT 允许发送操作被打断 MACH_SEND_TIMEOUT 发送超时，单位是毫秒。如果发送timeout秒后还未发送完成，则返回MACH_SEND_TIME_OUT MACH_SEND_NOTIFY 向通知端口通知消息的传递 MACH_SEND_ALWAYS 内部使用 MACH_SEND_TRAILER 表示一个已知的Mach trailer位于位置大小偏移的位置(也就是紧跟着消息缓冲区之后的位置，有点晦涩，笔者没看明白) MACH_SEND_CANCEL 取消一条消息(Lion中已经被移出了) Mach消息原本是为真正的微内核框架而设计的，也就是说mach_msg()必须在发送者和接收者之间复制消息所在的内存，这种实现方式忠于微内核的范式，但事实证明：频繁的复制内存所带来的性能消耗是无法忍受的。因此，XNU通过单一内核方式:所有的内核组件都共享同一个地址空间，这样传递消息的过程中只需要传递消息的指针的就可以了，从而省去了昂贵的内存复制操作。 为了实现消息的发送和接收，mach_msg()函数调用了一个Mach trap,在用户态调用mach_msg_trap()函数会引发陷阱机制，切换到内核态，而在内核态中，内核实现的mach_msg()会完成实际的工作。 端口端口是一个32位整型的标识符，不能按整数来操作，而是要按照透明的对象来操作。像一个端口发送消息实际是将消息放在一个队列中，直到消息能被接收者处理。所有的Mach原生对象都是通过对应的端口访问的，查找一个对象的句柄(Handle)时，实际上请求的是这个对象端口的句柄，访问端口是通过访问端口权限的方式进行的，Mach端口权限的定义如下: MACH_PORT_RIGHT_ 含义 SEND 向端口发送消息。允许多个发送者 RECEIVE 从端口读取消息，实际上这是对端口的所有权 SEND_ONCE 只发送一次消息，该权限在使用后立即被撤销(revoke)，成为DEAD_NAME PORT_SET 同时拥有多个端口的接受权限 DEAD_NAME 端口在SEND_ONCE之后用完了权限 关键是SEND和RECEIVE,而SEND_ONCE跟SEND一样，只不过只能发送一次。MACH_PORT_RIGHT_RECEIVE权限的持有者实际上是端口的所有者，这是允许从该端口读取队列消息的唯一实体。 &lt;mach/mach_port.h&gt;中的函数可以用于操纵任何端口，甚至可以在任务之外操纵。其中，mach_port_names函数可以导出给定任务的端口空间名称。 端口和权限也可以从一个实体传递到另一个实体。实际上，通过复杂消息将端口从一个任务传递到另一个任务并不罕见，这是IPC设计中的一个非常强大的特性，有点类似于UNIX中的domain socket允许在进程间传递描述符。Lion允许UNIX文件描述符和Mach端口相互转换。这些对象称为fileport，主要有通知系统使用。 Mach通过端口命名服务器注册全局的端口-即系统范围内的端口。在XNU中，这个“自举服务器”正是PID为1的launchd(8)，该进程注册自举服务器端口，由于系统的所有进程都是launchd的后代，因此从诞生起都集成了这个端口。 Mach 接口生成器(MIG)Mach没有使用专门的端口映射器(不过launchd(8)处理了一部分端口映射的逻辑）,但是Mach中有一个类似于rpcgen的组件，即Mach接口生成器(Mach Interface Generator)，简称MIG。rpcgen在经典UNIX中的SUN-RPC中，通过rpcgen编译器从IDL(Interface Definition Language, IDL)生成代码。]]></content>
      <categories>
        <category>OS Kernal</category>
      </categories>
      <tags>
        <tag>Mach</tag>
        <tag>MAC OS</tag>
        <tag>Mac内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mach 同步机制-学习笔记]]></title>
    <url>%2Ftech%2F2016%2F10%2F29%2FstudyNote-mach-synchronization%2F</url>
    <content type="text"><![CDATA[消息传递机制是 Mach IPC架构中的一个组件，另一个组件是同步机制(synchronization)，同步机制用于判定多个并发的操纵时，如何访问共享资源的问题。同步机制的本质是:排他访问的能力，即：在使用一个资源时，排除其它对象对该资源的访问的能力。最基本的同步原语是互斥(mutual exclusion)对象，也叫互斥体(mutex)。互斥体只不过是内核内存中的普通变量，硬件必须对这些变量进行原子(atomic)操作。意思是对互斥体的操作决不允许被打断，即使硬件中断也不能打断，在SMP系统上，互斥体还有一个要求就是要求硬件实现某种屏障(fence或barrier)。 下面是一些同步原语： 对象 实现的文件 所有者 可见性 等待 互斥体(lck_mtx_t) i386/i386_locks.c 1个 内核态 阻塞 信号量(semaphore_t) kern/sync_sema.c 多个 用户态 阻塞 自旋锁(hw_lock_t等) i386/i386_locks.s 1个 内核态 忙等 锁集(lock_set_t) kern/sync_lock.c 1个 用户态 阻塞(同互斥体) Mach锁由两个层次组成： 硬件相关层: 通过硬件的特性，通过特定的汇编指令实现的原子性和互斥性。 硬件无关层: 通过API包装硬件特定的调用，是通过简单的宏来实现的；这些API使得基于Mach的上层完全不用关心细节的实现。 锁组对象大部分Mach的同步对象都不是独立存在的，而是属于lck_grp_t对象,typedef struct __lck_grp__ lck_grp_t;;锁组(lock group)对象定义结构如下：123456789101112131415161718#define LCK_GRP_MAX_NAME 64typedef struct _lck_grp_ &#123; queue_chain_t lck_grp_link; unsigned int lck_grp_refcnt; unsigned int lck_grp_spincnt; unsigned int lck_grp_mtxcnt; unsigned int lck_grp_rwcnt; unsigned int lck_grp_attr; char lck_grp_name[LCK_GRP_MAX_NAME]; lck_grp_stat_t lck_grp_stat;&#125; lck_grp_t;#define LCK_GRP_NULL (lck_grp_t *)0#elsetypedef struct __lck_grp__ lck_grp_t;#endif lck_grp_t就是一个链表中的一个元素，有一个指定的名字，以及最多三种类型的锁:自旋锁、互斥体和读写锁。其中lck_grp_stat_t提供锁组的统计信息功能，用于调试和同步相关的问题。lck_grp_attr可以用来设置一个LCK_ATTR_DEBUG属性。 锁组的创建和销毁API如下：1234//创建新的锁组； 锁组通过grp_name标识，拥有attr指定的属性，一般情况下，都是通过lck_grp_attr_alloc_init()设置默认属性。extern void lck_grp_init(lck_grp_t *grp, const char *grp_name, lck_grp_attr_t *attr);//接触分配锁组extern void lck_grp_free(lck_grp_t *grp); 在Mach和BSD中，几乎每个子系统在初始化时都会创建一个自己使用的锁组。 互斥体对象互斥体(lck_mtx_t)是最常用的锁对象,它必须属于一个锁组，相关的API如下表： 1234567891011121314151617181920212223242526272829//通过指定的grp和attr,创建并初始化新的互斥体对象extern lck_mtx_t *lck_mtx_alloc_init(lck_grp_t *grp, lck_attr_t *attr);//初始化已经分配的互斥体lck.extern void lck_mtx_init(lck_mtx_t *lck, lck_grp_t *grp, lck_attr_t *attr);//对互斥体上锁，如果重复上锁会产生阻塞extern void lck_mtx_lock(lck_mtx_t *lck);//对互斥体尝试上锁，如果不成功则返回失败extern boolean_t ck_mtx_try_lock(lck_mtx_t *lck);//对互斥体解锁extern void lck_mtx_unlock(lck_mtx_t *lck);//将互斥体标记为销毁，互斥体将不可以继续使用，但依然占据内存空间，可以重新对其初始化。extern void lck_mtx_destroy(lck_mtx_t *lck,lck_grp_t *grp);//将互斥体标记为销毁，并释放其内存空间。extern void lck_mtx_free(lck_mtx_t *lck,lck_grp_t *grp);//将当前线程置于睡眠状态，直到lck变为可用状态extern wait_result_t lck_mtx_sleep(lck_mtx_t *lck, ck_sleep_action_t lck_sleep_action, event_t event, wait_interrupt_t interruptible);//将当前线程置于睡眠状态，直到lck变为可用状态或到达deadline的时限extern wait_result_t lck_mtx_sleep_deadline(lck_mtx_t *lck, lck_sleep_action_t lck_sleep_action, event_t event, wait_interrupt_t interruptible, uint64_t deadline); 互斥锁有一个很大的缺点：就是一次只能由一个线程持有锁对象。在很多情况下，多线程可能对资源请求只读的访问。在这些情况下，使用互斥体会阻止并发的访问，即使这些线程之间并不会相互影响，这就带来了性能的瓶颈。 读写锁对象读写锁(read-write lock)的设计初衷就是为了解决互斥锁的缺点。它是更智能的互斥锁，能够区分读写访问，多个只读的线程可以同时持有读写锁，而一次只允许一个写的线程可以获得锁，当一个写的线程持有锁是，其余线程的锁都将被阻塞。跟mutex lock相似，下面是读写锁相关的API:123456789101112131415161718192021222324252627282930extern lck_rw_t *lck_rw_alloc_init(lck_grp_t *grp, lck_attr_t *attr);extern void lck_rw_init(lck_rw_t *lck, lck_grp_t *grp, lck_attr_t *attr);extern void lck_rw_lock_shared(lck_rw_t *lck);extern void lck_rw_unlock_shared(lck_rw_t *lck);extern void lck_rw_lock_exclusive(lck_rw_t *lck);extern void lck_rw_unlock_exclusive(lck_rw_t *lck);//加锁//如果当前线程是读，当有写的线程持有锁时，当前线程调用会被阻塞//如果当前线程是写，当有其他线程获得锁时，调用会被阻塞//这个API等同于lck_rw_lock_shared + lck_rw_lock_exclusion extern void lck_rw_lock(lck_rw_t *lck, lck_rw_type_t lck_rw_type);////这个API等同于lck_rw_unlock_shared + lck_rw_unlock_exclusionextern void lck_rw_unlock(lck_rw_t *lck, lck_rw_type_t lck_rw_type);extern void lck_rw_destroy(lck_rw_t *lck, lck_grp_t *grp);extern void lck_rw_free(lck_rw_t *lck, lck_grp_t *grp);//action 可以是LCK_SLEEP_SHARED 和 LCK_SLEEP_EXCLUSION.extern wait_result_t lck_rw_sleep(lck_rw_t *lck, lck_sleep_action_t lck_sleep_action, event_t event, wait_interrupt_t interruptible);extern wait_result_t lck_rw_sleep_deadline(lck_rw_t *lck, lck_sleep_action_t lck_sleep_action, event_t event, wait_interrupt_t interruptible, uint64_t deadline); 信号量对象Mach提供了信号量(Semaphore)，信号量是一种泛化的互斥体，互斥体只能是0和1，而信号量是可以将取值达到某个整数时就允许持有信号量的线程同时执行的这样一种互斥体，信号量在用户态使用，而互斥体只能在内核态使用。 Mach中的信号量和POSIX中的信号量不同，API也不同，因此两者不相容，在XNU上，POSIX信号量的底层实现是通过Mach的信号量实现的。POSIX中的sem_open()函数其实调用了Mach的semaphore_create()函数 信号量本身是一个不可锁的对象，拥有很小的结构体，包含了所有者和端口的引用，还包括了一个wait_queue_t用来保证正在等待这个信号量的线程的链表，wait_queue_t会通过硬件锁的方式锁定。下面是信号量对象的结构体:12345678910111213141516171819202122#ifdef MACH_KERNEL_PRIVATEtypedef struct semaphore &#123; queue_chain_t task_link; /* chain of semaphores owned by a task */ struct wait_queue wait_queue; /* queue of blocked threads &amp; lock */ task_t owner; /* task that owns semaphore */ ipc_port_t port; /* semaphore port */ int ref_count; /* reference count */ int count; /* current count value */ boolean_t active; /* active status */&#125; Semaphore;#define semaphore_lock(semaphore) wait_queue_lock(&amp;(semaphore)-&gt;wait_queue)#define semaphore_unlock(semaphore) wait_queue_unlock(&amp;(semaphore)-&gt;wait_queue)extern void semaphore_init(void);extern void semaphore_reference (semaphore_t semaphore);extern void semaphore_dereference (semaphore_t semaphore);#endif /* MACH_KERNEL_PRIVATE */ 下面列出了Mach中 信号量的相关API:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * Routine: semaphore_create * * Creates a semaphore. * The port representing the semaphore is returned as a parameter. * 为task创建一个信号量new_semaphore,policy表示阻塞的线程如何被唤醒，使用的是和锁策略相同的值。 */kern_return_t semaphore_create(task_t task, semaphore_t *new_semaphore, int policy, int value)/* * Routine: semaphore_destroy * * Destroys a semaphore. This call will only succeed if the * specified task is the SAME task name specified at the semaphore's * creation. * * All threads currently blocked on the semaphore are awoken. These * threads will return with the KERN_TERMINATED error. */kern_return_t semaphore_destroy( task_t task, semaphore_t semaphore)/* * Routine: semaphore_signal * * Traditional (in-kernel client and MIG interface) semaphore * signal routine. Most users will access the trap version. * * This interface in not defined to return info about whether * this call found a thread waiting or not. The internal * routines (and future external routines) do. We have to * convert those into plain KERN_SUCCESS returns. * 增加信号量计数，如果计数器大于等于0，则唤醒一个阻塞的线程。 */kern_return_t semaphore_signal(semaphore_t semaphore)/* * Routine: semaphore_signal_all * * Awakens ALL threads currently blocked on the semaphore. * The semaphore count returns to zero. * 将计数器值置为0，并唤醒所有阻塞的线程。 */kern_return_t semaphore_signal_all(semaphore_t semaphore)/* * Routine: semaphore_wait * * Traditional (non-continuation) interface presented to * in-kernel clients to wait on a semaphore. * 减去一个信号量计数，如果小于0，则阻塞知道计数器再次变为非负数。 */kern_return_t semaphore_wait(semaphore_t semaphore) 信号量的属性可以让信号量转换为端口，也可以由端口转换回来，ipc_sync.c中定义了这些操作的函数，但该功能并不为用户态暴露，内核态也未使用。 自旋锁对象互斥体和信号量都是阻塞等待的对象。如果所被其他线程持有，那么请求将被加入到等待队列，当前线程处于阻塞状态，阻塞线程意味着放弃线程的时间片，把处理器让给调度器认为下一个要执行的线程。当锁可用时，调度器得到通知再根据判断将线程从等待队列中取出并重新调度。然而这种方式可能会严重的影响性能，在大多数情况下，锁对象可能只需要短短几个周期的时间，因为造成两次或更多次的上下文切换带来的开销非常大，在这种case下，如果线程不阻塞而是继续重复尝试访问锁对象所带来的开销可能会小得多，这种方式被称为“忙等(busy-wait)”。 然而上面说的case只是一种假设，按照这种方式自旋等待的线程很可能会陷入无限的循环等待中，这会造成一个非常恐怖的死锁场景，甚至整个系统会因此陷入停滞状态。 基础的自旋锁(spinlock)类型是硬件相关的hw_lock_t。其它的自旋锁类型都是实现在它之上： lck_spin_t、simple_lock_t、usimple_lock_t等。 这些自旋锁的的API和其它类型所得API都差不多，详参: 自旋锁API simple lock 锁集对象任务在用户态可以使用锁集，概念上，锁集对象就是锁的数组，实际上是互斥体的数组，通过给定的ID可以访问锁，锁可在线程之间传递，锁集是lck_mtx_t的封装下面是相关的函数：1234567891011121314151617181920212223242526272829//为task创建一个lock_set,锁的数量是locks个，policy用于指定唤醒锁的策略，主要有// SYNC_POLICY_FIFO 先进先出原则// SYNC_POLICY_FIXED_PROIRITY 根据指定的优先级原则kern_return_t lock_set_create(task_t task, lock_set_t lock_set, int locks, int policy);//销毁锁集及所包含的锁kern_return_t lock_set_destroy(task_t task, lock_set_t lock_set);//通过lock_id从lock_set中获取指定的锁，该函数可能会永久阻塞如果指定的锁已经被另外的线程控制了。kern_return_t lock_acquire(lock_set_t lock_set, int lock_id);//通过lock_id释放锁集中指定的锁，如果调用的线程不拥有该锁，则会调用失败kern_return_t lock_release(lock_set_t lock_set, int lock_id);//尝试获取锁，如果锁已经被持有了则立即返回KERN_LOCK_OWNEDkern_return_t lock_try(lock_set_t lock_set, int lock_id);//该函数清除锁集的不稳定状态，将锁集置于稳定状态。kern_return_t lock_make_stable(lock_set_t lock_set,int lock_id);//将当前线程拥有的锁交出，并传递给匿名的接受线程，如果接受线程没有等待接收该锁，则会造成线程阻塞，知道接收线程接收为止。//The lock_handoff function passes lock ownership from the calling thread to an anonymous accepting thread. //The lock must be owned by the calling thread. If the accepting thread is not waiting to receive the lock, //the calling thread will block until the hand-off is accepted.kern_return_t lock_handoff(lock_set_t lock_set, int lock_id);//接收一个匿名线程通过lock_handoff传递的锁，如果发送锁的线程没有等待切换锁，//则调用的线程将造成阻塞，知道锁切换完成，任何指定的时间只能有一个线程可能正在接受锁切换kern_return_t lock_handoff_accept(lock_set_t lock_set,int lock_id); 锁集的有趣之处在于允许锁在线程之间传递。Mach在调度中也使用了这个概念，允许一个线程放弃处理器并指定由另一个线程来接替运行。]]></content>
      <categories>
        <category>OS Kernal</category>
      </categories>
      <tags>
        <tag>Mach同步机制，同步，mutex，自旋锁，信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC-进程间通信-学习笔记]]></title>
    <url>%2Ftech%2F2016%2F10%2F28%2FstudyNote-IPC%2F</url>
    <content type="text"><![CDATA[进程间通信的基础原语: 消息、端口、已经确保并发安全的信号量和锁。这篇文章主要对于这些原语的底层实现和端口的内部实现做一些探讨。 Mach任务是一个对应于进程的高层次抽象，Mach任务包含了一个指向自己的IPC namespace（命名空间），在命名空间中保存了自己的端口，此外mach任务也可以获得系统范围内的端口，如：主机端口、特权端口和其它端口。 端口 导出给用户空间的端口对象(mach_port_t)实际上是对”真正”端口对象的一个句柄，后者是ipc_port_t，其数据结构如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* * A receive right (port) can be in four states: * 1) dead (not active, ip_timestamp has death time) * 2) in a space (ip_receiver_name != 0, ip_receiver points * to the space but doesn't hold a ref for it) * 3) in transit (ip_receiver_name == 0, ip_destination points * to the destination port and holds a ref for it) * 4) in limbo (ip_receiver_name == 0, ip_destination == IP_NULL) * * If the port is active, and ip_receiver points to some space, * then ip_receiver_name != 0, and that space holds receive rights. * If the port is not active, then ip_timestamp contains a timestamp * taken when the port was destroyed. */typedef unsigned int ipc_port_timestamp_t;typedef unsigned int ipc_port_flags_t;struct ipc_port &#123; /* * Initial sub-structure in common with ipc_pset and rpc_port * First element is an ipc_object */ struct ipc_object ip_object; //ipc对象，初始化子结构跟ipc_pset和rpc_port一致。 union &#123; struct ipc_space *receiver; //指向接收者的IPC指针 struct ipc_port *destination; //指向全局端口的指针 ipc_port_timestamp_t timestamp; &#125; data; ipc_kobject_t ip_kobject; mach_port_mscount_t ip_mscount; mach_port_rights_t ip_srights; mach_port_rights_t ip_sorights; struct ipc_port *ip_nsrequest; struct ipc_port *ip_pdrequest; struct ipc_port_request *ip_dnrequests; unsigned int ip_pset_count; struct ipc_mqueue ip_messages; //消息队列 struct ipc_kmsg *ip_premsg;#if NORMA_VM /* * These fields are needed for the use of XMM. * Few ports need this information; it should * be kept in XMM instead (TBD). XXX */ long ip_norma_xmm_object_refs; struct ipc_port *ip_norma_xmm_object;#endif#if MACH_ASSERT#define IP_NSPARES 10#define IP_CALLSTACK_MAX 10 queue_chain_t ip_port_links; /* all allocated ports */ natural_t ip_thread; /* who made me? thread context */ unsigned long ip_timetrack; /* give an idea of "when" created */ natural_t ip_callstack[IP_CALLSTACK_MAX]; /* stack trace */ unsigned long ip_spares[IP_NSPARES]; /* for debugging */#endif /* MACH_ASSERT */ int alias;&#125;; 消息传递的实现 用户态的Mach消息传递使用的函数是mach_msg()函数，这个函数通过内核的Mach trap调用内核函数mach_msg_trap()。然后mach_msg_trap调用mach_msg_overwrite_trap(),mach_msg_overwrite_trap通过测试MACH_SEND_MSG和MACH_RCV_MSG标志位来判断是发送操作还是接收操作。 下面分析IPC最重要的两个函数mach_msg_send()和mach_msg_receive()的实现 发送消息Mach 消息发送的核心逻辑在内核中有两处实现: mach_msg_overwrite_trap()和mach_msg_send()。后者只用于内核态的消息传递，对用户态不可见。两处实现的逻辑大同小异并遵循以下流程： 调用current_space()来获取当前的IPC空间。 调用current_map()来获取当前VM空间(vm_map) 对消息的大小进行正确性检查。 计算要分配的消息大小，从send_size参数获得大小再加上硬编码的MAX_TRAILER_SIZE。 通过ipc_kmsg_alloc分配消息。 复制消息(复制消息send_size字节的部分)，然后在消息头设置msgh_size。 复制消息关联的端口权限，然后通过ipc_kmsg_copyin将所有的OOL数据的内存复制到当前的vm_map。 ipc_kmsg_copyin函数调用了ipc_kmsg_copyin_header和ipc_kmsg_copyin_body。 调用ipc_kmsg_send()发送消息： 获得msgh_remote_port引用，并锁定端口。 如果该端口是一个内核端口（即端口的ip_receiver是内核的IPC空间），那么通过ipc_kobject_server()函数处理消息。该函数会在内核中找到相应的函数来执行消息，还会生成消息的应答。 不论哪种端口，调用ipc_mqueue_send(),这个函数将消息直接复制到端口的ip_messages队列中并唤醒任何正在等待的线程处理消息。 接收消息Mach接收消息的方式个发送类似，也体现在内核的两个地方，mach_msg_overwrite_trap()用用户态接收请求，而内核通过mach_msg_receive()函数接收消息。 调用current_space()来获取当前的IPC空间 调用current_map() 不校对消息大小，因为发送的时候已经校对过了 通过调用ipc_mqueue_copyin()获取IPC队列 持有当前线程的一个引用。使用当前线程的引用可使它适合使用Mach的续体模型，续体(continuation)模型可以表面维护完整线程栈的必要性。续体是撒玩意儿博主也弄不明白 调用ipc_mqueue_receive()从队列中取出消息 调用mach_msg_receive_results()函数，该函数也可以从续体中调用]]></content>
      <categories>
        <category>OS Kernal</category>
      </categories>
      <tags>
        <tag>进程间通信</tag>
        <tag>进程</tag>
        <tag>Process Communication</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2Ftech%2F2016%2F07%2F15%2Fgit-useage%2F</url>
    <content type="text"><![CDATA[该文记录git常用命令和使用方法，记录的博主平时工作所需的一些基础命令，并不能保证完整性和正确性，一般情况下的git使用基本上是满足的，当然如果您有一些特殊的需求，还是需要多查阅官方文档 git权威指南 git help 查看帮助文档12git help init//查看git init 的帮助文档命令，其余的类推 git init 初始化Git仓库1git init Create an empty Git repository or reinitialize an existing one命令执行后，在当前目录生成一个.git的隐藏目录，内含git仓库需要的资源。更多用法 git clone 克隆仓库1git clone http://code.site.you.clone localpath http://code.site.you.clone 更换成你克隆的地址localpath 指定你本地克隆的地址，也可省去，默认是克隆到当前路径下更多用法 git remote 远程仓库1234567891011121314151617181920212223git remote//显示本地已设置的远程仓库的keygit remote -v //查看本地仓库指向的远程仓库地址, `-v` == `--verbose`git remote set-url origin https://remote.site.com //设置远程仓库地址git remote add origin https://remote.site1.comgit remote add bookmark1 https://remote.site2.com//添加远程仓库地址，注意origin bookmark1在本地是唯一的，多个远程地址bookmark不能重复git remote get-url origingit remote get-url bookmark1//获取指定bookmark对应的远程仓库地址git remote rename bookmark1 bookmark2//更改bookmark名git remote remove bookmark2//通过bookmark删除本地远程仓库 更多用法 git config 配置1234567891011121314151617181920git config --global//使用全局配置文件git config --system//使用系统配置文件git config --local//使用本地仓库的配置文件git config -f filepath//使用指定路径下的配置文件git config -l //列出配置文件信息列表git config --global/--systme/--local user.name "yourname"//配置全局/系统/本地仓库的commit时的用户名git config --global/--systme/--local user.email "youremail"//配置全局/系统/本地仓库的commit时的邮箱 以上内容熟悉后，本地仓库克隆及commit及push基本已经可以了，关于多账号的sshkey问题，请左转 git branch 分支操作1234567891011121314151617181920212223242526272829303132333435git branch git branch --list//显示本地已有的分支git branch newBranch//创建本地newBranch分支，不切换当前分支git branch -a //显示本地和远程已有的分支列表git branch -d theBranch//删除theBranch,有两种情况无法删除.//1.当前分支就是theBranch,你需要切换到其它分支删除theBranch分支；//2.theBranch分支的代码没有完全合并，首先你需要把代码合并到其它需要合并的分支。git branch -D theBranch//强行删除theBranch,如果当前分支在theBranch,则删除失败。git push origin :theBranch//删除远程theBranch分支git branch -m theBranch newBranch//将theBranch分支 更名为 newBranch分支，git reflog的所有结果也将同时变更git branch -M theBranch newBranch//官方定义，`move/rename a branch, even if target exists`，个人感觉非常不安全的操作方式.git branch -v//打印当前分支最后一次commit的文件列表git branch --merged//仅打印已经合并过的分支列表git branch --no-merged//仅打印未合并的分支列表 更多用法 git status 代码状态12345git status //获取working copy的代码状态git status -s//更简单的展示working copy代码变更 更多用法 git stash 代码暂存123456789101112131415161718192021222324git stash //将当前分支的代码暂存git stash pop //将最后一次暂存的代码恢复git stash save "some description"//给暂存内容定义一个描述：some descriptiongit stash -p path/to/file//暂存某一个文件的内容，执行命令后要选择'y',暂存成功后，该文件将从本地变更中移出。git stash -p -- path/to/file1 path/to/file2//暂存多个文件内容，执行命令后需要多次选择‘y’,使用git stash pop即可恢复暂存代码git stash list//列出所有stash列表git stash pop 1//取出index为1的暂存数据git stash drop//丢弃最后一次代码暂存内容 更多用法 git add 添加到本地仓库12345678git add .//将当前变更添加到本地仓库git add . -v//将当前变更添加到本地仓库，并显示细节 `-v` == `--verbose`git add . -e//使用vim打开已变更内容文件，可编辑，:wq保存后添加到本地仓库 更多用法 git rm 删除文件12345678git rm filepath//删除指定的文件，该文件必须被git标记为tracked的文件git rm --cached filepath//从staged中删除filepath，filepath文件将变更为untracked状态，不会真正将文件删除掉git rm -f filepath//强制将filepath文件删除掉，同时该文件的所有记录也将从git的快照中删除。 更多用法 git commit 提交代码12345678git commit -m "your commit message" //直接通过命令行输入提交信息，并将代码提交到本地仓库git commit//使用vim打开本次提交内容，在vim中输入详细的提交信息,一般`git merge`后解决冲突使用这种方式更恰当git commit --amend//使用vim打开上次提交message,`:wq`保存后作为本次提交信息提交到本地仓库 更多用法 git checkout 分支创建切换1234567891011121314git checkout anotherBranch//从当前分支切换到anotherBranch分支git checkout -b newBranch//创建一个新的分支newBranch并切换到newBranch分支git checout -B oneBranch//创建或重置oneBranch分支并切换到oneBranch分支。git checkout .//将本地所有变更内容reset到当前分支的HEAD状态，即undo本地所有变更内容git checkout -- path/to/file1 path/to/file2//undo部分本地文件变更 更多用法 git pull12345git pull//默认拉取当前所在分支的全程分支代码，并合并到本地分支git pull origin branch//拉取远程变更历史，并合并变更 更多用法 git fetch12345git fetch //拉取仓库默认远端的所有历史git fetch bookmark//拉取仓库指定的bookmark指向的远端所有历史 更多用法 git rebase12git rebase branch//将branch分支的代码rebase到当前分支 rebase 和 merge 之间的使用，一直是比较有争议的，博主两个都使用，都遇到一些不好处理的地方，这里不做评价，请自行查阅官方文档。更多用法 git merge12345git merge branch//合并本地branch分支代码到当前分支git merge bookmark branch//合并bookmark所在的远程branch分支代码到当前分支 更多用法 git push123456789101112131415git push //将已提交至本地仓库代码push到远程分支，默认push到本地分支所对应的远程分支git push origin thebranch//将已提交至本地仓库代码push到远程指定的thebranch分支上，如果没有则创建.git push origin thebranch -v//功能同上，同时展示更多细节git push origin thebranch -q//功能同上，尽可能的省略更多细节 跟`-v`相反git push origin thebranch -f git push -f//强制push到远程thebranch分支或当前分支所对应的远程分支 更多用法 git mv 文件移动12git mv file_from file_to//将file_from文件更名为file_to 更多用法 git log12345678git log //查看当前分支提交记录,按`q`退出git log --oneline --decorate//查看提交记录，可在头部查看当前HEAD指针指向哪个分支git log --oneline --decorate --graph --all//查看提交记录，并且可以看到当前HEAD指针指向，同时可以看到分支结构图。 更多用法 git tag123456789101112131415161718192021222324252627282930313233git tag//查看tag列表git tag -l //查看tag列表,等同于 git tag --listgit tag -l "v1.2*"//列出所有tag中包括v1.2前缀的tag列表git tag -a v1.2 -m "your tag descrption”"//以当前分支创建v1.2tag，tag的信息为“your tag descrption”git show v1.2//显示tag v1.2的详细信息git tag v1.3 -lw//轻量级的tag,仅仅是打一个tag名，不支持跟-a -s或-m可选参数git push origin v1.4//将v1.4的tag push到远端仓库git push origin --tags//将一对tagspush到服务端git tag -d v1.4//删除v1.4所指的taggit checkout v1.4//将当前working copydetach到HEAD状态，显示v1.4tag所指的内容git checkout -b v14branch v1.4//以v1.4tag为基准创建一个新的分支v14branch，并切换当前working copy到v14branch 更多用法 git reflog12git reflog //查看所有分支的提交记录和操作过程，按`q`退出 更多用法 git diff1234567891011git diff filepath//查看filepath下的文件的变更 git diff branchName filepath//当前分支的filepath文件与branchName分支的filepath文件对比 git diff HEAD filepath//查看filepath文件与HEAD所指向的节点的filepath文件对比git diff commitId filepath//当前分支的filepath文件与指定commitId的提交时的filepath文件对比 更多用法 git reset 代码回滚12345678910111213141516git reset HEAD//将当前分支节点指向HEAD节点，其实没任何变化git reset HEAD~1//将当前分支指向HEAD节点的上一个节点,并将上一次提交的内容回滚.git reset commitID//将当前分支指向commitID指向的节点,并将commit节点之后所提交的所有内容回滚.git reset --soft commitID//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容回滚.git reset --hard commitID//将当前分支节点指向commitID指向的节点位置，并将commitID节点之后的提交内容全部删除.//如果commitID之后的内容没有被push到远端服务器，那么`git reset --hard`将是非常危险的操作。 更多用法 git reset 是具有一定危险性的操作方式，博主希望大家在执行命令前，一定先测试一下命令是否正确，是否能达到你想要的要求，千万不可带着试一试的态度去执行git reset --hard命令，很可能会导致你的代码丢失. git alias12345678910111213141516171819git config --global alias.co checkoutgit co branch //等同于 git checkout branchgit config --global alias. br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage 'reset HEAD --'git unstage filepath//等同于 git reset HEAD -- filepathgit config --global alias.last 'log -1 HEAD'git last//查看最后一次commit日志git config --global alias.visual '!gitk'//maybe you want to run an external command, rather than a Git subcommand. In that case, //you start the command with a ! character. This is useful if you write your own tools that work with a Git repository. git version 查看版本信息12git --version//查看当前系统下的git版本信息 git fsck –lost-found找回已经删除的文件，但是存在着add记录，博主未测试链接 git ls-files 列出工程的所有忽略文件1git ls-files --other --ignored --exclude-standard 友情推荐 git学习网站]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用笔记]]></title>
    <url>%2Ftech%2F2016%2F04%2F06%2FMac%20useage%2F</url>
    <content type="text"><![CDATA[显示隐藏文件： 显示: defaults write com.apple.finder AppleShowAllFiles -bool true隐藏: defaults write com.apple.finder AppleShowAllFiles -bool falserestart your mac 常用网址 MAC OS OpenSource Mach IPC Interfacexxxx xxxx xxxx Class-dump通过可执行文件反解析头文件class-dump -H [.app文件的路径] -o [输出文件夹路径]]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X系统下IPC方案及对比 (未完)]]></title>
    <url>%2Ftech%2F2015%2F09%2F06%2FIPC-methods-and-compare%2F</url>
    <content type="text"><![CDATA[前言优质文章推荐 Apple介绍 Interprocess communication]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>进程间通信</tag>
        <tag>MachPort</tag>
        <tag>NSNotificationCenter</tag>
        <tag>PosixSemaphore</tag>
        <tag>Socket</tag>
        <tag>XPC</tag>
        <tag>Pastboard粘贴板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X文件权限控制（未完结）]]></title>
    <url>%2Ftech%2F2015%2F02%2F22%2Fosx-permisson-control%2F</url>
    <content type="text"><![CDATA[用到的工具或技术点chmodchflagsetFileGetFileInfo hidden &amp; nohidden文件在GUI上隐藏和显示，但在命令行中使用ls依然可以看到该文件12$ chflags hidden file$ chflags nohidden file apaque &amp; noapaque12$ chflags apaque file$ chflags noapaque file uchg &amp; nouchg12chflags uchg filechflags nouchg file 递归加解锁12chflags -R uchg folderchflags -R nouchg folder schg &amp; noschg控制文件权限12$ sudo chflags schg file$ sudo chflags noschg file 设置文件的type,该type不能再file attributes中显示，但可以通过GetFileInfo获取12$ setFile -t "ABCD" file$ GetFileInfo -t file]]></content>
  </entry>
</search>
